
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model UserStreak
 * 
 */
export type UserStreak = $Result.DefaultSelection<Prisma.$UserStreakPayload>
/**
 * Model UserQuizAttempt
 * 
 */
export type UserQuizAttempt = $Result.DefaultSelection<Prisma.$UserQuizAttemptPayload>
/**
 * Model UserQuestionAttempt
 * 
 */
export type UserQuestionAttempt = $Result.DefaultSelection<Prisma.$UserQuestionAttemptPayload>
/**
 * Model LastActivity
 * 
 */
export type LastActivity = $Result.DefaultSelection<Prisma.$LastActivityPayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model Badge
 * 
 */
export type Badge = $Result.DefaultSelection<Prisma.$BadgePayload>
/**
 * Model CoinWallet
 * 
 */
export type CoinWallet = $Result.DefaultSelection<Prisma.$CoinWalletPayload>
/**
 * Model CoinTransaction
 * 
 */
export type CoinTransaction = $Result.DefaultSelection<Prisma.$CoinTransactionPayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model RoadmapProgress
 * 
 */
export type RoadmapProgress = $Result.DefaultSelection<Prisma.$RoadmapProgressPayload>
/**
 * Model RoadmapStep
 * 
 */
export type RoadmapStep = $Result.DefaultSelection<Prisma.$RoadmapStepPayload>
/**
 * Model Tutorial
 * 
 */
export type Tutorial = $Result.DefaultSelection<Prisma.$TutorialPayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model AdminActivityLog
 * 
 */
export type AdminActivityLog = $Result.DefaultSelection<Prisma.$AdminActivityLogPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ActivityType: {
  BADGE: 'BADGE',
  COINS: 'COINS',
  LOGIN: 'LOGIN',
  QUIZ: 'QUIZ',
  ROADMAP: 'ROADMAP',
  STEP: 'STEP',
  TUTORIAL: 'TUTORIAL',
  TRANSACTION: 'TRANSACTION',
  XP: 'XP',
  LEVEL: 'LEVEL'
};

export type ActivityType = (typeof ActivityType)[keyof typeof ActivityType]


export const DifficultyLevel: {
  EASY: 'EASY',
  HARD: 'HARD',
  MEDIUM: 'MEDIUM'
};

export type DifficultyLevel = (typeof DifficultyLevel)[keyof typeof DifficultyLevel]


export const RoadmapType: {
  AI: 'AI',
  BACKEND: 'BACKEND',
  DEVOPS: 'DEVOPS',
  FRONTEND: 'FRONTEND',
  FULLSTACK: 'FULLSTACK',
  DATA_SCIENCE: 'DATA_SCIENCE',
  MOBILE: 'MOBILE',
  MACHINE_LEARNING: 'MACHINE_LEARNING',
  MERN: 'MERN',
  MEAN: 'MEAN',
  BLOCKCHAIN: 'BLOCKCHAIN',
  CYBER_SECURITY: 'CYBER_SECURITY',
  GAMING: 'GAMING',
  CLOUD: 'CLOUD',
  SOFTWARE_TESTING: 'SOFTWARE_TESTING'
};

export type RoadmapType = (typeof RoadmapType)[keyof typeof RoadmapType]


export const StepStatus: {
  COMPLETED: 'COMPLETED',
  IN_PROGRESS: 'IN_PROGRESS',
  NOT_STARTED: 'NOT_STARTED'
};

export type StepStatus = (typeof StepStatus)[keyof typeof StepStatus]


export const TagType: {
  GLOBAL: 'GLOBAL',
  QUIZ: 'QUIZ',
  ROADMAP: 'ROADMAP',
  TUTORIAL: 'TUTORIAL'
};

export type TagType = (typeof TagType)[keyof typeof TagType]


export const ThemeName: {
  DARK: 'DARK',
  LIGHT: 'LIGHT'
};

export type ThemeName = (typeof ThemeName)[keyof typeof ThemeName]


export const TransactionType: {
  EARNED: 'EARNED',
  PENALTY: 'PENALTY',
  REWARD: 'REWARD',
  SPENT: 'SPENT',
  ALL: 'ALL'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TutorialStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  PUBLISHED: 'PUBLISHED'
};

export type TutorialStatus = (typeof TutorialStatus)[keyof typeof TutorialStatus]


export const UnitType: {
  CHALLENGE: 'CHALLENGE',
  LESSON: 'LESSON',
  QUIZ: 'QUIZ'
};

export type UnitType = (typeof UnitType)[keyof typeof UnitType]


export const UserRole: {
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]

}

export type ActivityType = $Enums.ActivityType

export const ActivityType: typeof $Enums.ActivityType

export type DifficultyLevel = $Enums.DifficultyLevel

export const DifficultyLevel: typeof $Enums.DifficultyLevel

export type RoadmapType = $Enums.RoadmapType

export const RoadmapType: typeof $Enums.RoadmapType

export type StepStatus = $Enums.StepStatus

export const StepStatus: typeof $Enums.StepStatus

export type TagType = $Enums.TagType

export const TagType: typeof $Enums.TagType

export type ThemeName = $Enums.ThemeName

export const ThemeName: typeof $Enums.ThemeName

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TutorialStatus = $Enums.TutorialStatus

export const TutorialStatus: typeof $Enums.TutorialStatus

export type UnitType = $Enums.UnitType

export const UnitType: typeof $Enums.UnitType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userStreak`: Exposes CRUD operations for the **UserStreak** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserStreaks
    * const userStreaks = await prisma.userStreak.findMany()
    * ```
    */
  get userStreak(): Prisma.UserStreakDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userQuizAttempt`: Exposes CRUD operations for the **UserQuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuizAttempts
    * const userQuizAttempts = await prisma.userQuizAttempt.findMany()
    * ```
    */
  get userQuizAttempt(): Prisma.UserQuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userQuestionAttempt`: Exposes CRUD operations for the **UserQuestionAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserQuestionAttempts
    * const userQuestionAttempts = await prisma.userQuestionAttempt.findMany()
    * ```
    */
  get userQuestionAttempt(): Prisma.UserQuestionAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lastActivity`: Exposes CRUD operations for the **LastActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LastActivities
    * const lastActivities = await prisma.lastActivity.findMany()
    * ```
    */
  get lastActivity(): Prisma.LastActivityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.badge`: Exposes CRUD operations for the **Badge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Badges
    * const badges = await prisma.badge.findMany()
    * ```
    */
  get badge(): Prisma.BadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coinWallet`: Exposes CRUD operations for the **CoinWallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoinWallets
    * const coinWallets = await prisma.coinWallet.findMany()
    * ```
    */
  get coinWallet(): Prisma.CoinWalletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.coinTransaction`: Exposes CRUD operations for the **CoinTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoinTransactions
    * const coinTransactions = await prisma.coinTransaction.findMany()
    * ```
    */
  get coinTransaction(): Prisma.CoinTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapProgress`: Exposes CRUD operations for the **RoadmapProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapProgresses
    * const roadmapProgresses = await prisma.roadmapProgress.findMany()
    * ```
    */
  get roadmapProgress(): Prisma.RoadmapProgressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roadmapStep`: Exposes CRUD operations for the **RoadmapStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapSteps
    * const roadmapSteps = await prisma.roadmapStep.findMany()
    * ```
    */
  get roadmapStep(): Prisma.RoadmapStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutorial`: Exposes CRUD operations for the **Tutorial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutorials
    * const tutorials = await prisma.tutorial.findMany()
    * ```
    */
  get tutorial(): Prisma.TutorialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminActivityLog`: Exposes CRUD operations for the **AdminActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminActivityLogs
    * const adminActivityLogs = await prisma.adminActivityLog.findMany()
    * ```
    */
  get adminActivityLog(): Prisma.AdminActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    UserProgress: 'UserProgress',
    UserStreak: 'UserStreak',
    UserQuizAttempt: 'UserQuizAttempt',
    UserQuestionAttempt: 'UserQuestionAttempt',
    LastActivity: 'LastActivity',
    UserBadge: 'UserBadge',
    Badge: 'Badge',
    CoinWallet: 'CoinWallet',
    CoinTransaction: 'CoinTransaction',
    Roadmap: 'Roadmap',
    RoadmapProgress: 'RoadmapProgress',
    RoadmapStep: 'RoadmapStep',
    Tutorial: 'Tutorial',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    AdminActivityLog: 'AdminActivityLog',
    Tag: 'Tag'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userProfile" | "userProgress" | "userStreak" | "userQuizAttempt" | "userQuestionAttempt" | "lastActivity" | "userBadge" | "badge" | "coinWallet" | "coinTransaction" | "roadmap" | "roadmapProgress" | "roadmapStep" | "tutorial" | "quiz" | "quizQuestion" | "adminActivityLog" | "tag"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      UserStreak: {
        payload: Prisma.$UserStreakPayload<ExtArgs>
        fields: Prisma.UserStreakFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserStreakFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserStreakFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          findFirst: {
            args: Prisma.UserStreakFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserStreakFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          findMany: {
            args: Prisma.UserStreakFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>[]
          }
          create: {
            args: Prisma.UserStreakCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          createMany: {
            args: Prisma.UserStreakCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserStreakCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>[]
          }
          delete: {
            args: Prisma.UserStreakDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          update: {
            args: Prisma.UserStreakUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          deleteMany: {
            args: Prisma.UserStreakDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserStreakUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserStreakUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>[]
          }
          upsert: {
            args: Prisma.UserStreakUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserStreakPayload>
          }
          aggregate: {
            args: Prisma.UserStreakAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserStreak>
          }
          groupBy: {
            args: Prisma.UserStreakGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserStreakGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserStreakCountArgs<ExtArgs>
            result: $Utils.Optional<UserStreakCountAggregateOutputType> | number
          }
        }
      }
      UserQuizAttempt: {
        payload: Prisma.$UserQuizAttemptPayload<ExtArgs>
        fields: Prisma.UserQuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.UserQuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          findMany: {
            args: Prisma.UserQuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>[]
          }
          create: {
            args: Prisma.UserQuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          createMany: {
            args: Prisma.UserQuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.UserQuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          update: {
            args: Prisma.UserQuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.UserQuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserQuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.UserQuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.UserQuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuizAttempt>
          }
          groupBy: {
            args: Prisma.UserQuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      UserQuestionAttempt: {
        payload: Prisma.$UserQuestionAttemptPayload<ExtArgs>
        fields: Prisma.UserQuestionAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserQuestionAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserQuestionAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          findFirst: {
            args: Prisma.UserQuestionAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserQuestionAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          findMany: {
            args: Prisma.UserQuestionAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>[]
          }
          create: {
            args: Prisma.UserQuestionAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          createMany: {
            args: Prisma.UserQuestionAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserQuestionAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>[]
          }
          delete: {
            args: Prisma.UserQuestionAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          update: {
            args: Prisma.UserQuestionAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          deleteMany: {
            args: Prisma.UserQuestionAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserQuestionAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserQuestionAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>[]
          }
          upsert: {
            args: Prisma.UserQuestionAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserQuestionAttemptPayload>
          }
          aggregate: {
            args: Prisma.UserQuestionAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserQuestionAttempt>
          }
          groupBy: {
            args: Prisma.UserQuestionAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserQuestionAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserQuestionAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<UserQuestionAttemptCountAggregateOutputType> | number
          }
        }
      }
      LastActivity: {
        payload: Prisma.$LastActivityPayload<ExtArgs>
        fields: Prisma.LastActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LastActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LastActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          findFirst: {
            args: Prisma.LastActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LastActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          findMany: {
            args: Prisma.LastActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>[]
          }
          create: {
            args: Prisma.LastActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          createMany: {
            args: Prisma.LastActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LastActivityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>[]
          }
          delete: {
            args: Prisma.LastActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          update: {
            args: Prisma.LastActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          deleteMany: {
            args: Prisma.LastActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LastActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LastActivityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>[]
          }
          upsert: {
            args: Prisma.LastActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LastActivityPayload>
          }
          aggregate: {
            args: Prisma.LastActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLastActivity>
          }
          groupBy: {
            args: Prisma.LastActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<LastActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.LastActivityCountArgs<ExtArgs>
            result: $Utils.Optional<LastActivityCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      Badge: {
        payload: Prisma.$BadgePayload<ExtArgs>
        fields: Prisma.BadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findFirst: {
            args: Prisma.BadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          findMany: {
            args: Prisma.BadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          create: {
            args: Prisma.BadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          createMany: {
            args: Prisma.BadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          delete: {
            args: Prisma.BadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          update: {
            args: Prisma.BadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          deleteMany: {
            args: Prisma.BadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>[]
          }
          upsert: {
            args: Prisma.BadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BadgePayload>
          }
          aggregate: {
            args: Prisma.BadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBadge>
          }
          groupBy: {
            args: Prisma.BadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BadgeCountArgs<ExtArgs>
            result: $Utils.Optional<BadgeCountAggregateOutputType> | number
          }
        }
      }
      CoinWallet: {
        payload: Prisma.$CoinWalletPayload<ExtArgs>
        fields: Prisma.CoinWalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinWalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinWalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          findFirst: {
            args: Prisma.CoinWalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinWalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          findMany: {
            args: Prisma.CoinWalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>[]
          }
          create: {
            args: Prisma.CoinWalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          createMany: {
            args: Prisma.CoinWalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoinWalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>[]
          }
          delete: {
            args: Prisma.CoinWalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          update: {
            args: Prisma.CoinWalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          deleteMany: {
            args: Prisma.CoinWalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoinWalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoinWalletUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>[]
          }
          upsert: {
            args: Prisma.CoinWalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinWalletPayload>
          }
          aggregate: {
            args: Prisma.CoinWalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoinWallet>
          }
          groupBy: {
            args: Prisma.CoinWalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoinWalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinWalletCountArgs<ExtArgs>
            result: $Utils.Optional<CoinWalletCountAggregateOutputType> | number
          }
        }
      }
      CoinTransaction: {
        payload: Prisma.$CoinTransactionPayload<ExtArgs>
        fields: Prisma.CoinTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoinTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoinTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          findFirst: {
            args: Prisma.CoinTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoinTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          findMany: {
            args: Prisma.CoinTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>[]
          }
          create: {
            args: Prisma.CoinTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          createMany: {
            args: Prisma.CoinTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoinTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>[]
          }
          delete: {
            args: Prisma.CoinTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          update: {
            args: Prisma.CoinTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          deleteMany: {
            args: Prisma.CoinTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoinTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CoinTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>[]
          }
          upsert: {
            args: Prisma.CoinTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoinTransactionPayload>
          }
          aggregate: {
            args: Prisma.CoinTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoinTransaction>
          }
          groupBy: {
            args: Prisma.CoinTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoinTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoinTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<CoinTransactionCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      RoadmapProgress: {
        payload: Prisma.$RoadmapProgressPayload<ExtArgs>
        fields: Prisma.RoadmapProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          findFirst: {
            args: Prisma.RoadmapProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          findMany: {
            args: Prisma.RoadmapProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>[]
          }
          create: {
            args: Prisma.RoadmapProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          createMany: {
            args: Prisma.RoadmapProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>[]
          }
          delete: {
            args: Prisma.RoadmapProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          update: {
            args: Prisma.RoadmapProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapProgressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          aggregate: {
            args: Prisma.RoadmapProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapProgress>
          }
          groupBy: {
            args: Prisma.RoadmapProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapProgressCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapProgressCountAggregateOutputType> | number
          }
        }
      }
      RoadmapStep: {
        payload: Prisma.$RoadmapStepPayload<ExtArgs>
        fields: Prisma.RoadmapStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          findFirst: {
            args: Prisma.RoadmapStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          findMany: {
            args: Prisma.RoadmapStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>[]
          }
          create: {
            args: Prisma.RoadmapStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          createMany: {
            args: Prisma.RoadmapStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>[]
          }
          delete: {
            args: Prisma.RoadmapStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          update: {
            args: Prisma.RoadmapStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoadmapStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>[]
          }
          upsert: {
            args: Prisma.RoadmapStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          aggregate: {
            args: Prisma.RoadmapStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapStep>
          }
          groupBy: {
            args: Prisma.RoadmapStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapStepCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapStepCountAggregateOutputType> | number
          }
        }
      }
      Tutorial: {
        payload: Prisma.$TutorialPayload<ExtArgs>
        fields: Prisma.TutorialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutorialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutorialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          findFirst: {
            args: Prisma.TutorialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutorialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          findMany: {
            args: Prisma.TutorialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>[]
          }
          create: {
            args: Prisma.TutorialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          createMany: {
            args: Prisma.TutorialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutorialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>[]
          }
          delete: {
            args: Prisma.TutorialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          update: {
            args: Prisma.TutorialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          deleteMany: {
            args: Prisma.TutorialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutorialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TutorialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>[]
          }
          upsert: {
            args: Prisma.TutorialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutorialPayload>
          }
          aggregate: {
            args: Prisma.TutorialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutorial>
          }
          groupBy: {
            args: Prisma.TutorialGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutorialGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutorialCountArgs<ExtArgs>
            result: $Utils.Optional<TutorialCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      AdminActivityLog: {
        payload: Prisma.$AdminActivityLogPayload<ExtArgs>
        fields: Prisma.AdminActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          findFirst: {
            args: Prisma.AdminActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          findMany: {
            args: Prisma.AdminActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          create: {
            args: Prisma.AdminActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          createMany: {
            args: Prisma.AdminActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          delete: {
            args: Prisma.AdminActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          update: {
            args: Prisma.AdminActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.AdminActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminActivityLogPayload>
          }
          aggregate: {
            args: Prisma.AdminActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminActivityLog>
          }
          groupBy: {
            args: Prisma.AdminActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userProfile?: UserProfileOmit
    userProgress?: UserProgressOmit
    userStreak?: UserStreakOmit
    userQuizAttempt?: UserQuizAttemptOmit
    userQuestionAttempt?: UserQuestionAttemptOmit
    lastActivity?: LastActivityOmit
    userBadge?: UserBadgeOmit
    badge?: BadgeOmit
    coinWallet?: CoinWalletOmit
    coinTransaction?: CoinTransactionOmit
    roadmap?: RoadmapOmit
    roadmapProgress?: RoadmapProgressOmit
    roadmapStep?: RoadmapStepOmit
    tutorial?: TutorialOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    adminActivityLog?: AdminActivityLogOmit
    tag?: TagOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roadmaps: number
    roadmapProgress: number
    adminActivityLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmaps?: boolean | UserCountOutputTypeCountRoadmapsArgs
    roadmapProgress?: boolean | UserCountOutputTypeCountRoadmapProgressArgs
    adminActivityLogs?: boolean | UserCountOutputTypeCountAdminActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoadmapProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAdminActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActivityLogWhereInput
  }


  /**
   * Count Type UserProfileCountOutputType
   */

  export type UserProfileCountOutputType = {
    coinTransaction: number
    lastActivities: number
    progress: number
    quizAttempts: number
    userBadges: number
  }

  export type UserProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coinTransaction?: boolean | UserProfileCountOutputTypeCountCoinTransactionArgs
    lastActivities?: boolean | UserProfileCountOutputTypeCountLastActivitiesArgs
    progress?: boolean | UserProfileCountOutputTypeCountProgressArgs
    quizAttempts?: boolean | UserProfileCountOutputTypeCountQuizAttemptsArgs
    userBadges?: boolean | UserProfileCountOutputTypeCountUserBadgesArgs
  }

  // Custom InputTypes
  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfileCountOutputType
     */
    select?: UserProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountCoinTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinTransactionWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuizAttemptWhereInput
  }

  /**
   * UserProfileCountOutputType without action
   */
  export type UserProfileCountOutputTypeCountUserBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type UserQuizAttemptCountOutputType
   */

  export type UserQuizAttemptCountOutputType = {
    questionAttempts: number
    lastActivities: number
    userProgress: number
  }

  export type UserQuizAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questionAttempts?: boolean | UserQuizAttemptCountOutputTypeCountQuestionAttemptsArgs
    lastActivities?: boolean | UserQuizAttemptCountOutputTypeCountLastActivitiesArgs
    userProgress?: boolean | UserQuizAttemptCountOutputTypeCountUserProgressArgs
  }

  // Custom InputTypes
  /**
   * UserQuizAttemptCountOutputType without action
   */
  export type UserQuizAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttemptCountOutputType
     */
    select?: UserQuizAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserQuizAttemptCountOutputType without action
   */
  export type UserQuizAttemptCountOutputTypeCountQuestionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestionAttemptWhereInput
  }

  /**
   * UserQuizAttemptCountOutputType without action
   */
  export type UserQuizAttemptCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }

  /**
   * UserQuizAttemptCountOutputType without action
   */
  export type UserQuizAttemptCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }


  /**
   * Count Type UserQuestionAttemptCountOutputType
   */

  export type UserQuestionAttemptCountOutputType = {
    lastActivities: number
  }

  export type UserQuestionAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lastActivities?: boolean | UserQuestionAttemptCountOutputTypeCountLastActivitiesArgs
  }

  // Custom InputTypes
  /**
   * UserQuestionAttemptCountOutputType without action
   */
  export type UserQuestionAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttemptCountOutputType
     */
    select?: UserQuestionAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserQuestionAttemptCountOutputType without action
   */
  export type UserQuestionAttemptCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }


  /**
   * Count Type LastActivityCountOutputType
   */

  export type LastActivityCountOutputType = {
    profile: number
  }

  export type LastActivityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | LastActivityCountOutputTypeCountProfileArgs
  }

  // Custom InputTypes
  /**
   * LastActivityCountOutputType without action
   */
  export type LastActivityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivityCountOutputType
     */
    select?: LastActivityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LastActivityCountOutputType without action
   */
  export type LastActivityCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
  }


  /**
   * Count Type BadgeCountOutputType
   */

  export type BadgeCountOutputType = {
    badges: number
  }

  export type BadgeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | BadgeCountOutputTypeCountBadgesArgs
  }

  // Custom InputTypes
  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BadgeCountOutputType
     */
    select?: BadgeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BadgeCountOutputType without action
   */
  export type BadgeCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    steps: number
    roadmapProgress: number
    lastActivities: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | RoadmapCountOutputTypeCountStepsArgs
    roadmapProgress?: boolean | RoadmapCountOutputTypeCountRoadmapProgressArgs
    lastActivities?: boolean | RoadmapCountOutputTypeCountLastActivitiesArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapStepWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountRoadmapProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }


  /**
   * Count Type RoadmapStepCountOutputType
   */

  export type RoadmapStepCountOutputType = {
    children: number
    tutorials: number
    quizzes: number
    lastActivities: number
  }

  export type RoadmapStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | RoadmapStepCountOutputTypeCountChildrenArgs
    tutorials?: boolean | RoadmapStepCountOutputTypeCountTutorialsArgs
    quizzes?: boolean | RoadmapStepCountOutputTypeCountQuizzesArgs
    lastActivities?: boolean | RoadmapStepCountOutputTypeCountLastActivitiesArgs
  }

  // Custom InputTypes
  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStepCountOutputType
     */
    select?: RoadmapStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapStepWhereInput
  }

  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeCountTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialWhereInput
  }

  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }


  /**
   * Count Type TutorialCountOutputType
   */

  export type TutorialCountOutputType = {
    quizzes: number
    progress: number
    tutorialTags: number
    previousTutorials: number
    relatedTutorials: number
    lastActivities: number
  }

  export type TutorialCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | TutorialCountOutputTypeCountQuizzesArgs
    progress?: boolean | TutorialCountOutputTypeCountProgressArgs
    tutorialTags?: boolean | TutorialCountOutputTypeCountTutorialTagsArgs
    previousTutorials?: boolean | TutorialCountOutputTypeCountPreviousTutorialsArgs
    relatedTutorials?: boolean | TutorialCountOutputTypeCountRelatedTutorialsArgs
    lastActivities?: boolean | TutorialCountOutputTypeCountLastActivitiesArgs
  }

  // Custom InputTypes
  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutorialCountOutputType
     */
    select?: TutorialCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountTutorialTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountPreviousTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialWhereInput
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountRelatedTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialWhereInput
  }

  /**
   * TutorialCountOutputType without action
   */
  export type TutorialCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    attempts: number
    tags: number
    lastActivities: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
    tags?: boolean | QuizCountOutputTypeCountTagsArgs
    lastActivities?: boolean | QuizCountOutputTypeCountLastActivitiesArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuizAttemptWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountLastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    quizzes: number
    tutorials: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | TagCountOutputTypeCountQuizzesArgs
    tutorials?: boolean | TagCountOutputTypeCountTutorialsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountQuizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    failedAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    failedAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    failedAttempts: number | null
    lockedUntil: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    emailVerified: boolean | null
    verificationToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    passwordHash: string | null
    role: $Enums.UserRole | null
    failedAttempts: number | null
    lockedUntil: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    emailVerified: boolean | null
    verificationToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    firstName: number
    lastName: number
    email: number
    passwordHash: number
    role: number
    failedAttempts: number
    lockedUntil: number
    resetToken: number
    resetTokenExpiry: number
    emailVerified: number
    verificationToken: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    failedAttempts?: true
  }

  export type UserSumAggregateInputType = {
    failedAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    role?: true
    failedAttempts?: true
    lockedUntil?: true
    resetToken?: true
    resetTokenExpiry?: true
    emailVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    role?: true
    failedAttempts?: true
    lockedUntil?: true
    resetToken?: true
    resetTokenExpiry?: true
    emailVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    firstName?: true
    lastName?: true
    email?: true
    passwordHash?: true
    role?: true
    failedAttempts?: true
    lockedUntil?: true
    resetToken?: true
    resetTokenExpiry?: true
    emailVerified?: true
    verificationToken?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    firstName: string
    lastName: string | null
    email: string
    passwordHash: string | null
    role: $Enums.UserRole
    failedAttempts: number
    lockedUntil: Date | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    emailVerified: boolean
    verificationToken: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    roadmaps?: boolean | User$roadmapsArgs<ExtArgs>
    roadmapProgress?: boolean | User$roadmapProgressArgs<ExtArgs>
    adminActivityLogs?: boolean | User$adminActivityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    failedAttempts?: boolean
    lockedUntil?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    emailVerified?: boolean
    verificationToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "firstName" | "lastName" | "email" | "passwordHash" | "role" | "failedAttempts" | "lockedUntil" | "resetToken" | "resetTokenExpiry" | "emailVerified" | "verificationToken" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    roadmaps?: boolean | User$roadmapsArgs<ExtArgs>
    roadmapProgress?: boolean | User$roadmapProgressArgs<ExtArgs>
    adminActivityLogs?: boolean | User$adminActivityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      roadmaps: Prisma.$RoadmapPayload<ExtArgs>[]
      roadmapProgress: Prisma.$RoadmapProgressPayload<ExtArgs>[]
      adminActivityLogs: Prisma.$AdminActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      firstName: string
      lastName: string | null
      email: string
      passwordHash: string | null
      role: $Enums.UserRole
      failedAttempts: number
      lockedUntil: Date | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      emailVerified: boolean
      verificationToken: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roadmaps<T extends User$roadmapsArgs<ExtArgs> = {}>(args?: Subset<T, User$roadmapsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapProgress<T extends User$roadmapProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$roadmapProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    adminActivityLogs<T extends User$adminActivityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$adminActivityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly failedAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly verificationToken: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.roadmaps
   */
  export type User$roadmapsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    cursor?: RoadmapWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * User.roadmapProgress
   */
  export type User$roadmapProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    cursor?: RoadmapProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * User.adminActivityLogs
   */
  export type User$adminActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    where?: AdminActivityLogWhereInput
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    cursor?: AdminActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileAvgAggregateOutputType = {
    level: number | null
    xp: number | null
    levelProgress: number | null
    levelProgressMax: number | null
  }

  export type UserProfileSumAggregateOutputType = {
    level: number | null
    xp: number | null
    levelProgress: number | null
    levelProgressMax: number | null
  }

  export type UserProfileMinAggregateOutputType = {
    userId: string | null
    bio: string | null
    location: string | null
    website: string | null
    avatar: string | null
    rank: string | null
    level: number | null
    xp: number | null
    levelProgress: number | null
    levelProgressMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastLogin: Date | null
    theme: $Enums.ThemeName | null
  }

  export type UserProfileMaxAggregateOutputType = {
    userId: string | null
    bio: string | null
    location: string | null
    website: string | null
    avatar: string | null
    rank: string | null
    level: number | null
    xp: number | null
    levelProgress: number | null
    levelProgressMax: number | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    lastLogin: Date | null
    theme: $Enums.ThemeName | null
  }

  export type UserProfileCountAggregateOutputType = {
    userId: number
    bio: number
    location: number
    website: number
    socialLinks: number
    avatar: number
    rank: number
    level: number
    xp: number
    levelProgress: number
    levelProgressMax: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    lastLogin: number
    completedQuizzes: number
    completedTutorials: number
    completedRoadmaps: number
    completedSteps: number
    completedChallenges: number
    completedInterviews: number
    completedProjects: number
    theme: number
    _all: number
  }


  export type UserProfileAvgAggregateInputType = {
    level?: true
    xp?: true
    levelProgress?: true
    levelProgressMax?: true
  }

  export type UserProfileSumAggregateInputType = {
    level?: true
    xp?: true
    levelProgress?: true
    levelProgressMax?: true
  }

  export type UserProfileMinAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    website?: true
    avatar?: true
    rank?: true
    level?: true
    xp?: true
    levelProgress?: true
    levelProgressMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLogin?: true
    theme?: true
  }

  export type UserProfileMaxAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    website?: true
    avatar?: true
    rank?: true
    level?: true
    xp?: true
    levelProgress?: true
    levelProgressMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLogin?: true
    theme?: true
  }

  export type UserProfileCountAggregateInputType = {
    userId?: true
    bio?: true
    location?: true
    website?: true
    socialLinks?: true
    avatar?: true
    rank?: true
    level?: true
    xp?: true
    levelProgress?: true
    levelProgressMax?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    lastLogin?: true
    completedQuizzes?: true
    completedTutorials?: true
    completedRoadmaps?: true
    completedSteps?: true
    completedChallenges?: true
    completedInterviews?: true
    completedProjects?: true
    theme?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _avg?: UserProfileAvgAggregateInputType
    _sum?: UserProfileSumAggregateInputType
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    userId: string
    bio: string | null
    location: string | null
    website: string | null
    socialLinks: string[]
    avatar: string | null
    rank: string
    level: number
    xp: number
    levelProgress: number
    levelProgressMax: number
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    lastLogin: Date | null
    completedQuizzes: string[]
    completedTutorials: string[]
    completedRoadmaps: string[]
    completedSteps: string[]
    completedChallenges: string[]
    completedInterviews: string[]
    completedProjects: string[]
    theme: $Enums.ThemeName
    _count: UserProfileCountAggregateOutputType | null
    _avg: UserProfileAvgAggregateOutputType | null
    _sum: UserProfileSumAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    socialLinks?: boolean
    avatar?: boolean
    rank?: boolean
    level?: boolean
    xp?: boolean
    levelProgress?: boolean
    levelProgressMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLogin?: boolean
    completedQuizzes?: boolean
    completedTutorials?: boolean
    completedRoadmaps?: boolean
    completedSteps?: boolean
    completedChallenges?: boolean
    completedInterviews?: boolean
    completedProjects?: boolean
    theme?: boolean
    coinWallet?: boolean | UserProfile$coinWalletArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coinTransaction?: boolean | UserProfile$coinTransactionArgs<ExtArgs>
    lastActivities?: boolean | UserProfile$lastActivitiesArgs<ExtArgs>
    progress?: boolean | UserProfile$progressArgs<ExtArgs>
    quizAttempts?: boolean | UserProfile$quizAttemptsArgs<ExtArgs>
    userBadges?: boolean | UserProfile$userBadgesArgs<ExtArgs>
    streaks?: boolean | UserProfile$streaksArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    socialLinks?: boolean
    avatar?: boolean
    rank?: boolean
    level?: boolean
    xp?: boolean
    levelProgress?: boolean
    levelProgressMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLogin?: boolean
    completedQuizzes?: boolean
    completedTutorials?: boolean
    completedRoadmaps?: boolean
    completedSteps?: boolean
    completedChallenges?: boolean
    completedInterviews?: boolean
    completedProjects?: boolean
    theme?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    socialLinks?: boolean
    avatar?: boolean
    rank?: boolean
    level?: boolean
    xp?: boolean
    levelProgress?: boolean
    levelProgressMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLogin?: boolean
    completedQuizzes?: boolean
    completedTutorials?: boolean
    completedRoadmaps?: boolean
    completedSteps?: boolean
    completedChallenges?: boolean
    completedInterviews?: boolean
    completedProjects?: boolean
    theme?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    userId?: boolean
    bio?: boolean
    location?: boolean
    website?: boolean
    socialLinks?: boolean
    avatar?: boolean
    rank?: boolean
    level?: boolean
    xp?: boolean
    levelProgress?: boolean
    levelProgressMax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    lastLogin?: boolean
    completedQuizzes?: boolean
    completedTutorials?: boolean
    completedRoadmaps?: boolean
    completedSteps?: boolean
    completedChallenges?: boolean
    completedInterviews?: boolean
    completedProjects?: boolean
    theme?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "bio" | "location" | "website" | "socialLinks" | "avatar" | "rank" | "level" | "xp" | "levelProgress" | "levelProgressMax" | "createdAt" | "updatedAt" | "deletedAt" | "lastLogin" | "completedQuizzes" | "completedTutorials" | "completedRoadmaps" | "completedSteps" | "completedChallenges" | "completedInterviews" | "completedProjects" | "theme", ExtArgs["result"]["userProfile"]>
  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    coinWallet?: boolean | UserProfile$coinWalletArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    coinTransaction?: boolean | UserProfile$coinTransactionArgs<ExtArgs>
    lastActivities?: boolean | UserProfile$lastActivitiesArgs<ExtArgs>
    progress?: boolean | UserProfile$progressArgs<ExtArgs>
    quizAttempts?: boolean | UserProfile$quizAttemptsArgs<ExtArgs>
    userBadges?: boolean | UserProfile$userBadgesArgs<ExtArgs>
    streaks?: boolean | UserProfile$streaksArgs<ExtArgs>
    _count?: boolean | UserProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      coinWallet: Prisma.$CoinWalletPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
      coinTransaction: Prisma.$CoinTransactionPayload<ExtArgs>[]
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      quizAttempts: Prisma.$UserQuizAttemptPayload<ExtArgs>[]
      userBadges: Prisma.$UserBadgePayload<ExtArgs>[]
      streaks: Prisma.$UserStreakPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      bio: string | null
      location: string | null
      website: string | null
      socialLinks: string[]
      avatar: string | null
      rank: string
      level: number
      xp: number
      levelProgress: number
      levelProgressMax: number
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      lastLogin: Date | null
      completedQuizzes: string[]
      completedTutorials: string[]
      completedRoadmaps: string[]
      completedSteps: string[]
      completedChallenges: string[]
      completedInterviews: string[]
      completedProjects: string[]
      theme: $Enums.ThemeName
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userProfileWithUserIdOnly = await prisma.userProfile.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `userId`
     * const userProfileWithUserIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `userId`
     * const userProfileWithUserIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    coinWallet<T extends UserProfile$coinWalletArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$coinWalletArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    coinTransaction<T extends UserProfile$coinTransactionArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$coinTransactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastActivities<T extends UserProfile$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends UserProfile$progressArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAttempts<T extends UserProfile$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userBadges<T extends UserProfile$userBadgesArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$userBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    streaks<T extends UserProfile$streaksArgs<ExtArgs> = {}>(args?: Subset<T, UserProfile$streaksArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */
  interface UserProfileFieldRefs {
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly bio: FieldRef<"UserProfile", 'String'>
    readonly location: FieldRef<"UserProfile", 'String'>
    readonly website: FieldRef<"UserProfile", 'String'>
    readonly socialLinks: FieldRef<"UserProfile", 'String[]'>
    readonly avatar: FieldRef<"UserProfile", 'String'>
    readonly rank: FieldRef<"UserProfile", 'String'>
    readonly level: FieldRef<"UserProfile", 'Int'>
    readonly xp: FieldRef<"UserProfile", 'Int'>
    readonly levelProgress: FieldRef<"UserProfile", 'Int'>
    readonly levelProgressMax: FieldRef<"UserProfile", 'Int'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly deletedAt: FieldRef<"UserProfile", 'DateTime'>
    readonly lastLogin: FieldRef<"UserProfile", 'DateTime'>
    readonly completedQuizzes: FieldRef<"UserProfile", 'String[]'>
    readonly completedTutorials: FieldRef<"UserProfile", 'String[]'>
    readonly completedRoadmaps: FieldRef<"UserProfile", 'String[]'>
    readonly completedSteps: FieldRef<"UserProfile", 'String[]'>
    readonly completedChallenges: FieldRef<"UserProfile", 'String[]'>
    readonly completedInterviews: FieldRef<"UserProfile", 'String[]'>
    readonly completedProjects: FieldRef<"UserProfile", 'String[]'>
    readonly theme: FieldRef<"UserProfile", 'ThemeName'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile.coinWallet
   */
  export type UserProfile$coinWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    where?: CoinWalletWhereInput
  }

  /**
   * UserProfile.coinTransaction
   */
  export type UserProfile$coinTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    where?: CoinTransactionWhereInput
    orderBy?: CoinTransactionOrderByWithRelationInput | CoinTransactionOrderByWithRelationInput[]
    cursor?: CoinTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoinTransactionScalarFieldEnum | CoinTransactionScalarFieldEnum[]
  }

  /**
   * UserProfile.lastActivities
   */
  export type UserProfile$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * UserProfile.progress
   */
  export type UserProfile$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProfile.quizAttempts
   */
  export type UserProfile$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    where?: UserQuizAttemptWhereInput
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    cursor?: UserQuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuizAttemptScalarFieldEnum | UserQuizAttemptScalarFieldEnum[]
  }

  /**
   * UserProfile.userBadges
   */
  export type UserProfile$userBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserProfile.streaks
   */
  export type UserProfile$streaksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    where?: UserStreakWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressAvgAggregateOutputType = {
    attempts: number | null
    bestScore: number | null
    percentageCompleted: number | null
  }

  export type UserProgressSumAggregateOutputType = {
    attempts: number | null
    bestScore: number | null
    percentageCompleted: number | null
  }

  export type UserProgressMinAggregateOutputType = {
    tutorialId: string | null
    bestAttemptId: string | null
    lastAttemptId: string | null
    userQuizAttemptId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    attempts: number | null
    bestScore: number | null
    percentageCompleted: number | null
    interviewCompleted: boolean | null
    challengeCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserProgressMaxAggregateOutputType = {
    tutorialId: string | null
    bestAttemptId: string | null
    lastAttemptId: string | null
    userQuizAttemptId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    attempts: number | null
    bestScore: number | null
    percentageCompleted: number | null
    interviewCompleted: boolean | null
    challengeCompleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserProgressCountAggregateOutputType = {
    tutorialId: number
    bestAttemptId: number
    lastAttemptId: number
    userQuizAttemptId: number
    isCompleted: number
    completedAt: number
    attempts: number
    bestScore: number
    percentageCompleted: number
    interviewCompleted: number
    challengeCompleted: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type UserProgressAvgAggregateInputType = {
    attempts?: true
    bestScore?: true
    percentageCompleted?: true
  }

  export type UserProgressSumAggregateInputType = {
    attempts?: true
    bestScore?: true
    percentageCompleted?: true
  }

  export type UserProgressMinAggregateInputType = {
    tutorialId?: true
    bestAttemptId?: true
    lastAttemptId?: true
    userQuizAttemptId?: true
    isCompleted?: true
    completedAt?: true
    attempts?: true
    bestScore?: true
    percentageCompleted?: true
    interviewCompleted?: true
    challengeCompleted?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserProgressMaxAggregateInputType = {
    tutorialId?: true
    bestAttemptId?: true
    lastAttemptId?: true
    userQuizAttemptId?: true
    isCompleted?: true
    completedAt?: true
    attempts?: true
    bestScore?: true
    percentageCompleted?: true
    interviewCompleted?: true
    challengeCompleted?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserProgressCountAggregateInputType = {
    tutorialId?: true
    bestAttemptId?: true
    lastAttemptId?: true
    userQuizAttemptId?: true
    isCompleted?: true
    completedAt?: true
    attempts?: true
    bestScore?: true
    percentageCompleted?: true
    interviewCompleted?: true
    challengeCompleted?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _avg?: UserProgressAvgAggregateInputType
    _sum?: UserProgressSumAggregateInputType
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    tutorialId: string
    bestAttemptId: string | null
    lastAttemptId: string | null
    userQuizAttemptId: string | null
    isCompleted: boolean
    completedAt: Date | null
    attempts: number
    bestScore: number
    percentageCompleted: number
    interviewCompleted: boolean
    challengeCompleted: boolean
    createdAt: Date
    updatedAt: Date
    profileId: string
    _count: UserProgressCountAggregateOutputType | null
    _avg: UserProgressAvgAggregateOutputType | null
    _sum: UserProgressSumAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tutorialId?: boolean
    bestAttemptId?: boolean
    lastAttemptId?: boolean
    userQuizAttemptId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    attempts?: boolean
    bestScore?: boolean
    percentageCompleted?: boolean
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tutorialId?: boolean
    bestAttemptId?: boolean
    lastAttemptId?: boolean
    userQuizAttemptId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    attempts?: boolean
    bestScore?: boolean
    percentageCompleted?: boolean
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tutorialId?: boolean
    bestAttemptId?: boolean
    lastAttemptId?: boolean
    userQuizAttemptId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    attempts?: boolean
    bestScore?: boolean
    percentageCompleted?: boolean
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    tutorialId?: boolean
    bestAttemptId?: boolean
    lastAttemptId?: boolean
    userQuizAttemptId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    attempts?: boolean
    bestScore?: boolean
    percentageCompleted?: boolean
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type UserProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tutorialId" | "bestAttemptId" | "lastAttemptId" | "userQuizAttemptId" | "isCompleted" | "completedAt" | "attempts" | "bestScore" | "percentageCompleted" | "interviewCompleted" | "challengeCompleted" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["userProgress"]>
  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }
  export type UserProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    userQuizAttempt?: boolean | UserProgress$userQuizAttemptArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
      tutorial: Prisma.$TutorialPayload<ExtArgs>
      userQuizAttempt: Prisma.$UserQuizAttemptPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      tutorialId: string
      bestAttemptId: string | null
      lastAttemptId: string | null
      userQuizAttemptId: string | null
      isCompleted: boolean
      completedAt: Date | null
      attempts: number
      bestScore: number
      percentageCompleted: number
      interviewCompleted: boolean
      challengeCompleted: boolean
      createdAt: Date
      updatedAt: Date
      profileId: string
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `tutorialId`
     * const userProgressWithTutorialIdOnly = await prisma.userProgress.findMany({ select: { tutorialId: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `tutorialId`
     * const userProgressWithTutorialIdOnly = await prisma.userProgress.createManyAndReturn({
     *   select: { tutorialId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses and returns the data updated in the database.
     * @param {UserProgressUpdateManyAndReturnArgs} args - Arguments to update many UserProgresses.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProgresses and only return the `tutorialId`
     * const userProgressWithTutorialIdOnly = await prisma.userProgress.updateManyAndReturn({
     *   select: { tutorialId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tutorial<T extends TutorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorialDefaultArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userQuizAttempt<T extends UserProgress$userQuizAttemptArgs<ExtArgs> = {}>(args?: Subset<T, UserProgress$userQuizAttemptArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */
  interface UserProgressFieldRefs {
    readonly tutorialId: FieldRef<"UserProgress", 'String'>
    readonly bestAttemptId: FieldRef<"UserProgress", 'String'>
    readonly lastAttemptId: FieldRef<"UserProgress", 'String'>
    readonly userQuizAttemptId: FieldRef<"UserProgress", 'String'>
    readonly isCompleted: FieldRef<"UserProgress", 'Boolean'>
    readonly completedAt: FieldRef<"UserProgress", 'DateTime'>
    readonly attempts: FieldRef<"UserProgress", 'Int'>
    readonly bestScore: FieldRef<"UserProgress", 'Int'>
    readonly percentageCompleted: FieldRef<"UserProgress", 'Int'>
    readonly interviewCompleted: FieldRef<"UserProgress", 'Boolean'>
    readonly challengeCompleted: FieldRef<"UserProgress", 'Boolean'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProgress", 'DateTime'>
    readonly profileId: FieldRef<"UserProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
  }

  /**
   * UserProgress updateManyAndReturn
   */
  export type UserProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
    /**
     * Limit how many UserProgresses to delete.
     */
    limit?: number
  }

  /**
   * UserProgress.userQuizAttempt
   */
  export type UserProgress$userQuizAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    where?: UserQuizAttemptWhereInput
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model UserStreak
   */

  export type AggregateUserStreak = {
    _count: UserStreakCountAggregateOutputType | null
    _avg: UserStreakAvgAggregateOutputType | null
    _sum: UserStreakSumAggregateOutputType | null
    _min: UserStreakMinAggregateOutputType | null
    _max: UserStreakMaxAggregateOutputType | null
  }

  export type UserStreakAvgAggregateOutputType = {
    streak: number | null
    streakDays: number | null
    longestStreak: number | null
  }

  export type UserStreakSumAggregateOutputType = {
    streak: number | null
    streakDays: number | null
    longestStreak: number | null
  }

  export type UserStreakMinAggregateOutputType = {
    profileId: string | null
    streak: number | null
    streakDays: number | null
    lastLogin: Date | null
    currentStart: Date | null
    currentEnd: Date | null
    longestStreak: number | null
    longestStart: Date | null
    longestEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStreakMaxAggregateOutputType = {
    profileId: string | null
    streak: number | null
    streakDays: number | null
    lastLogin: Date | null
    currentStart: Date | null
    currentEnd: Date | null
    longestStreak: number | null
    longestStart: Date | null
    longestEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserStreakCountAggregateOutputType = {
    profileId: number
    streak: number
    streakDays: number
    lastLogin: number
    currentStart: number
    currentEnd: number
    longestStreak: number
    longestStart: number
    longestEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserStreakAvgAggregateInputType = {
    streak?: true
    streakDays?: true
    longestStreak?: true
  }

  export type UserStreakSumAggregateInputType = {
    streak?: true
    streakDays?: true
    longestStreak?: true
  }

  export type UserStreakMinAggregateInputType = {
    profileId?: true
    streak?: true
    streakDays?: true
    lastLogin?: true
    currentStart?: true
    currentEnd?: true
    longestStreak?: true
    longestStart?: true
    longestEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStreakMaxAggregateInputType = {
    profileId?: true
    streak?: true
    streakDays?: true
    lastLogin?: true
    currentStart?: true
    currentEnd?: true
    longestStreak?: true
    longestStart?: true
    longestEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserStreakCountAggregateInputType = {
    profileId?: true
    streak?: true
    streakDays?: true
    lastLogin?: true
    currentStart?: true
    currentEnd?: true
    longestStreak?: true
    longestStart?: true
    longestEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserStreakAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStreak to aggregate.
     */
    where?: UserStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStreaks to fetch.
     */
    orderBy?: UserStreakOrderByWithRelationInput | UserStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserStreaks
    **/
    _count?: true | UserStreakCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserStreakAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserStreakSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserStreakMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserStreakMaxAggregateInputType
  }

  export type GetUserStreakAggregateType<T extends UserStreakAggregateArgs> = {
        [P in keyof T & keyof AggregateUserStreak]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserStreak[P]>
      : GetScalarType<T[P], AggregateUserStreak[P]>
  }




  export type UserStreakGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserStreakWhereInput
    orderBy?: UserStreakOrderByWithAggregationInput | UserStreakOrderByWithAggregationInput[]
    by: UserStreakScalarFieldEnum[] | UserStreakScalarFieldEnum
    having?: UserStreakScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserStreakCountAggregateInputType | true
    _avg?: UserStreakAvgAggregateInputType
    _sum?: UserStreakSumAggregateInputType
    _min?: UserStreakMinAggregateInputType
    _max?: UserStreakMaxAggregateInputType
  }

  export type UserStreakGroupByOutputType = {
    profileId: string
    streak: number
    streakDays: number
    lastLogin: Date | null
    currentStart: Date | null
    currentEnd: Date | null
    longestStreak: number
    longestStart: Date | null
    longestEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserStreakCountAggregateOutputType | null
    _avg: UserStreakAvgAggregateOutputType | null
    _sum: UserStreakSumAggregateOutputType | null
    _min: UserStreakMinAggregateOutputType | null
    _max: UserStreakMaxAggregateOutputType | null
  }

  type GetUserStreakGroupByPayload<T extends UserStreakGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserStreakGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserStreakGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserStreakGroupByOutputType[P]>
            : GetScalarType<T[P], UserStreakGroupByOutputType[P]>
        }
      >
    >


  export type UserStreakSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    streak?: boolean
    streakDays?: boolean
    lastLogin?: boolean
    currentStart?: boolean
    currentEnd?: boolean
    longestStreak?: boolean
    longestStart?: boolean
    longestEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStreak"]>

  export type UserStreakSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    streak?: boolean
    streakDays?: boolean
    lastLogin?: boolean
    currentStart?: boolean
    currentEnd?: boolean
    longestStreak?: boolean
    longestStart?: boolean
    longestEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStreak"]>

  export type UserStreakSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    streak?: boolean
    streakDays?: boolean
    lastLogin?: boolean
    currentStart?: boolean
    currentEnd?: boolean
    longestStreak?: boolean
    longestStart?: boolean
    longestEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userStreak"]>

  export type UserStreakSelectScalar = {
    profileId?: boolean
    streak?: boolean
    streakDays?: boolean
    lastLogin?: boolean
    currentStart?: boolean
    currentEnd?: boolean
    longestStreak?: boolean
    longestStart?: boolean
    longestEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserStreakOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profileId" | "streak" | "streakDays" | "lastLogin" | "currentStart" | "currentEnd" | "longestStreak" | "longestStart" | "longestEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["userStreak"]>
  export type UserStreakInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type UserStreakIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type UserStreakIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $UserStreakPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserStreak"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      profileId: string
      streak: number
      streakDays: number
      lastLogin: Date | null
      currentStart: Date | null
      currentEnd: Date | null
      longestStreak: number
      longestStart: Date | null
      longestEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userStreak"]>
    composites: {}
  }

  type UserStreakGetPayload<S extends boolean | null | undefined | UserStreakDefaultArgs> = $Result.GetResult<Prisma.$UserStreakPayload, S>

  type UserStreakCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserStreakFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserStreakCountAggregateInputType | true
    }

  export interface UserStreakDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserStreak'], meta: { name: 'UserStreak' } }
    /**
     * Find zero or one UserStreak that matches the filter.
     * @param {UserStreakFindUniqueArgs} args - Arguments to find a UserStreak
     * @example
     * // Get one UserStreak
     * const userStreak = await prisma.userStreak.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserStreakFindUniqueArgs>(args: SelectSubset<T, UserStreakFindUniqueArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserStreak that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserStreakFindUniqueOrThrowArgs} args - Arguments to find a UserStreak
     * @example
     * // Get one UserStreak
     * const userStreak = await prisma.userStreak.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserStreakFindUniqueOrThrowArgs>(args: SelectSubset<T, UserStreakFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStreak that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakFindFirstArgs} args - Arguments to find a UserStreak
     * @example
     * // Get one UserStreak
     * const userStreak = await prisma.userStreak.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserStreakFindFirstArgs>(args?: SelectSubset<T, UserStreakFindFirstArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserStreak that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakFindFirstOrThrowArgs} args - Arguments to find a UserStreak
     * @example
     * // Get one UserStreak
     * const userStreak = await prisma.userStreak.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserStreakFindFirstOrThrowArgs>(args?: SelectSubset<T, UserStreakFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserStreaks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserStreaks
     * const userStreaks = await prisma.userStreak.findMany()
     * 
     * // Get first 10 UserStreaks
     * const userStreaks = await prisma.userStreak.findMany({ take: 10 })
     * 
     * // Only select the `profileId`
     * const userStreakWithProfileIdOnly = await prisma.userStreak.findMany({ select: { profileId: true } })
     * 
     */
    findMany<T extends UserStreakFindManyArgs>(args?: SelectSubset<T, UserStreakFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserStreak.
     * @param {UserStreakCreateArgs} args - Arguments to create a UserStreak.
     * @example
     * // Create one UserStreak
     * const UserStreak = await prisma.userStreak.create({
     *   data: {
     *     // ... data to create a UserStreak
     *   }
     * })
     * 
     */
    create<T extends UserStreakCreateArgs>(args: SelectSubset<T, UserStreakCreateArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserStreaks.
     * @param {UserStreakCreateManyArgs} args - Arguments to create many UserStreaks.
     * @example
     * // Create many UserStreaks
     * const userStreak = await prisma.userStreak.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserStreakCreateManyArgs>(args?: SelectSubset<T, UserStreakCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserStreaks and returns the data saved in the database.
     * @param {UserStreakCreateManyAndReturnArgs} args - Arguments to create many UserStreaks.
     * @example
     * // Create many UserStreaks
     * const userStreak = await prisma.userStreak.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserStreaks and only return the `profileId`
     * const userStreakWithProfileIdOnly = await prisma.userStreak.createManyAndReturn({
     *   select: { profileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserStreakCreateManyAndReturnArgs>(args?: SelectSubset<T, UserStreakCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserStreak.
     * @param {UserStreakDeleteArgs} args - Arguments to delete one UserStreak.
     * @example
     * // Delete one UserStreak
     * const UserStreak = await prisma.userStreak.delete({
     *   where: {
     *     // ... filter to delete one UserStreak
     *   }
     * })
     * 
     */
    delete<T extends UserStreakDeleteArgs>(args: SelectSubset<T, UserStreakDeleteArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserStreak.
     * @param {UserStreakUpdateArgs} args - Arguments to update one UserStreak.
     * @example
     * // Update one UserStreak
     * const userStreak = await prisma.userStreak.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserStreakUpdateArgs>(args: SelectSubset<T, UserStreakUpdateArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserStreaks.
     * @param {UserStreakDeleteManyArgs} args - Arguments to filter UserStreaks to delete.
     * @example
     * // Delete a few UserStreaks
     * const { count } = await prisma.userStreak.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserStreakDeleteManyArgs>(args?: SelectSubset<T, UserStreakDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserStreaks
     * const userStreak = await prisma.userStreak.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserStreakUpdateManyArgs>(args: SelectSubset<T, UserStreakUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserStreaks and returns the data updated in the database.
     * @param {UserStreakUpdateManyAndReturnArgs} args - Arguments to update many UserStreaks.
     * @example
     * // Update many UserStreaks
     * const userStreak = await prisma.userStreak.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserStreaks and only return the `profileId`
     * const userStreakWithProfileIdOnly = await prisma.userStreak.updateManyAndReturn({
     *   select: { profileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserStreakUpdateManyAndReturnArgs>(args: SelectSubset<T, UserStreakUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserStreak.
     * @param {UserStreakUpsertArgs} args - Arguments to update or create a UserStreak.
     * @example
     * // Update or create a UserStreak
     * const userStreak = await prisma.userStreak.upsert({
     *   create: {
     *     // ... data to create a UserStreak
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserStreak we want to update
     *   }
     * })
     */
    upsert<T extends UserStreakUpsertArgs>(args: SelectSubset<T, UserStreakUpsertArgs<ExtArgs>>): Prisma__UserStreakClient<$Result.GetResult<Prisma.$UserStreakPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserStreaks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakCountArgs} args - Arguments to filter UserStreaks to count.
     * @example
     * // Count the number of UserStreaks
     * const count = await prisma.userStreak.count({
     *   where: {
     *     // ... the filter for the UserStreaks we want to count
     *   }
     * })
    **/
    count<T extends UserStreakCountArgs>(
      args?: Subset<T, UserStreakCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserStreakCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserStreakAggregateArgs>(args: Subset<T, UserStreakAggregateArgs>): Prisma.PrismaPromise<GetUserStreakAggregateType<T>>

    /**
     * Group by UserStreak.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserStreakGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserStreakGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserStreakGroupByArgs['orderBy'] }
        : { orderBy?: UserStreakGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserStreakGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserStreakGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserStreak model
   */
  readonly fields: UserStreakFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserStreak.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserStreakClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserStreak model
   */
  interface UserStreakFieldRefs {
    readonly profileId: FieldRef<"UserStreak", 'String'>
    readonly streak: FieldRef<"UserStreak", 'Int'>
    readonly streakDays: FieldRef<"UserStreak", 'Int'>
    readonly lastLogin: FieldRef<"UserStreak", 'DateTime'>
    readonly currentStart: FieldRef<"UserStreak", 'DateTime'>
    readonly currentEnd: FieldRef<"UserStreak", 'DateTime'>
    readonly longestStreak: FieldRef<"UserStreak", 'Int'>
    readonly longestStart: FieldRef<"UserStreak", 'DateTime'>
    readonly longestEnd: FieldRef<"UserStreak", 'DateTime'>
    readonly createdAt: FieldRef<"UserStreak", 'DateTime'>
    readonly updatedAt: FieldRef<"UserStreak", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserStreak findUnique
   */
  export type UserStreakFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter, which UserStreak to fetch.
     */
    where: UserStreakWhereUniqueInput
  }

  /**
   * UserStreak findUniqueOrThrow
   */
  export type UserStreakFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter, which UserStreak to fetch.
     */
    where: UserStreakWhereUniqueInput
  }

  /**
   * UserStreak findFirst
   */
  export type UserStreakFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter, which UserStreak to fetch.
     */
    where?: UserStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStreaks to fetch.
     */
    orderBy?: UserStreakOrderByWithRelationInput | UserStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStreaks.
     */
    cursor?: UserStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStreaks.
     */
    distinct?: UserStreakScalarFieldEnum | UserStreakScalarFieldEnum[]
  }

  /**
   * UserStreak findFirstOrThrow
   */
  export type UserStreakFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter, which UserStreak to fetch.
     */
    where?: UserStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStreaks to fetch.
     */
    orderBy?: UserStreakOrderByWithRelationInput | UserStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserStreaks.
     */
    cursor?: UserStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStreaks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserStreaks.
     */
    distinct?: UserStreakScalarFieldEnum | UserStreakScalarFieldEnum[]
  }

  /**
   * UserStreak findMany
   */
  export type UserStreakFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter, which UserStreaks to fetch.
     */
    where?: UserStreakWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserStreaks to fetch.
     */
    orderBy?: UserStreakOrderByWithRelationInput | UserStreakOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserStreaks.
     */
    cursor?: UserStreakWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserStreaks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserStreaks.
     */
    skip?: number
    distinct?: UserStreakScalarFieldEnum | UserStreakScalarFieldEnum[]
  }

  /**
   * UserStreak create
   */
  export type UserStreakCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * The data needed to create a UserStreak.
     */
    data: XOR<UserStreakCreateInput, UserStreakUncheckedCreateInput>
  }

  /**
   * UserStreak createMany
   */
  export type UserStreakCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserStreaks.
     */
    data: UserStreakCreateManyInput | UserStreakCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserStreak createManyAndReturn
   */
  export type UserStreakCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * The data used to create many UserStreaks.
     */
    data: UserStreakCreateManyInput | UserStreakCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStreak update
   */
  export type UserStreakUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * The data needed to update a UserStreak.
     */
    data: XOR<UserStreakUpdateInput, UserStreakUncheckedUpdateInput>
    /**
     * Choose, which UserStreak to update.
     */
    where: UserStreakWhereUniqueInput
  }

  /**
   * UserStreak updateMany
   */
  export type UserStreakUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserStreaks.
     */
    data: XOR<UserStreakUpdateManyMutationInput, UserStreakUncheckedUpdateManyInput>
    /**
     * Filter which UserStreaks to update
     */
    where?: UserStreakWhereInput
    /**
     * Limit how many UserStreaks to update.
     */
    limit?: number
  }

  /**
   * UserStreak updateManyAndReturn
   */
  export type UserStreakUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * The data used to update UserStreaks.
     */
    data: XOR<UserStreakUpdateManyMutationInput, UserStreakUncheckedUpdateManyInput>
    /**
     * Filter which UserStreaks to update
     */
    where?: UserStreakWhereInput
    /**
     * Limit how many UserStreaks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserStreak upsert
   */
  export type UserStreakUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * The filter to search for the UserStreak to update in case it exists.
     */
    where: UserStreakWhereUniqueInput
    /**
     * In case the UserStreak found by the `where` argument doesn't exist, create a new UserStreak with this data.
     */
    create: XOR<UserStreakCreateInput, UserStreakUncheckedCreateInput>
    /**
     * In case the UserStreak was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserStreakUpdateInput, UserStreakUncheckedUpdateInput>
  }

  /**
   * UserStreak delete
   */
  export type UserStreakDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
    /**
     * Filter which UserStreak to delete.
     */
    where: UserStreakWhereUniqueInput
  }

  /**
   * UserStreak deleteMany
   */
  export type UserStreakDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserStreaks to delete
     */
    where?: UserStreakWhereInput
    /**
     * Limit how many UserStreaks to delete.
     */
    limit?: number
  }

  /**
   * UserStreak without action
   */
  export type UserStreakDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserStreak
     */
    select?: UserStreakSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserStreak
     */
    omit?: UserStreakOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserStreakInclude<ExtArgs> | null
  }


  /**
   * Model UserQuizAttempt
   */

  export type AggregateUserQuizAttempt = {
    _count: UserQuizAttemptCountAggregateOutputType | null
    _avg: UserQuizAttemptAvgAggregateOutputType | null
    _sum: UserQuizAttemptSumAggregateOutputType | null
    _min: UserQuizAttemptMinAggregateOutputType | null
    _max: UserQuizAttemptMaxAggregateOutputType | null
  }

  export type UserQuizAttemptAvgAggregateOutputType = {
    score: number | null
  }

  export type UserQuizAttemptSumAggregateOutputType = {
    score: number | null
  }

  export type UserQuizAttemptMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    isPassed: boolean | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserQuizAttemptMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    startedAt: Date | null
    completedAt: Date | null
    score: number | null
    isPassed: boolean | null
    feedback: string | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserQuizAttemptCountAggregateOutputType = {
    id: number
    quizId: number
    startedAt: number
    completedAt: number
    score: number
    isPassed: number
    feedback: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type UserQuizAttemptAvgAggregateInputType = {
    score?: true
  }

  export type UserQuizAttemptSumAggregateInputType = {
    score?: true
  }

  export type UserQuizAttemptMinAggregateInputType = {
    id?: true
    quizId?: true
    startedAt?: true
    completedAt?: true
    score?: true
    isPassed?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserQuizAttemptMaxAggregateInputType = {
    id?: true
    quizId?: true
    startedAt?: true
    completedAt?: true
    score?: true
    isPassed?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserQuizAttemptCountAggregateInputType = {
    id?: true
    quizId?: true
    startedAt?: true
    completedAt?: true
    score?: true
    isPassed?: true
    feedback?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type UserQuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuizAttempt to aggregate.
     */
    where?: UserQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuizAttempts to fetch.
     */
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuizAttempts
    **/
    _count?: true | UserQuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuizAttemptMaxAggregateInputType
  }

  export type GetUserQuizAttemptAggregateType<T extends UserQuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuizAttempt[P]>
      : GetScalarType<T[P], AggregateUserQuizAttempt[P]>
  }




  export type UserQuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuizAttemptWhereInput
    orderBy?: UserQuizAttemptOrderByWithAggregationInput | UserQuizAttemptOrderByWithAggregationInput[]
    by: UserQuizAttemptScalarFieldEnum[] | UserQuizAttemptScalarFieldEnum
    having?: UserQuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuizAttemptCountAggregateInputType | true
    _avg?: UserQuizAttemptAvgAggregateInputType
    _sum?: UserQuizAttemptSumAggregateInputType
    _min?: UserQuizAttemptMinAggregateInputType
    _max?: UserQuizAttemptMaxAggregateInputType
  }

  export type UserQuizAttemptGroupByOutputType = {
    id: string
    quizId: string
    startedAt: Date
    completedAt: Date | null
    score: number
    isPassed: boolean
    feedback: string | null
    createdAt: Date
    updatedAt: Date
    profileId: string
    _count: UserQuizAttemptCountAggregateOutputType | null
    _avg: UserQuizAttemptAvgAggregateOutputType | null
    _sum: UserQuizAttemptSumAggregateOutputType | null
    _min: UserQuizAttemptMinAggregateOutputType | null
    _max: UserQuizAttemptMaxAggregateOutputType | null
  }

  type GetUserQuizAttemptGroupByPayload<T extends UserQuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type UserQuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    isPassed?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    questionAttempts?: boolean | UserQuizAttempt$questionAttemptsArgs<ExtArgs>
    lastActivities?: boolean | UserQuizAttempt$lastActivitiesArgs<ExtArgs>
    userProgress?: boolean | UserQuizAttempt$userProgressArgs<ExtArgs>
    _count?: boolean | UserQuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuizAttempt"]>

  export type UserQuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    isPassed?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuizAttempt"]>

  export type UserQuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    isPassed?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuizAttempt"]>

  export type UserQuizAttemptSelectScalar = {
    id?: boolean
    quizId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    score?: boolean
    isPassed?: boolean
    feedback?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type UserQuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "startedAt" | "completedAt" | "score" | "isPassed" | "feedback" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["userQuizAttempt"]>
  export type UserQuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    questionAttempts?: boolean | UserQuizAttempt$questionAttemptsArgs<ExtArgs>
    lastActivities?: boolean | UserQuizAttempt$lastActivitiesArgs<ExtArgs>
    userProgress?: boolean | UserQuizAttempt$userProgressArgs<ExtArgs>
    _count?: boolean | UserQuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserQuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type UserQuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $UserQuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuizAttempt"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
      quiz: Prisma.$QuizPayload<ExtArgs>
      questionAttempts: Prisma.$UserQuestionAttemptPayload<ExtArgs>[]
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
      userProgress: Prisma.$UserProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      startedAt: Date
      completedAt: Date | null
      score: number
      isPassed: boolean
      feedback: string | null
      createdAt: Date
      updatedAt: Date
      profileId: string
    }, ExtArgs["result"]["userQuizAttempt"]>
    composites: {}
  }

  type UserQuizAttemptGetPayload<S extends boolean | null | undefined | UserQuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$UserQuizAttemptPayload, S>

  type UserQuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserQuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserQuizAttemptCountAggregateInputType | true
    }

  export interface UserQuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuizAttempt'], meta: { name: 'UserQuizAttempt' } }
    /**
     * Find zero or one UserQuizAttempt that matches the filter.
     * @param {UserQuizAttemptFindUniqueArgs} args - Arguments to find a UserQuizAttempt
     * @example
     * // Get one UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuizAttemptFindUniqueArgs>(args: SelectSubset<T, UserQuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserQuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserQuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a UserQuizAttempt
     * @example
     * // Get one UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptFindFirstArgs} args - Arguments to find a UserQuizAttempt
     * @example
     * // Get one UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuizAttemptFindFirstArgs>(args?: SelectSubset<T, UserQuizAttemptFindFirstArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptFindFirstOrThrowArgs} args - Arguments to find a UserQuizAttempt
     * @example
     * // Get one UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserQuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuizAttempts
     * const userQuizAttempts = await prisma.userQuizAttempt.findMany()
     * 
     * // Get first 10 UserQuizAttempts
     * const userQuizAttempts = await prisma.userQuizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuizAttemptWithIdOnly = await prisma.userQuizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQuizAttemptFindManyArgs>(args?: SelectSubset<T, UserQuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserQuizAttempt.
     * @param {UserQuizAttemptCreateArgs} args - Arguments to create a UserQuizAttempt.
     * @example
     * // Create one UserQuizAttempt
     * const UserQuizAttempt = await prisma.userQuizAttempt.create({
     *   data: {
     *     // ... data to create a UserQuizAttempt
     *   }
     * })
     * 
     */
    create<T extends UserQuizAttemptCreateArgs>(args: SelectSubset<T, UserQuizAttemptCreateArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserQuizAttempts.
     * @param {UserQuizAttemptCreateManyArgs} args - Arguments to create many UserQuizAttempts.
     * @example
     * // Create many UserQuizAttempts
     * const userQuizAttempt = await prisma.userQuizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuizAttemptCreateManyArgs>(args?: SelectSubset<T, UserQuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuizAttempts and returns the data saved in the database.
     * @param {UserQuizAttemptCreateManyAndReturnArgs} args - Arguments to create many UserQuizAttempts.
     * @example
     * // Create many UserQuizAttempts
     * const userQuizAttempt = await prisma.userQuizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuizAttempts and only return the `id`
     * const userQuizAttemptWithIdOnly = await prisma.userQuizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserQuizAttempt.
     * @param {UserQuizAttemptDeleteArgs} args - Arguments to delete one UserQuizAttempt.
     * @example
     * // Delete one UserQuizAttempt
     * const UserQuizAttempt = await prisma.userQuizAttempt.delete({
     *   where: {
     *     // ... filter to delete one UserQuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends UserQuizAttemptDeleteArgs>(args: SelectSubset<T, UserQuizAttemptDeleteArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserQuizAttempt.
     * @param {UserQuizAttemptUpdateArgs} args - Arguments to update one UserQuizAttempt.
     * @example
     * // Update one UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuizAttemptUpdateArgs>(args: SelectSubset<T, UserQuizAttemptUpdateArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserQuizAttempts.
     * @param {UserQuizAttemptDeleteManyArgs} args - Arguments to filter UserQuizAttempts to delete.
     * @example
     * // Delete a few UserQuizAttempts
     * const { count } = await prisma.userQuizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuizAttemptDeleteManyArgs>(args?: SelectSubset<T, UserQuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuizAttempts
     * const userQuizAttempt = await prisma.userQuizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuizAttemptUpdateManyArgs>(args: SelectSubset<T, UserQuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuizAttempts and returns the data updated in the database.
     * @param {UserQuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many UserQuizAttempts.
     * @example
     * // Update many UserQuizAttempts
     * const userQuizAttempt = await prisma.userQuizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserQuizAttempts and only return the `id`
     * const userQuizAttemptWithIdOnly = await prisma.userQuizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserQuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, UserQuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserQuizAttempt.
     * @param {UserQuizAttemptUpsertArgs} args - Arguments to update or create a UserQuizAttempt.
     * @example
     * // Update or create a UserQuizAttempt
     * const userQuizAttempt = await prisma.userQuizAttempt.upsert({
     *   create: {
     *     // ... data to create a UserQuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends UserQuizAttemptUpsertArgs>(args: SelectSubset<T, UserQuizAttemptUpsertArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserQuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptCountArgs} args - Arguments to filter UserQuizAttempts to count.
     * @example
     * // Count the number of UserQuizAttempts
     * const count = await prisma.userQuizAttempt.count({
     *   where: {
     *     // ... the filter for the UserQuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends UserQuizAttemptCountArgs>(
      args?: Subset<T, UserQuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuizAttemptAggregateArgs>(args: Subset<T, UserQuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetUserQuizAttemptAggregateType<T>>

    /**
     * Group by UserQuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: UserQuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuizAttempt model
   */
  readonly fields: UserQuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questionAttempts<T extends UserQuizAttempt$questionAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, UserQuizAttempt$questionAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastActivities<T extends UserQuizAttempt$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, UserQuizAttempt$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userProgress<T extends UserQuizAttempt$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, UserQuizAttempt$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuizAttempt model
   */
  interface UserQuizAttemptFieldRefs {
    readonly id: FieldRef<"UserQuizAttempt", 'String'>
    readonly quizId: FieldRef<"UserQuizAttempt", 'String'>
    readonly startedAt: FieldRef<"UserQuizAttempt", 'DateTime'>
    readonly completedAt: FieldRef<"UserQuizAttempt", 'DateTime'>
    readonly score: FieldRef<"UserQuizAttempt", 'Int'>
    readonly isPassed: FieldRef<"UserQuizAttempt", 'Boolean'>
    readonly feedback: FieldRef<"UserQuizAttempt", 'String'>
    readonly createdAt: FieldRef<"UserQuizAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"UserQuizAttempt", 'DateTime'>
    readonly profileId: FieldRef<"UserQuizAttempt", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserQuizAttempt findUnique
   */
  export type UserQuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuizAttempt to fetch.
     */
    where: UserQuizAttemptWhereUniqueInput
  }

  /**
   * UserQuizAttempt findUniqueOrThrow
   */
  export type UserQuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuizAttempt to fetch.
     */
    where: UserQuizAttemptWhereUniqueInput
  }

  /**
   * UserQuizAttempt findFirst
   */
  export type UserQuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuizAttempt to fetch.
     */
    where?: UserQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuizAttempts to fetch.
     */
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuizAttempts.
     */
    cursor?: UserQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuizAttempts.
     */
    distinct?: UserQuizAttemptScalarFieldEnum | UserQuizAttemptScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt findFirstOrThrow
   */
  export type UserQuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuizAttempt to fetch.
     */
    where?: UserQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuizAttempts to fetch.
     */
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuizAttempts.
     */
    cursor?: UserQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuizAttempts.
     */
    distinct?: UserQuizAttemptScalarFieldEnum | UserQuizAttemptScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt findMany
   */
  export type UserQuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuizAttempts to fetch.
     */
    where?: UserQuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuizAttempts to fetch.
     */
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuizAttempts.
     */
    cursor?: UserQuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuizAttempts.
     */
    skip?: number
    distinct?: UserQuizAttemptScalarFieldEnum | UserQuizAttemptScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt create
   */
  export type UserQuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuizAttempt.
     */
    data: XOR<UserQuizAttemptCreateInput, UserQuizAttemptUncheckedCreateInput>
  }

  /**
   * UserQuizAttempt createMany
   */
  export type UserQuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuizAttempts.
     */
    data: UserQuizAttemptCreateManyInput | UserQuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuizAttempt createManyAndReturn
   */
  export type UserQuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many UserQuizAttempts.
     */
    data: UserQuizAttemptCreateManyInput | UserQuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuizAttempt update
   */
  export type UserQuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuizAttempt.
     */
    data: XOR<UserQuizAttemptUpdateInput, UserQuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which UserQuizAttempt to update.
     */
    where: UserQuizAttemptWhereUniqueInput
  }

  /**
   * UserQuizAttempt updateMany
   */
  export type UserQuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuizAttempts.
     */
    data: XOR<UserQuizAttemptUpdateManyMutationInput, UserQuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserQuizAttempts to update
     */
    where?: UserQuizAttemptWhereInput
    /**
     * Limit how many UserQuizAttempts to update.
     */
    limit?: number
  }

  /**
   * UserQuizAttempt updateManyAndReturn
   */
  export type UserQuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update UserQuizAttempts.
     */
    data: XOR<UserQuizAttemptUpdateManyMutationInput, UserQuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserQuizAttempts to update
     */
    where?: UserQuizAttemptWhereInput
    /**
     * Limit how many UserQuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuizAttempt upsert
   */
  export type UserQuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuizAttempt to update in case it exists.
     */
    where: UserQuizAttemptWhereUniqueInput
    /**
     * In case the UserQuizAttempt found by the `where` argument doesn't exist, create a new UserQuizAttempt with this data.
     */
    create: XOR<UserQuizAttemptCreateInput, UserQuizAttemptUncheckedCreateInput>
    /**
     * In case the UserQuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuizAttemptUpdateInput, UserQuizAttemptUncheckedUpdateInput>
  }

  /**
   * UserQuizAttempt delete
   */
  export type UserQuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which UserQuizAttempt to delete.
     */
    where: UserQuizAttemptWhereUniqueInput
  }

  /**
   * UserQuizAttempt deleteMany
   */
  export type UserQuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuizAttempts to delete
     */
    where?: UserQuizAttemptWhereInput
    /**
     * Limit how many UserQuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * UserQuizAttempt.questionAttempts
   */
  export type UserQuizAttempt$questionAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    where?: UserQuestionAttemptWhereInput
    orderBy?: UserQuestionAttemptOrderByWithRelationInput | UserQuestionAttemptOrderByWithRelationInput[]
    cursor?: UserQuestionAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuestionAttemptScalarFieldEnum | UserQuestionAttemptScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt.lastActivities
   */
  export type UserQuizAttempt$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt.userProgress
   */
  export type UserQuizAttempt$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserQuizAttempt without action
   */
  export type UserQuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model UserQuestionAttempt
   */

  export type AggregateUserQuestionAttempt = {
    _count: UserQuestionAttemptCountAggregateOutputType | null
    _avg: UserQuestionAttemptAvgAggregateOutputType | null
    _sum: UserQuestionAttemptSumAggregateOutputType | null
    _min: UserQuestionAttemptMinAggregateOutputType | null
    _max: UserQuestionAttemptMaxAggregateOutputType | null
  }

  export type UserQuestionAttemptAvgAggregateOutputType = {
    xpEarned: number | null
  }

  export type UserQuestionAttemptSumAggregateOutputType = {
    xpEarned: number | null
  }

  export type UserQuestionAttemptMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    selectedOption: string | null
    isCorrect: boolean | null
    xpEarned: number | null
    userQuizAttemptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuestionAttemptMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    selectedOption: string | null
    isCorrect: boolean | null
    xpEarned: number | null
    userQuizAttemptId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserQuestionAttemptCountAggregateOutputType = {
    id: number
    questionId: number
    selectedOption: number
    isCorrect: number
    xpEarned: number
    userQuizAttemptId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserQuestionAttemptAvgAggregateInputType = {
    xpEarned?: true
  }

  export type UserQuestionAttemptSumAggregateInputType = {
    xpEarned?: true
  }

  export type UserQuestionAttemptMinAggregateInputType = {
    id?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
    xpEarned?: true
    userQuizAttemptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuestionAttemptMaxAggregateInputType = {
    id?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
    xpEarned?: true
    userQuizAttemptId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserQuestionAttemptCountAggregateInputType = {
    id?: true
    questionId?: true
    selectedOption?: true
    isCorrect?: true
    xpEarned?: true
    userQuizAttemptId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserQuestionAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuestionAttempt to aggregate.
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuestionAttempts to fetch.
     */
    orderBy?: UserQuestionAttemptOrderByWithRelationInput | UserQuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserQuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserQuestionAttempts
    **/
    _count?: true | UserQuestionAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserQuestionAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserQuestionAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserQuestionAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserQuestionAttemptMaxAggregateInputType
  }

  export type GetUserQuestionAttemptAggregateType<T extends UserQuestionAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateUserQuestionAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserQuestionAttempt[P]>
      : GetScalarType<T[P], AggregateUserQuestionAttempt[P]>
  }




  export type UserQuestionAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserQuestionAttemptWhereInput
    orderBy?: UserQuestionAttemptOrderByWithAggregationInput | UserQuestionAttemptOrderByWithAggregationInput[]
    by: UserQuestionAttemptScalarFieldEnum[] | UserQuestionAttemptScalarFieldEnum
    having?: UserQuestionAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserQuestionAttemptCountAggregateInputType | true
    _avg?: UserQuestionAttemptAvgAggregateInputType
    _sum?: UserQuestionAttemptSumAggregateInputType
    _min?: UserQuestionAttemptMinAggregateInputType
    _max?: UserQuestionAttemptMaxAggregateInputType
  }

  export type UserQuestionAttemptGroupByOutputType = {
    id: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned: number
    userQuizAttemptId: string
    createdAt: Date
    updatedAt: Date
    _count: UserQuestionAttemptCountAggregateOutputType | null
    _avg: UserQuestionAttemptAvgAggregateOutputType | null
    _sum: UserQuestionAttemptSumAggregateOutputType | null
    _min: UserQuestionAttemptMinAggregateOutputType | null
    _max: UserQuestionAttemptMaxAggregateOutputType | null
  }

  type GetUserQuestionAttemptGroupByPayload<T extends UserQuestionAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserQuestionAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserQuestionAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserQuestionAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], UserQuestionAttemptGroupByOutputType[P]>
        }
      >
    >


  export type UserQuestionAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    xpEarned?: boolean
    userQuizAttemptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
    lastActivities?: boolean | UserQuestionAttempt$lastActivitiesArgs<ExtArgs>
    _count?: boolean | UserQuestionAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuestionAttempt"]>

  export type UserQuestionAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    xpEarned?: boolean
    userQuizAttemptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuestionAttempt"]>

  export type UserQuestionAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    xpEarned?: boolean
    userQuizAttemptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userQuestionAttempt"]>

  export type UserQuestionAttemptSelectScalar = {
    id?: boolean
    questionId?: boolean
    selectedOption?: boolean
    isCorrect?: boolean
    xpEarned?: boolean
    userQuizAttemptId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserQuestionAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "selectedOption" | "isCorrect" | "xpEarned" | "userQuizAttemptId" | "createdAt" | "updatedAt", ExtArgs["result"]["userQuestionAttempt"]>
  export type UserQuestionAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
    lastActivities?: boolean | UserQuestionAttempt$lastActivitiesArgs<ExtArgs>
    _count?: boolean | UserQuestionAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserQuestionAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
  }
  export type UserQuestionAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizAttempts?: boolean | UserQuizAttemptDefaultArgs<ExtArgs>
  }

  export type $UserQuestionAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserQuestionAttempt"
    objects: {
      quizAttempts: Prisma.$UserQuizAttemptPayload<ExtArgs>
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      selectedOption: string
      isCorrect: boolean
      xpEarned: number
      userQuizAttemptId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userQuestionAttempt"]>
    composites: {}
  }

  type UserQuestionAttemptGetPayload<S extends boolean | null | undefined | UserQuestionAttemptDefaultArgs> = $Result.GetResult<Prisma.$UserQuestionAttemptPayload, S>

  type UserQuestionAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserQuestionAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserQuestionAttemptCountAggregateInputType | true
    }

  export interface UserQuestionAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserQuestionAttempt'], meta: { name: 'UserQuestionAttempt' } }
    /**
     * Find zero or one UserQuestionAttempt that matches the filter.
     * @param {UserQuestionAttemptFindUniqueArgs} args - Arguments to find a UserQuestionAttempt
     * @example
     * // Get one UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserQuestionAttemptFindUniqueArgs>(args: SelectSubset<T, UserQuestionAttemptFindUniqueArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserQuestionAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserQuestionAttemptFindUniqueOrThrowArgs} args - Arguments to find a UserQuestionAttempt
     * @example
     * // Get one UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserQuestionAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, UserQuestionAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQuestionAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptFindFirstArgs} args - Arguments to find a UserQuestionAttempt
     * @example
     * // Get one UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserQuestionAttemptFindFirstArgs>(args?: SelectSubset<T, UserQuestionAttemptFindFirstArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserQuestionAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptFindFirstOrThrowArgs} args - Arguments to find a UserQuestionAttempt
     * @example
     * // Get one UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserQuestionAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, UserQuestionAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserQuestionAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserQuestionAttempts
     * const userQuestionAttempts = await prisma.userQuestionAttempt.findMany()
     * 
     * // Get first 10 UserQuestionAttempts
     * const userQuestionAttempts = await prisma.userQuestionAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userQuestionAttemptWithIdOnly = await prisma.userQuestionAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserQuestionAttemptFindManyArgs>(args?: SelectSubset<T, UserQuestionAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserQuestionAttempt.
     * @param {UserQuestionAttemptCreateArgs} args - Arguments to create a UserQuestionAttempt.
     * @example
     * // Create one UserQuestionAttempt
     * const UserQuestionAttempt = await prisma.userQuestionAttempt.create({
     *   data: {
     *     // ... data to create a UserQuestionAttempt
     *   }
     * })
     * 
     */
    create<T extends UserQuestionAttemptCreateArgs>(args: SelectSubset<T, UserQuestionAttemptCreateArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserQuestionAttempts.
     * @param {UserQuestionAttemptCreateManyArgs} args - Arguments to create many UserQuestionAttempts.
     * @example
     * // Create many UserQuestionAttempts
     * const userQuestionAttempt = await prisma.userQuestionAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserQuestionAttemptCreateManyArgs>(args?: SelectSubset<T, UserQuestionAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserQuestionAttempts and returns the data saved in the database.
     * @param {UserQuestionAttemptCreateManyAndReturnArgs} args - Arguments to create many UserQuestionAttempts.
     * @example
     * // Create many UserQuestionAttempts
     * const userQuestionAttempt = await prisma.userQuestionAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserQuestionAttempts and only return the `id`
     * const userQuestionAttemptWithIdOnly = await prisma.userQuestionAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserQuestionAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, UserQuestionAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserQuestionAttempt.
     * @param {UserQuestionAttemptDeleteArgs} args - Arguments to delete one UserQuestionAttempt.
     * @example
     * // Delete one UserQuestionAttempt
     * const UserQuestionAttempt = await prisma.userQuestionAttempt.delete({
     *   where: {
     *     // ... filter to delete one UserQuestionAttempt
     *   }
     * })
     * 
     */
    delete<T extends UserQuestionAttemptDeleteArgs>(args: SelectSubset<T, UserQuestionAttemptDeleteArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserQuestionAttempt.
     * @param {UserQuestionAttemptUpdateArgs} args - Arguments to update one UserQuestionAttempt.
     * @example
     * // Update one UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserQuestionAttemptUpdateArgs>(args: SelectSubset<T, UserQuestionAttemptUpdateArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserQuestionAttempts.
     * @param {UserQuestionAttemptDeleteManyArgs} args - Arguments to filter UserQuestionAttempts to delete.
     * @example
     * // Delete a few UserQuestionAttempts
     * const { count } = await prisma.userQuestionAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserQuestionAttemptDeleteManyArgs>(args?: SelectSubset<T, UserQuestionAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserQuestionAttempts
     * const userQuestionAttempt = await prisma.userQuestionAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserQuestionAttemptUpdateManyArgs>(args: SelectSubset<T, UserQuestionAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserQuestionAttempts and returns the data updated in the database.
     * @param {UserQuestionAttemptUpdateManyAndReturnArgs} args - Arguments to update many UserQuestionAttempts.
     * @example
     * // Update many UserQuestionAttempts
     * const userQuestionAttempt = await prisma.userQuestionAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserQuestionAttempts and only return the `id`
     * const userQuestionAttemptWithIdOnly = await prisma.userQuestionAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserQuestionAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, UserQuestionAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserQuestionAttempt.
     * @param {UserQuestionAttemptUpsertArgs} args - Arguments to update or create a UserQuestionAttempt.
     * @example
     * // Update or create a UserQuestionAttempt
     * const userQuestionAttempt = await prisma.userQuestionAttempt.upsert({
     *   create: {
     *     // ... data to create a UserQuestionAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserQuestionAttempt we want to update
     *   }
     * })
     */
    upsert<T extends UserQuestionAttemptUpsertArgs>(args: SelectSubset<T, UserQuestionAttemptUpsertArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserQuestionAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptCountArgs} args - Arguments to filter UserQuestionAttempts to count.
     * @example
     * // Count the number of UserQuestionAttempts
     * const count = await prisma.userQuestionAttempt.count({
     *   where: {
     *     // ... the filter for the UserQuestionAttempts we want to count
     *   }
     * })
    **/
    count<T extends UserQuestionAttemptCountArgs>(
      args?: Subset<T, UserQuestionAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserQuestionAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserQuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserQuestionAttemptAggregateArgs>(args: Subset<T, UserQuestionAttemptAggregateArgs>): Prisma.PrismaPromise<GetUserQuestionAttemptAggregateType<T>>

    /**
     * Group by UserQuestionAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserQuestionAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserQuestionAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserQuestionAttemptGroupByArgs['orderBy'] }
        : { orderBy?: UserQuestionAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserQuestionAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserQuestionAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserQuestionAttempt model
   */
  readonly fields: UserQuestionAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserQuestionAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserQuestionAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizAttempts<T extends UserQuizAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserQuizAttemptDefaultArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lastActivities<T extends UserQuestionAttempt$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, UserQuestionAttempt$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserQuestionAttempt model
   */
  interface UserQuestionAttemptFieldRefs {
    readonly id: FieldRef<"UserQuestionAttempt", 'String'>
    readonly questionId: FieldRef<"UserQuestionAttempt", 'String'>
    readonly selectedOption: FieldRef<"UserQuestionAttempt", 'String'>
    readonly isCorrect: FieldRef<"UserQuestionAttempt", 'Boolean'>
    readonly xpEarned: FieldRef<"UserQuestionAttempt", 'Int'>
    readonly userQuizAttemptId: FieldRef<"UserQuestionAttempt", 'String'>
    readonly createdAt: FieldRef<"UserQuestionAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"UserQuestionAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserQuestionAttempt findUnique
   */
  export type UserQuestionAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuestionAttempt to fetch.
     */
    where: UserQuestionAttemptWhereUniqueInput
  }

  /**
   * UserQuestionAttempt findUniqueOrThrow
   */
  export type UserQuestionAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuestionAttempt to fetch.
     */
    where: UserQuestionAttemptWhereUniqueInput
  }

  /**
   * UserQuestionAttempt findFirst
   */
  export type UserQuestionAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuestionAttempt to fetch.
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuestionAttempts to fetch.
     */
    orderBy?: UserQuestionAttemptOrderByWithRelationInput | UserQuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuestionAttempts.
     */
    cursor?: UserQuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuestionAttempts.
     */
    distinct?: UserQuestionAttemptScalarFieldEnum | UserQuestionAttemptScalarFieldEnum[]
  }

  /**
   * UserQuestionAttempt findFirstOrThrow
   */
  export type UserQuestionAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuestionAttempt to fetch.
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuestionAttempts to fetch.
     */
    orderBy?: UserQuestionAttemptOrderByWithRelationInput | UserQuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserQuestionAttempts.
     */
    cursor?: UserQuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuestionAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserQuestionAttempts.
     */
    distinct?: UserQuestionAttemptScalarFieldEnum | UserQuestionAttemptScalarFieldEnum[]
  }

  /**
   * UserQuestionAttempt findMany
   */
  export type UserQuestionAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter, which UserQuestionAttempts to fetch.
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserQuestionAttempts to fetch.
     */
    orderBy?: UserQuestionAttemptOrderByWithRelationInput | UserQuestionAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserQuestionAttempts.
     */
    cursor?: UserQuestionAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserQuestionAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserQuestionAttempts.
     */
    skip?: number
    distinct?: UserQuestionAttemptScalarFieldEnum | UserQuestionAttemptScalarFieldEnum[]
  }

  /**
   * UserQuestionAttempt create
   */
  export type UserQuestionAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a UserQuestionAttempt.
     */
    data: XOR<UserQuestionAttemptCreateInput, UserQuestionAttemptUncheckedCreateInput>
  }

  /**
   * UserQuestionAttempt createMany
   */
  export type UserQuestionAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserQuestionAttempts.
     */
    data: UserQuestionAttemptCreateManyInput | UserQuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserQuestionAttempt createManyAndReturn
   */
  export type UserQuestionAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many UserQuestionAttempts.
     */
    data: UserQuestionAttemptCreateManyInput | UserQuestionAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuestionAttempt update
   */
  export type UserQuestionAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a UserQuestionAttempt.
     */
    data: XOR<UserQuestionAttemptUpdateInput, UserQuestionAttemptUncheckedUpdateInput>
    /**
     * Choose, which UserQuestionAttempt to update.
     */
    where: UserQuestionAttemptWhereUniqueInput
  }

  /**
   * UserQuestionAttempt updateMany
   */
  export type UserQuestionAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserQuestionAttempts.
     */
    data: XOR<UserQuestionAttemptUpdateManyMutationInput, UserQuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserQuestionAttempts to update
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * Limit how many UserQuestionAttempts to update.
     */
    limit?: number
  }

  /**
   * UserQuestionAttempt updateManyAndReturn
   */
  export type UserQuestionAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * The data used to update UserQuestionAttempts.
     */
    data: XOR<UserQuestionAttemptUpdateManyMutationInput, UserQuestionAttemptUncheckedUpdateManyInput>
    /**
     * Filter which UserQuestionAttempts to update
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * Limit how many UserQuestionAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserQuestionAttempt upsert
   */
  export type UserQuestionAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the UserQuestionAttempt to update in case it exists.
     */
    where: UserQuestionAttemptWhereUniqueInput
    /**
     * In case the UserQuestionAttempt found by the `where` argument doesn't exist, create a new UserQuestionAttempt with this data.
     */
    create: XOR<UserQuestionAttemptCreateInput, UserQuestionAttemptUncheckedCreateInput>
    /**
     * In case the UserQuestionAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserQuestionAttemptUpdateInput, UserQuestionAttemptUncheckedUpdateInput>
  }

  /**
   * UserQuestionAttempt delete
   */
  export type UserQuestionAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    /**
     * Filter which UserQuestionAttempt to delete.
     */
    where: UserQuestionAttemptWhereUniqueInput
  }

  /**
   * UserQuestionAttempt deleteMany
   */
  export type UserQuestionAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserQuestionAttempts to delete
     */
    where?: UserQuestionAttemptWhereInput
    /**
     * Limit how many UserQuestionAttempts to delete.
     */
    limit?: number
  }

  /**
   * UserQuestionAttempt.lastActivities
   */
  export type UserQuestionAttempt$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * UserQuestionAttempt without action
   */
  export type UserQuestionAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
  }


  /**
   * Model LastActivity
   */

  export type AggregateLastActivity = {
    _count: LastActivityCountAggregateOutputType | null
    _avg: LastActivityAvgAggregateOutputType | null
    _sum: LastActivitySumAggregateOutputType | null
    _min: LastActivityMinAggregateOutputType | null
    _max: LastActivityMaxAggregateOutputType | null
  }

  export type LastActivityAvgAggregateOutputType = {
    xpAwarded: number | null
  }

  export type LastActivitySumAggregateOutputType = {
    xpAwarded: number | null
  }

  export type LastActivityMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    description: string | null
    xpAwarded: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quizId: string | null
    tutorialId: string | null
    roadmapId: string | null
    roadmapStepId: string | null
    quizAttemptId: string | null
    questionAttemptId: string | null
  }

  export type LastActivityMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.ActivityType | null
    description: string | null
    xpAwarded: number | null
    createdAt: Date | null
    updatedAt: Date | null
    quizId: string | null
    tutorialId: string | null
    roadmapId: string | null
    roadmapStepId: string | null
    quizAttemptId: string | null
    questionAttemptId: string | null
  }

  export type LastActivityCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    description: number
    xpAwarded: number
    createdAt: number
    updatedAt: number
    quizId: number
    tutorialId: number
    roadmapId: number
    roadmapStepId: number
    quizAttemptId: number
    questionAttemptId: number
    _all: number
  }


  export type LastActivityAvgAggregateInputType = {
    xpAwarded?: true
  }

  export type LastActivitySumAggregateInputType = {
    xpAwarded?: true
  }

  export type LastActivityMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpAwarded?: true
    createdAt?: true
    updatedAt?: true
    quizId?: true
    tutorialId?: true
    roadmapId?: true
    roadmapStepId?: true
    quizAttemptId?: true
    questionAttemptId?: true
  }

  export type LastActivityMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpAwarded?: true
    createdAt?: true
    updatedAt?: true
    quizId?: true
    tutorialId?: true
    roadmapId?: true
    roadmapStepId?: true
    quizAttemptId?: true
    questionAttemptId?: true
  }

  export type LastActivityCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    description?: true
    xpAwarded?: true
    createdAt?: true
    updatedAt?: true
    quizId?: true
    tutorialId?: true
    roadmapId?: true
    roadmapStepId?: true
    quizAttemptId?: true
    questionAttemptId?: true
    _all?: true
  }

  export type LastActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LastActivity to aggregate.
     */
    where?: LastActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastActivities to fetch.
     */
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LastActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LastActivities
    **/
    _count?: true | LastActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LastActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LastActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LastActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LastActivityMaxAggregateInputType
  }

  export type GetLastActivityAggregateType<T extends LastActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateLastActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLastActivity[P]>
      : GetScalarType<T[P], AggregateLastActivity[P]>
  }




  export type LastActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithAggregationInput | LastActivityOrderByWithAggregationInput[]
    by: LastActivityScalarFieldEnum[] | LastActivityScalarFieldEnum
    having?: LastActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LastActivityCountAggregateInputType | true
    _avg?: LastActivityAvgAggregateInputType
    _sum?: LastActivitySumAggregateInputType
    _min?: LastActivityMinAggregateInputType
    _max?: LastActivityMaxAggregateInputType
  }

  export type LastActivityGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.ActivityType
    description: string | null
    xpAwarded: number | null
    createdAt: Date
    updatedAt: Date
    quizId: string | null
    tutorialId: string | null
    roadmapId: string | null
    roadmapStepId: string | null
    quizAttemptId: string | null
    questionAttemptId: string | null
    _count: LastActivityCountAggregateOutputType | null
    _avg: LastActivityAvgAggregateOutputType | null
    _sum: LastActivitySumAggregateOutputType | null
    _min: LastActivityMinAggregateOutputType | null
    _max: LastActivityMaxAggregateOutputType | null
  }

  type GetLastActivityGroupByPayload<T extends LastActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LastActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LastActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LastActivityGroupByOutputType[P]>
            : GetScalarType<T[P], LastActivityGroupByOutputType[P]>
        }
      >
    >


  export type LastActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizId?: boolean
    tutorialId?: boolean
    roadmapId?: boolean
    roadmapStepId?: boolean
    quizAttemptId?: boolean
    questionAttemptId?: boolean
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
    profile?: boolean | LastActivity$profileArgs<ExtArgs>
    _count?: boolean | LastActivityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lastActivity"]>

  export type LastActivitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizId?: boolean
    tutorialId?: boolean
    roadmapId?: boolean
    roadmapStepId?: boolean
    quizAttemptId?: boolean
    questionAttemptId?: boolean
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
  }, ExtArgs["result"]["lastActivity"]>

  export type LastActivitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizId?: boolean
    tutorialId?: boolean
    roadmapId?: boolean
    roadmapStepId?: boolean
    quizAttemptId?: boolean
    questionAttemptId?: boolean
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
  }, ExtArgs["result"]["lastActivity"]>

  export type LastActivitySelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    description?: boolean
    xpAwarded?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizId?: boolean
    tutorialId?: boolean
    roadmapId?: boolean
    roadmapStepId?: boolean
    quizAttemptId?: boolean
    questionAttemptId?: boolean
  }

  export type LastActivityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "description" | "xpAwarded" | "createdAt" | "updatedAt" | "quizId" | "tutorialId" | "roadmapId" | "roadmapStepId" | "quizAttemptId" | "questionAttemptId", ExtArgs["result"]["lastActivity"]>
  export type LastActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
    profile?: boolean | LastActivity$profileArgs<ExtArgs>
    _count?: boolean | LastActivityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LastActivityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
  }
  export type LastActivityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | LastActivity$quizArgs<ExtArgs>
    tutorial?: boolean | LastActivity$tutorialArgs<ExtArgs>
    roadmap?: boolean | LastActivity$roadmapArgs<ExtArgs>
    roadmapStep?: boolean | LastActivity$roadmapStepArgs<ExtArgs>
    quizAttempt?: boolean | LastActivity$quizAttemptArgs<ExtArgs>
    questionAttempt?: boolean | LastActivity$questionAttemptArgs<ExtArgs>
  }

  export type $LastActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LastActivity"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs> | null
      tutorial: Prisma.$TutorialPayload<ExtArgs> | null
      roadmap: Prisma.$RoadmapPayload<ExtArgs> | null
      roadmapStep: Prisma.$RoadmapStepPayload<ExtArgs> | null
      quizAttempt: Prisma.$UserQuizAttemptPayload<ExtArgs> | null
      questionAttempt: Prisma.$UserQuestionAttemptPayload<ExtArgs> | null
      profile: Prisma.$UserProfilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.ActivityType
      description: string | null
      xpAwarded: number | null
      createdAt: Date
      updatedAt: Date
      quizId: string | null
      tutorialId: string | null
      roadmapId: string | null
      roadmapStepId: string | null
      quizAttemptId: string | null
      questionAttemptId: string | null
    }, ExtArgs["result"]["lastActivity"]>
    composites: {}
  }

  type LastActivityGetPayload<S extends boolean | null | undefined | LastActivityDefaultArgs> = $Result.GetResult<Prisma.$LastActivityPayload, S>

  type LastActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LastActivityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LastActivityCountAggregateInputType | true
    }

  export interface LastActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LastActivity'], meta: { name: 'LastActivity' } }
    /**
     * Find zero or one LastActivity that matches the filter.
     * @param {LastActivityFindUniqueArgs} args - Arguments to find a LastActivity
     * @example
     * // Get one LastActivity
     * const lastActivity = await prisma.lastActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LastActivityFindUniqueArgs>(args: SelectSubset<T, LastActivityFindUniqueArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LastActivity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LastActivityFindUniqueOrThrowArgs} args - Arguments to find a LastActivity
     * @example
     * // Get one LastActivity
     * const lastActivity = await prisma.lastActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LastActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, LastActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LastActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityFindFirstArgs} args - Arguments to find a LastActivity
     * @example
     * // Get one LastActivity
     * const lastActivity = await prisma.lastActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LastActivityFindFirstArgs>(args?: SelectSubset<T, LastActivityFindFirstArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LastActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityFindFirstOrThrowArgs} args - Arguments to find a LastActivity
     * @example
     * // Get one LastActivity
     * const lastActivity = await prisma.lastActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LastActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, LastActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LastActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LastActivities
     * const lastActivities = await prisma.lastActivity.findMany()
     * 
     * // Get first 10 LastActivities
     * const lastActivities = await prisma.lastActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lastActivityWithIdOnly = await prisma.lastActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LastActivityFindManyArgs>(args?: SelectSubset<T, LastActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LastActivity.
     * @param {LastActivityCreateArgs} args - Arguments to create a LastActivity.
     * @example
     * // Create one LastActivity
     * const LastActivity = await prisma.lastActivity.create({
     *   data: {
     *     // ... data to create a LastActivity
     *   }
     * })
     * 
     */
    create<T extends LastActivityCreateArgs>(args: SelectSubset<T, LastActivityCreateArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LastActivities.
     * @param {LastActivityCreateManyArgs} args - Arguments to create many LastActivities.
     * @example
     * // Create many LastActivities
     * const lastActivity = await prisma.lastActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LastActivityCreateManyArgs>(args?: SelectSubset<T, LastActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LastActivities and returns the data saved in the database.
     * @param {LastActivityCreateManyAndReturnArgs} args - Arguments to create many LastActivities.
     * @example
     * // Create many LastActivities
     * const lastActivity = await prisma.lastActivity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LastActivities and only return the `id`
     * const lastActivityWithIdOnly = await prisma.lastActivity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LastActivityCreateManyAndReturnArgs>(args?: SelectSubset<T, LastActivityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LastActivity.
     * @param {LastActivityDeleteArgs} args - Arguments to delete one LastActivity.
     * @example
     * // Delete one LastActivity
     * const LastActivity = await prisma.lastActivity.delete({
     *   where: {
     *     // ... filter to delete one LastActivity
     *   }
     * })
     * 
     */
    delete<T extends LastActivityDeleteArgs>(args: SelectSubset<T, LastActivityDeleteArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LastActivity.
     * @param {LastActivityUpdateArgs} args - Arguments to update one LastActivity.
     * @example
     * // Update one LastActivity
     * const lastActivity = await prisma.lastActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LastActivityUpdateArgs>(args: SelectSubset<T, LastActivityUpdateArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LastActivities.
     * @param {LastActivityDeleteManyArgs} args - Arguments to filter LastActivities to delete.
     * @example
     * // Delete a few LastActivities
     * const { count } = await prisma.lastActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LastActivityDeleteManyArgs>(args?: SelectSubset<T, LastActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LastActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LastActivities
     * const lastActivity = await prisma.lastActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LastActivityUpdateManyArgs>(args: SelectSubset<T, LastActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LastActivities and returns the data updated in the database.
     * @param {LastActivityUpdateManyAndReturnArgs} args - Arguments to update many LastActivities.
     * @example
     * // Update many LastActivities
     * const lastActivity = await prisma.lastActivity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LastActivities and only return the `id`
     * const lastActivityWithIdOnly = await prisma.lastActivity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LastActivityUpdateManyAndReturnArgs>(args: SelectSubset<T, LastActivityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LastActivity.
     * @param {LastActivityUpsertArgs} args - Arguments to update or create a LastActivity.
     * @example
     * // Update or create a LastActivity
     * const lastActivity = await prisma.lastActivity.upsert({
     *   create: {
     *     // ... data to create a LastActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LastActivity we want to update
     *   }
     * })
     */
    upsert<T extends LastActivityUpsertArgs>(args: SelectSubset<T, LastActivityUpsertArgs<ExtArgs>>): Prisma__LastActivityClient<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LastActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityCountArgs} args - Arguments to filter LastActivities to count.
     * @example
     * // Count the number of LastActivities
     * const count = await prisma.lastActivity.count({
     *   where: {
     *     // ... the filter for the LastActivities we want to count
     *   }
     * })
    **/
    count<T extends LastActivityCountArgs>(
      args?: Subset<T, LastActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LastActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LastActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LastActivityAggregateArgs>(args: Subset<T, LastActivityAggregateArgs>): Prisma.PrismaPromise<GetLastActivityAggregateType<T>>

    /**
     * Group by LastActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LastActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LastActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LastActivityGroupByArgs['orderBy'] }
        : { orderBy?: LastActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LastActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLastActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LastActivity model
   */
  readonly fields: LastActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LastActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LastActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends LastActivity$quizArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$quizArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutorial<T extends LastActivity$tutorialArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$tutorialArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roadmap<T extends LastActivity$roadmapArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$roadmapArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    roadmapStep<T extends LastActivity$roadmapStepArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$roadmapStepArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quizAttempt<T extends LastActivity$quizAttemptArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$quizAttemptArgs<ExtArgs>>): Prisma__UserQuizAttemptClient<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questionAttempt<T extends LastActivity$questionAttemptArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$questionAttemptArgs<ExtArgs>>): Prisma__UserQuestionAttemptClient<$Result.GetResult<Prisma.$UserQuestionAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends LastActivity$profileArgs<ExtArgs> = {}>(args?: Subset<T, LastActivity$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LastActivity model
   */
  interface LastActivityFieldRefs {
    readonly id: FieldRef<"LastActivity", 'String'>
    readonly userId: FieldRef<"LastActivity", 'String'>
    readonly type: FieldRef<"LastActivity", 'ActivityType'>
    readonly description: FieldRef<"LastActivity", 'String'>
    readonly xpAwarded: FieldRef<"LastActivity", 'Int'>
    readonly createdAt: FieldRef<"LastActivity", 'DateTime'>
    readonly updatedAt: FieldRef<"LastActivity", 'DateTime'>
    readonly quizId: FieldRef<"LastActivity", 'String'>
    readonly tutorialId: FieldRef<"LastActivity", 'String'>
    readonly roadmapId: FieldRef<"LastActivity", 'String'>
    readonly roadmapStepId: FieldRef<"LastActivity", 'String'>
    readonly quizAttemptId: FieldRef<"LastActivity", 'String'>
    readonly questionAttemptId: FieldRef<"LastActivity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LastActivity findUnique
   */
  export type LastActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter, which LastActivity to fetch.
     */
    where: LastActivityWhereUniqueInput
  }

  /**
   * LastActivity findUniqueOrThrow
   */
  export type LastActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter, which LastActivity to fetch.
     */
    where: LastActivityWhereUniqueInput
  }

  /**
   * LastActivity findFirst
   */
  export type LastActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter, which LastActivity to fetch.
     */
    where?: LastActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastActivities to fetch.
     */
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LastActivities.
     */
    cursor?: LastActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LastActivities.
     */
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * LastActivity findFirstOrThrow
   */
  export type LastActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter, which LastActivity to fetch.
     */
    where?: LastActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastActivities to fetch.
     */
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LastActivities.
     */
    cursor?: LastActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LastActivities.
     */
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * LastActivity findMany
   */
  export type LastActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter, which LastActivities to fetch.
     */
    where?: LastActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LastActivities to fetch.
     */
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LastActivities.
     */
    cursor?: LastActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LastActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LastActivities.
     */
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * LastActivity create
   */
  export type LastActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a LastActivity.
     */
    data: XOR<LastActivityCreateInput, LastActivityUncheckedCreateInput>
  }

  /**
   * LastActivity createMany
   */
  export type LastActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LastActivities.
     */
    data: LastActivityCreateManyInput | LastActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LastActivity createManyAndReturn
   */
  export type LastActivityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * The data used to create many LastActivities.
     */
    data: LastActivityCreateManyInput | LastActivityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LastActivity update
   */
  export type LastActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a LastActivity.
     */
    data: XOR<LastActivityUpdateInput, LastActivityUncheckedUpdateInput>
    /**
     * Choose, which LastActivity to update.
     */
    where: LastActivityWhereUniqueInput
  }

  /**
   * LastActivity updateMany
   */
  export type LastActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LastActivities.
     */
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyInput>
    /**
     * Filter which LastActivities to update
     */
    where?: LastActivityWhereInput
    /**
     * Limit how many LastActivities to update.
     */
    limit?: number
  }

  /**
   * LastActivity updateManyAndReturn
   */
  export type LastActivityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * The data used to update LastActivities.
     */
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyInput>
    /**
     * Filter which LastActivities to update
     */
    where?: LastActivityWhereInput
    /**
     * Limit how many LastActivities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LastActivity upsert
   */
  export type LastActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the LastActivity to update in case it exists.
     */
    where: LastActivityWhereUniqueInput
    /**
     * In case the LastActivity found by the `where` argument doesn't exist, create a new LastActivity with this data.
     */
    create: XOR<LastActivityCreateInput, LastActivityUncheckedCreateInput>
    /**
     * In case the LastActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LastActivityUpdateInput, LastActivityUncheckedUpdateInput>
  }

  /**
   * LastActivity delete
   */
  export type LastActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    /**
     * Filter which LastActivity to delete.
     */
    where: LastActivityWhereUniqueInput
  }

  /**
   * LastActivity deleteMany
   */
  export type LastActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LastActivities to delete
     */
    where?: LastActivityWhereInput
    /**
     * Limit how many LastActivities to delete.
     */
    limit?: number
  }

  /**
   * LastActivity.quiz
   */
  export type LastActivity$quizArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
  }

  /**
   * LastActivity.tutorial
   */
  export type LastActivity$tutorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
  }

  /**
   * LastActivity.roadmap
   */
  export type LastActivity$roadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
  }

  /**
   * LastActivity.roadmapStep
   */
  export type LastActivity$roadmapStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
  }

  /**
   * LastActivity.quizAttempt
   */
  export type LastActivity$quizAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    where?: UserQuizAttemptWhereInput
  }

  /**
   * LastActivity.questionAttempt
   */
  export type LastActivity$questionAttemptArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuestionAttempt
     */
    select?: UserQuestionAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuestionAttempt
     */
    omit?: UserQuestionAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuestionAttemptInclude<ExtArgs> | null
    where?: UserQuestionAttemptWhereInput
  }

  /**
   * LastActivity.profile
   */
  export type LastActivity$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    cursor?: UserProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * LastActivity without action
   */
  export type LastActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeMinAggregateOutputType = {
    badgeId: string | null
    earnedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    badgeId: string | null
    earnedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type UserBadgeCountAggregateOutputType = {
    badgeId: number
    earnedAt: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type UserBadgeMinAggregateInputType = {
    badgeId?: true
    earnedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    badgeId?: true
    earnedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type UserBadgeCountAggregateInputType = {
    badgeId?: true
    earnedAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    badgeId: string
    earnedAt: Date
    createdAt: Date
    updatedAt: Date
    profileId: string
    _count: UserBadgeCountAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badgeId?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badgeId?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    badgeId?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>

  export type UserBadgeSelectScalar = {
    badgeId?: boolean
    earnedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type UserBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"badgeId" | "earnedAt" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["userBadge"]>
  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }
  export type UserBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
    badge?: boolean | BadgeDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
      badge: Prisma.$BadgePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      badgeId: string
      earnedAt: Date
      createdAt: Date
      updatedAt: Date
      profileId: string
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `badgeId`
     * const userBadgeWithBadgeIdOnly = await prisma.userBadge.findMany({ select: { badgeId: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserBadges and returns the data saved in the database.
     * @param {UserBadgeCreateManyAndReturnArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserBadges and only return the `badgeId`
     * const userBadgeWithBadgeIdOnly = await prisma.userBadge.createManyAndReturn({
     *   select: { badgeId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, UserBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges and returns the data updated in the database.
     * @param {UserBadgeUpdateManyAndReturnArgs} args - Arguments to update many UserBadges.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserBadges and only return the `badgeId`
     * const userBadgeWithBadgeIdOnly = await prisma.userBadge.updateManyAndReturn({
     *   select: { badgeId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, UserBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    badge<T extends BadgeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BadgeDefaultArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */
  interface UserBadgeFieldRefs {
    readonly badgeId: FieldRef<"UserBadge", 'String'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
    readonly createdAt: FieldRef<"UserBadge", 'DateTime'>
    readonly updatedAt: FieldRef<"UserBadge", 'DateTime'>
    readonly profileId: FieldRef<"UserBadge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge createManyAndReturn
   */
  export type UserBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
  }

  /**
   * UserBadge updateManyAndReturn
   */
  export type UserBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
    /**
     * Limit how many UserBadges to delete.
     */
    limit?: number
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model Badge
   */

  export type AggregateBadge = {
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  export type BadgeAvgAggregateOutputType = {
    xpReq: number | null
  }

  export type BadgeSumAggregateOutputType = {
    xpReq: number | null
  }

  export type BadgeMinAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    xpReq: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    xpReq: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BadgeCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    xpReq: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BadgeAvgAggregateInputType = {
    xpReq?: true
  }

  export type BadgeSumAggregateInputType = {
    xpReq?: true
  }

  export type BadgeMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    xpReq?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    xpReq?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BadgeCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    xpReq?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badge to aggregate.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Badges
    **/
    _count?: true | BadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BadgeMaxAggregateInputType
  }

  export type GetBadgeAggregateType<T extends BadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBadge[P]>
      : GetScalarType<T[P], AggregateBadge[P]>
  }




  export type BadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BadgeWhereInput
    orderBy?: BadgeOrderByWithAggregationInput | BadgeOrderByWithAggregationInput[]
    by: BadgeScalarFieldEnum[] | BadgeScalarFieldEnum
    having?: BadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BadgeCountAggregateInputType | true
    _avg?: BadgeAvgAggregateInputType
    _sum?: BadgeSumAggregateInputType
    _min?: BadgeMinAggregateInputType
    _max?: BadgeMaxAggregateInputType
  }

  export type BadgeGroupByOutputType = {
    id: string
    name: string
    imageUrl: string
    xpReq: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: BadgeCountAggregateOutputType | null
    _avg: BadgeAvgAggregateOutputType | null
    _sum: BadgeSumAggregateOutputType | null
    _min: BadgeMinAggregateOutputType | null
    _max: BadgeMaxAggregateOutputType | null
  }

  type GetBadgeGroupByPayload<T extends BadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BadgeGroupByOutputType[P]>
            : GetScalarType<T[P], BadgeGroupByOutputType[P]>
        }
      >
    >


  export type BadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    xpReq?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    badges?: boolean | Badge$badgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    xpReq?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    xpReq?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["badge"]>

  export type BadgeSelectScalar = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    xpReq?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "imageUrl" | "xpReq" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["badge"]>
  export type BadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    badges?: boolean | Badge$badgesArgs<ExtArgs>
    _count?: boolean | BadgeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Badge"
    objects: {
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      imageUrl: string
      xpReq: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["badge"]>
    composites: {}
  }

  type BadgeGetPayload<S extends boolean | null | undefined | BadgeDefaultArgs> = $Result.GetResult<Prisma.$BadgePayload, S>

  type BadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BadgeCountAggregateInputType | true
    }

  export interface BadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Badge'], meta: { name: 'Badge' } }
    /**
     * Find zero or one Badge that matches the filter.
     * @param {BadgeFindUniqueArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BadgeFindUniqueArgs>(args: SelectSubset<T, BadgeFindUniqueArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Badge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BadgeFindUniqueOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, BadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BadgeFindFirstArgs>(args?: SelectSubset<T, BadgeFindFirstArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Badge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindFirstOrThrowArgs} args - Arguments to find a Badge
     * @example
     * // Get one Badge
     * const badge = await prisma.badge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, BadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Badges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Badges
     * const badges = await prisma.badge.findMany()
     * 
     * // Get first 10 Badges
     * const badges = await prisma.badge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const badgeWithIdOnly = await prisma.badge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BadgeFindManyArgs>(args?: SelectSubset<T, BadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Badge.
     * @param {BadgeCreateArgs} args - Arguments to create a Badge.
     * @example
     * // Create one Badge
     * const Badge = await prisma.badge.create({
     *   data: {
     *     // ... data to create a Badge
     *   }
     * })
     * 
     */
    create<T extends BadgeCreateArgs>(args: SelectSubset<T, BadgeCreateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Badges.
     * @param {BadgeCreateManyArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BadgeCreateManyArgs>(args?: SelectSubset<T, BadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Badges and returns the data saved in the database.
     * @param {BadgeCreateManyAndReturnArgs} args - Arguments to create many Badges.
     * @example
     * // Create many Badges
     * const badge = await prisma.badge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, BadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Badge.
     * @param {BadgeDeleteArgs} args - Arguments to delete one Badge.
     * @example
     * // Delete one Badge
     * const Badge = await prisma.badge.delete({
     *   where: {
     *     // ... filter to delete one Badge
     *   }
     * })
     * 
     */
    delete<T extends BadgeDeleteArgs>(args: SelectSubset<T, BadgeDeleteArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Badge.
     * @param {BadgeUpdateArgs} args - Arguments to update one Badge.
     * @example
     * // Update one Badge
     * const badge = await prisma.badge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BadgeUpdateArgs>(args: SelectSubset<T, BadgeUpdateArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Badges.
     * @param {BadgeDeleteManyArgs} args - Arguments to filter Badges to delete.
     * @example
     * // Delete a few Badges
     * const { count } = await prisma.badge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BadgeDeleteManyArgs>(args?: SelectSubset<T, BadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BadgeUpdateManyArgs>(args: SelectSubset<T, BadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Badges and returns the data updated in the database.
     * @param {BadgeUpdateManyAndReturnArgs} args - Arguments to update many Badges.
     * @example
     * // Update many Badges
     * const badge = await prisma.badge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Badges and only return the `id`
     * const badgeWithIdOnly = await prisma.badge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, BadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Badge.
     * @param {BadgeUpsertArgs} args - Arguments to update or create a Badge.
     * @example
     * // Update or create a Badge
     * const badge = await prisma.badge.upsert({
     *   create: {
     *     // ... data to create a Badge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Badge we want to update
     *   }
     * })
     */
    upsert<T extends BadgeUpsertArgs>(args: SelectSubset<T, BadgeUpsertArgs<ExtArgs>>): Prisma__BadgeClient<$Result.GetResult<Prisma.$BadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Badges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeCountArgs} args - Arguments to filter Badges to count.
     * @example
     * // Count the number of Badges
     * const count = await prisma.badge.count({
     *   where: {
     *     // ... the filter for the Badges we want to count
     *   }
     * })
    **/
    count<T extends BadgeCountArgs>(
      args?: Subset<T, BadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BadgeAggregateArgs>(args: Subset<T, BadgeAggregateArgs>): Prisma.PrismaPromise<GetBadgeAggregateType<T>>

    /**
     * Group by Badge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BadgeGroupByArgs['orderBy'] }
        : { orderBy?: BadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Badge model
   */
  readonly fields: BadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Badge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    badges<T extends Badge$badgesArgs<ExtArgs> = {}>(args?: Subset<T, Badge$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Badge model
   */
  interface BadgeFieldRefs {
    readonly id: FieldRef<"Badge", 'String'>
    readonly name: FieldRef<"Badge", 'String'>
    readonly imageUrl: FieldRef<"Badge", 'String'>
    readonly xpReq: FieldRef<"Badge", 'Int'>
    readonly description: FieldRef<"Badge", 'String'>
    readonly createdAt: FieldRef<"Badge", 'DateTime'>
    readonly updatedAt: FieldRef<"Badge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Badge findUnique
   */
  export type BadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findUniqueOrThrow
   */
  export type BadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge findFirst
   */
  export type BadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findFirstOrThrow
   */
  export type BadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badge to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Badges.
     */
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge findMany
   */
  export type BadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter, which Badges to fetch.
     */
    where?: BadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Badges to fetch.
     */
    orderBy?: BadgeOrderByWithRelationInput | BadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Badges.
     */
    cursor?: BadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Badges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Badges.
     */
    skip?: number
    distinct?: BadgeScalarFieldEnum | BadgeScalarFieldEnum[]
  }

  /**
   * Badge create
   */
  export type BadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a Badge.
     */
    data: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
  }

  /**
   * Badge createMany
   */
  export type BadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge createManyAndReturn
   */
  export type BadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to create many Badges.
     */
    data: BadgeCreateManyInput | BadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Badge update
   */
  export type BadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a Badge.
     */
    data: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
    /**
     * Choose, which Badge to update.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge updateMany
   */
  export type BadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge updateManyAndReturn
   */
  export type BadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * The data used to update Badges.
     */
    data: XOR<BadgeUpdateManyMutationInput, BadgeUncheckedUpdateManyInput>
    /**
     * Filter which Badges to update
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to update.
     */
    limit?: number
  }

  /**
   * Badge upsert
   */
  export type BadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the Badge to update in case it exists.
     */
    where: BadgeWhereUniqueInput
    /**
     * In case the Badge found by the `where` argument doesn't exist, create a new Badge with this data.
     */
    create: XOR<BadgeCreateInput, BadgeUncheckedCreateInput>
    /**
     * In case the Badge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BadgeUpdateInput, BadgeUncheckedUpdateInput>
  }

  /**
   * Badge delete
   */
  export type BadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
    /**
     * Filter which Badge to delete.
     */
    where: BadgeWhereUniqueInput
  }

  /**
   * Badge deleteMany
   */
  export type BadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Badges to delete
     */
    where?: BadgeWhereInput
    /**
     * Limit how many Badges to delete.
     */
    limit?: number
  }

  /**
   * Badge.badges
   */
  export type Badge$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserBadge
     */
    omit?: UserBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * Badge without action
   */
  export type BadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Badge
     */
    select?: BadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Badge
     */
    omit?: BadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BadgeInclude<ExtArgs> | null
  }


  /**
   * Model CoinWallet
   */

  export type AggregateCoinWallet = {
    _count: CoinWalletCountAggregateOutputType | null
    _avg: CoinWalletAvgAggregateOutputType | null
    _sum: CoinWalletSumAggregateOutputType | null
    _min: CoinWalletMinAggregateOutputType | null
    _max: CoinWalletMaxAggregateOutputType | null
  }

  export type CoinWalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type CoinWalletSumAggregateOutputType = {
    balance: number | null
  }

  export type CoinWalletMinAggregateOutputType = {
    profileId: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoinWalletMaxAggregateOutputType = {
    profileId: string | null
    balance: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoinWalletCountAggregateOutputType = {
    profileId: number
    balance: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoinWalletAvgAggregateInputType = {
    balance?: true
  }

  export type CoinWalletSumAggregateInputType = {
    balance?: true
  }

  export type CoinWalletMinAggregateInputType = {
    profileId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoinWalletMaxAggregateInputType = {
    profileId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoinWalletCountAggregateInputType = {
    profileId?: true
    balance?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoinWalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinWallet to aggregate.
     */
    where?: CoinWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinWallets to fetch.
     */
    orderBy?: CoinWalletOrderByWithRelationInput | CoinWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoinWallets
    **/
    _count?: true | CoinWalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinWalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinWalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinWalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinWalletMaxAggregateInputType
  }

  export type GetCoinWalletAggregateType<T extends CoinWalletAggregateArgs> = {
        [P in keyof T & keyof AggregateCoinWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoinWallet[P]>
      : GetScalarType<T[P], AggregateCoinWallet[P]>
  }




  export type CoinWalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinWalletWhereInput
    orderBy?: CoinWalletOrderByWithAggregationInput | CoinWalletOrderByWithAggregationInput[]
    by: CoinWalletScalarFieldEnum[] | CoinWalletScalarFieldEnum
    having?: CoinWalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinWalletCountAggregateInputType | true
    _avg?: CoinWalletAvgAggregateInputType
    _sum?: CoinWalletSumAggregateInputType
    _min?: CoinWalletMinAggregateInputType
    _max?: CoinWalletMaxAggregateInputType
  }

  export type CoinWalletGroupByOutputType = {
    profileId: string
    balance: number
    createdAt: Date
    updatedAt: Date
    _count: CoinWalletCountAggregateOutputType | null
    _avg: CoinWalletAvgAggregateOutputType | null
    _sum: CoinWalletSumAggregateOutputType | null
    _min: CoinWalletMinAggregateOutputType | null
    _max: CoinWalletMaxAggregateOutputType | null
  }

  type GetCoinWalletGroupByPayload<T extends CoinWalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinWalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinWalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinWalletGroupByOutputType[P]>
            : GetScalarType<T[P], CoinWalletGroupByOutputType[P]>
        }
      >
    >


  export type CoinWalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinWallet"]>

  export type CoinWalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinWallet"]>

  export type CoinWalletSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinWallet"]>

  export type CoinWalletSelectScalar = {
    profileId?: boolean
    balance?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoinWalletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profileId" | "balance" | "createdAt" | "updatedAt", ExtArgs["result"]["coinWallet"]>
  export type CoinWalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type CoinWalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type CoinWalletIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $CoinWalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoinWallet"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      profileId: string
      balance: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coinWallet"]>
    composites: {}
  }

  type CoinWalletGetPayload<S extends boolean | null | undefined | CoinWalletDefaultArgs> = $Result.GetResult<Prisma.$CoinWalletPayload, S>

  type CoinWalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoinWalletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoinWalletCountAggregateInputType | true
    }

  export interface CoinWalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoinWallet'], meta: { name: 'CoinWallet' } }
    /**
     * Find zero or one CoinWallet that matches the filter.
     * @param {CoinWalletFindUniqueArgs} args - Arguments to find a CoinWallet
     * @example
     * // Get one CoinWallet
     * const coinWallet = await prisma.coinWallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoinWalletFindUniqueArgs>(args: SelectSubset<T, CoinWalletFindUniqueArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoinWallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoinWalletFindUniqueOrThrowArgs} args - Arguments to find a CoinWallet
     * @example
     * // Get one CoinWallet
     * const coinWallet = await prisma.coinWallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoinWalletFindUniqueOrThrowArgs>(args: SelectSubset<T, CoinWalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinWallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletFindFirstArgs} args - Arguments to find a CoinWallet
     * @example
     * // Get one CoinWallet
     * const coinWallet = await prisma.coinWallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoinWalletFindFirstArgs>(args?: SelectSubset<T, CoinWalletFindFirstArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinWallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletFindFirstOrThrowArgs} args - Arguments to find a CoinWallet
     * @example
     * // Get one CoinWallet
     * const coinWallet = await prisma.coinWallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoinWalletFindFirstOrThrowArgs>(args?: SelectSubset<T, CoinWalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoinWallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoinWallets
     * const coinWallets = await prisma.coinWallet.findMany()
     * 
     * // Get first 10 CoinWallets
     * const coinWallets = await prisma.coinWallet.findMany({ take: 10 })
     * 
     * // Only select the `profileId`
     * const coinWalletWithProfileIdOnly = await prisma.coinWallet.findMany({ select: { profileId: true } })
     * 
     */
    findMany<T extends CoinWalletFindManyArgs>(args?: SelectSubset<T, CoinWalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoinWallet.
     * @param {CoinWalletCreateArgs} args - Arguments to create a CoinWallet.
     * @example
     * // Create one CoinWallet
     * const CoinWallet = await prisma.coinWallet.create({
     *   data: {
     *     // ... data to create a CoinWallet
     *   }
     * })
     * 
     */
    create<T extends CoinWalletCreateArgs>(args: SelectSubset<T, CoinWalletCreateArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoinWallets.
     * @param {CoinWalletCreateManyArgs} args - Arguments to create many CoinWallets.
     * @example
     * // Create many CoinWallets
     * const coinWallet = await prisma.coinWallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoinWalletCreateManyArgs>(args?: SelectSubset<T, CoinWalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoinWallets and returns the data saved in the database.
     * @param {CoinWalletCreateManyAndReturnArgs} args - Arguments to create many CoinWallets.
     * @example
     * // Create many CoinWallets
     * const coinWallet = await prisma.coinWallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoinWallets and only return the `profileId`
     * const coinWalletWithProfileIdOnly = await prisma.coinWallet.createManyAndReturn({
     *   select: { profileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoinWalletCreateManyAndReturnArgs>(args?: SelectSubset<T, CoinWalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoinWallet.
     * @param {CoinWalletDeleteArgs} args - Arguments to delete one CoinWallet.
     * @example
     * // Delete one CoinWallet
     * const CoinWallet = await prisma.coinWallet.delete({
     *   where: {
     *     // ... filter to delete one CoinWallet
     *   }
     * })
     * 
     */
    delete<T extends CoinWalletDeleteArgs>(args: SelectSubset<T, CoinWalletDeleteArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoinWallet.
     * @param {CoinWalletUpdateArgs} args - Arguments to update one CoinWallet.
     * @example
     * // Update one CoinWallet
     * const coinWallet = await prisma.coinWallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoinWalletUpdateArgs>(args: SelectSubset<T, CoinWalletUpdateArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoinWallets.
     * @param {CoinWalletDeleteManyArgs} args - Arguments to filter CoinWallets to delete.
     * @example
     * // Delete a few CoinWallets
     * const { count } = await prisma.coinWallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoinWalletDeleteManyArgs>(args?: SelectSubset<T, CoinWalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoinWallets
     * const coinWallet = await prisma.coinWallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoinWalletUpdateManyArgs>(args: SelectSubset<T, CoinWalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinWallets and returns the data updated in the database.
     * @param {CoinWalletUpdateManyAndReturnArgs} args - Arguments to update many CoinWallets.
     * @example
     * // Update many CoinWallets
     * const coinWallet = await prisma.coinWallet.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoinWallets and only return the `profileId`
     * const coinWalletWithProfileIdOnly = await prisma.coinWallet.updateManyAndReturn({
     *   select: { profileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoinWalletUpdateManyAndReturnArgs>(args: SelectSubset<T, CoinWalletUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoinWallet.
     * @param {CoinWalletUpsertArgs} args - Arguments to update or create a CoinWallet.
     * @example
     * // Update or create a CoinWallet
     * const coinWallet = await prisma.coinWallet.upsert({
     *   create: {
     *     // ... data to create a CoinWallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoinWallet we want to update
     *   }
     * })
     */
    upsert<T extends CoinWalletUpsertArgs>(args: SelectSubset<T, CoinWalletUpsertArgs<ExtArgs>>): Prisma__CoinWalletClient<$Result.GetResult<Prisma.$CoinWalletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoinWallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletCountArgs} args - Arguments to filter CoinWallets to count.
     * @example
     * // Count the number of CoinWallets
     * const count = await prisma.coinWallet.count({
     *   where: {
     *     // ... the filter for the CoinWallets we want to count
     *   }
     * })
    **/
    count<T extends CoinWalletCountArgs>(
      args?: Subset<T, CoinWalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinWalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoinWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinWalletAggregateArgs>(args: Subset<T, CoinWalletAggregateArgs>): Prisma.PrismaPromise<GetCoinWalletAggregateType<T>>

    /**
     * Group by CoinWallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinWalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinWalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinWalletGroupByArgs['orderBy'] }
        : { orderBy?: CoinWalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinWalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoinWallet model
   */
  readonly fields: CoinWalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoinWallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinWalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoinWallet model
   */
  interface CoinWalletFieldRefs {
    readonly profileId: FieldRef<"CoinWallet", 'String'>
    readonly balance: FieldRef<"CoinWallet", 'Int'>
    readonly createdAt: FieldRef<"CoinWallet", 'DateTime'>
    readonly updatedAt: FieldRef<"CoinWallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoinWallet findUnique
   */
  export type CoinWalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter, which CoinWallet to fetch.
     */
    where: CoinWalletWhereUniqueInput
  }

  /**
   * CoinWallet findUniqueOrThrow
   */
  export type CoinWalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter, which CoinWallet to fetch.
     */
    where: CoinWalletWhereUniqueInput
  }

  /**
   * CoinWallet findFirst
   */
  export type CoinWalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter, which CoinWallet to fetch.
     */
    where?: CoinWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinWallets to fetch.
     */
    orderBy?: CoinWalletOrderByWithRelationInput | CoinWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinWallets.
     */
    cursor?: CoinWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinWallets.
     */
    distinct?: CoinWalletScalarFieldEnum | CoinWalletScalarFieldEnum[]
  }

  /**
   * CoinWallet findFirstOrThrow
   */
  export type CoinWalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter, which CoinWallet to fetch.
     */
    where?: CoinWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinWallets to fetch.
     */
    orderBy?: CoinWalletOrderByWithRelationInput | CoinWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinWallets.
     */
    cursor?: CoinWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinWallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinWallets.
     */
    distinct?: CoinWalletScalarFieldEnum | CoinWalletScalarFieldEnum[]
  }

  /**
   * CoinWallet findMany
   */
  export type CoinWalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter, which CoinWallets to fetch.
     */
    where?: CoinWalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinWallets to fetch.
     */
    orderBy?: CoinWalletOrderByWithRelationInput | CoinWalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoinWallets.
     */
    cursor?: CoinWalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinWallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinWallets.
     */
    skip?: number
    distinct?: CoinWalletScalarFieldEnum | CoinWalletScalarFieldEnum[]
  }

  /**
   * CoinWallet create
   */
  export type CoinWalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * The data needed to create a CoinWallet.
     */
    data: XOR<CoinWalletCreateInput, CoinWalletUncheckedCreateInput>
  }

  /**
   * CoinWallet createMany
   */
  export type CoinWalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoinWallets.
     */
    data: CoinWalletCreateManyInput | CoinWalletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoinWallet createManyAndReturn
   */
  export type CoinWalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * The data used to create many CoinWallets.
     */
    data: CoinWalletCreateManyInput | CoinWalletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinWallet update
   */
  export type CoinWalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * The data needed to update a CoinWallet.
     */
    data: XOR<CoinWalletUpdateInput, CoinWalletUncheckedUpdateInput>
    /**
     * Choose, which CoinWallet to update.
     */
    where: CoinWalletWhereUniqueInput
  }

  /**
   * CoinWallet updateMany
   */
  export type CoinWalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoinWallets.
     */
    data: XOR<CoinWalletUpdateManyMutationInput, CoinWalletUncheckedUpdateManyInput>
    /**
     * Filter which CoinWallets to update
     */
    where?: CoinWalletWhereInput
    /**
     * Limit how many CoinWallets to update.
     */
    limit?: number
  }

  /**
   * CoinWallet updateManyAndReturn
   */
  export type CoinWalletUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * The data used to update CoinWallets.
     */
    data: XOR<CoinWalletUpdateManyMutationInput, CoinWalletUncheckedUpdateManyInput>
    /**
     * Filter which CoinWallets to update
     */
    where?: CoinWalletWhereInput
    /**
     * Limit how many CoinWallets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinWallet upsert
   */
  export type CoinWalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * The filter to search for the CoinWallet to update in case it exists.
     */
    where: CoinWalletWhereUniqueInput
    /**
     * In case the CoinWallet found by the `where` argument doesn't exist, create a new CoinWallet with this data.
     */
    create: XOR<CoinWalletCreateInput, CoinWalletUncheckedCreateInput>
    /**
     * In case the CoinWallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinWalletUpdateInput, CoinWalletUncheckedUpdateInput>
  }

  /**
   * CoinWallet delete
   */
  export type CoinWalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
    /**
     * Filter which CoinWallet to delete.
     */
    where: CoinWalletWhereUniqueInput
  }

  /**
   * CoinWallet deleteMany
   */
  export type CoinWalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinWallets to delete
     */
    where?: CoinWalletWhereInput
    /**
     * Limit how many CoinWallets to delete.
     */
    limit?: number
  }

  /**
   * CoinWallet without action
   */
  export type CoinWalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinWallet
     */
    select?: CoinWalletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinWallet
     */
    omit?: CoinWalletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinWalletInclude<ExtArgs> | null
  }


  /**
   * Model CoinTransaction
   */

  export type AggregateCoinTransaction = {
    _count: CoinTransactionCountAggregateOutputType | null
    _avg: CoinTransactionAvgAggregateOutputType | null
    _sum: CoinTransactionSumAggregateOutputType | null
    _min: CoinTransactionMinAggregateOutputType | null
    _max: CoinTransactionMaxAggregateOutputType | null
  }

  export type CoinTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type CoinTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type CoinTransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    description: string | null
    transactionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type CoinTransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    amount: number | null
    description: string | null
    transactionAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    profileId: string | null
  }

  export type CoinTransactionCountAggregateOutputType = {
    id: number
    type: number
    amount: number
    description: number
    transactionAt: number
    createdAt: number
    updatedAt: number
    profileId: number
    _all: number
  }


  export type CoinTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type CoinTransactionSumAggregateInputType = {
    amount?: true
  }

  export type CoinTransactionMinAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    transactionAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type CoinTransactionMaxAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    transactionAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
  }

  export type CoinTransactionCountAggregateInputType = {
    id?: true
    type?: true
    amount?: true
    description?: true
    transactionAt?: true
    createdAt?: true
    updatedAt?: true
    profileId?: true
    _all?: true
  }

  export type CoinTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinTransaction to aggregate.
     */
    where?: CoinTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinTransactions to fetch.
     */
    orderBy?: CoinTransactionOrderByWithRelationInput | CoinTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoinTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoinTransactions
    **/
    _count?: true | CoinTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoinTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoinTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoinTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoinTransactionMaxAggregateInputType
  }

  export type GetCoinTransactionAggregateType<T extends CoinTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCoinTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoinTransaction[P]>
      : GetScalarType<T[P], AggregateCoinTransaction[P]>
  }




  export type CoinTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoinTransactionWhereInput
    orderBy?: CoinTransactionOrderByWithAggregationInput | CoinTransactionOrderByWithAggregationInput[]
    by: CoinTransactionScalarFieldEnum[] | CoinTransactionScalarFieldEnum
    having?: CoinTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoinTransactionCountAggregateInputType | true
    _avg?: CoinTransactionAvgAggregateInputType
    _sum?: CoinTransactionSumAggregateInputType
    _min?: CoinTransactionMinAggregateInputType
    _max?: CoinTransactionMaxAggregateInputType
  }

  export type CoinTransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt: Date
    createdAt: Date
    updatedAt: Date
    profileId: string
    _count: CoinTransactionCountAggregateOutputType | null
    _avg: CoinTransactionAvgAggregateOutputType | null
    _sum: CoinTransactionSumAggregateOutputType | null
    _min: CoinTransactionMinAggregateOutputType | null
    _max: CoinTransactionMaxAggregateOutputType | null
  }

  type GetCoinTransactionGroupByPayload<T extends CoinTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoinTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoinTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoinTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], CoinTransactionGroupByOutputType[P]>
        }
      >
    >


  export type CoinTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    transactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinTransaction"]>

  export type CoinTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    transactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinTransaction"]>

  export type CoinTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    transactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coinTransaction"]>

  export type CoinTransactionSelectScalar = {
    id?: boolean
    type?: boolean
    amount?: boolean
    description?: boolean
    transactionAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profileId?: boolean
  }

  export type CoinTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "amount" | "description" | "transactionAt" | "createdAt" | "updatedAt" | "profileId", ExtArgs["result"]["coinTransaction"]>
  export type CoinTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type CoinTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }
  export type CoinTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | UserProfileDefaultArgs<ExtArgs>
  }

  export type $CoinTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoinTransaction"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      amount: number
      description: string
      transactionAt: Date
      createdAt: Date
      updatedAt: Date
      profileId: string
    }, ExtArgs["result"]["coinTransaction"]>
    composites: {}
  }

  type CoinTransactionGetPayload<S extends boolean | null | undefined | CoinTransactionDefaultArgs> = $Result.GetResult<Prisma.$CoinTransactionPayload, S>

  type CoinTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CoinTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoinTransactionCountAggregateInputType | true
    }

  export interface CoinTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoinTransaction'], meta: { name: 'CoinTransaction' } }
    /**
     * Find zero or one CoinTransaction that matches the filter.
     * @param {CoinTransactionFindUniqueArgs} args - Arguments to find a CoinTransaction
     * @example
     * // Get one CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoinTransactionFindUniqueArgs>(args: SelectSubset<T, CoinTransactionFindUniqueArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CoinTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CoinTransactionFindUniqueOrThrowArgs} args - Arguments to find a CoinTransaction
     * @example
     * // Get one CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoinTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CoinTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionFindFirstArgs} args - Arguments to find a CoinTransaction
     * @example
     * // Get one CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoinTransactionFindFirstArgs>(args?: SelectSubset<T, CoinTransactionFindFirstArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CoinTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionFindFirstOrThrowArgs} args - Arguments to find a CoinTransaction
     * @example
     * // Get one CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoinTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CoinTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CoinTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoinTransactions
     * const coinTransactions = await prisma.coinTransaction.findMany()
     * 
     * // Get first 10 CoinTransactions
     * const coinTransactions = await prisma.coinTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coinTransactionWithIdOnly = await prisma.coinTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoinTransactionFindManyArgs>(args?: SelectSubset<T, CoinTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CoinTransaction.
     * @param {CoinTransactionCreateArgs} args - Arguments to create a CoinTransaction.
     * @example
     * // Create one CoinTransaction
     * const CoinTransaction = await prisma.coinTransaction.create({
     *   data: {
     *     // ... data to create a CoinTransaction
     *   }
     * })
     * 
     */
    create<T extends CoinTransactionCreateArgs>(args: SelectSubset<T, CoinTransactionCreateArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CoinTransactions.
     * @param {CoinTransactionCreateManyArgs} args - Arguments to create many CoinTransactions.
     * @example
     * // Create many CoinTransactions
     * const coinTransaction = await prisma.coinTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoinTransactionCreateManyArgs>(args?: SelectSubset<T, CoinTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoinTransactions and returns the data saved in the database.
     * @param {CoinTransactionCreateManyAndReturnArgs} args - Arguments to create many CoinTransactions.
     * @example
     * // Create many CoinTransactions
     * const coinTransaction = await prisma.coinTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoinTransactions and only return the `id`
     * const coinTransactionWithIdOnly = await prisma.coinTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoinTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CoinTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CoinTransaction.
     * @param {CoinTransactionDeleteArgs} args - Arguments to delete one CoinTransaction.
     * @example
     * // Delete one CoinTransaction
     * const CoinTransaction = await prisma.coinTransaction.delete({
     *   where: {
     *     // ... filter to delete one CoinTransaction
     *   }
     * })
     * 
     */
    delete<T extends CoinTransactionDeleteArgs>(args: SelectSubset<T, CoinTransactionDeleteArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CoinTransaction.
     * @param {CoinTransactionUpdateArgs} args - Arguments to update one CoinTransaction.
     * @example
     * // Update one CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoinTransactionUpdateArgs>(args: SelectSubset<T, CoinTransactionUpdateArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CoinTransactions.
     * @param {CoinTransactionDeleteManyArgs} args - Arguments to filter CoinTransactions to delete.
     * @example
     * // Delete a few CoinTransactions
     * const { count } = await prisma.coinTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoinTransactionDeleteManyArgs>(args?: SelectSubset<T, CoinTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoinTransactions
     * const coinTransaction = await prisma.coinTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoinTransactionUpdateManyArgs>(args: SelectSubset<T, CoinTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoinTransactions and returns the data updated in the database.
     * @param {CoinTransactionUpdateManyAndReturnArgs} args - Arguments to update many CoinTransactions.
     * @example
     * // Update many CoinTransactions
     * const coinTransaction = await prisma.coinTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CoinTransactions and only return the `id`
     * const coinTransactionWithIdOnly = await prisma.coinTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CoinTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CoinTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CoinTransaction.
     * @param {CoinTransactionUpsertArgs} args - Arguments to update or create a CoinTransaction.
     * @example
     * // Update or create a CoinTransaction
     * const coinTransaction = await prisma.coinTransaction.upsert({
     *   create: {
     *     // ... data to create a CoinTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoinTransaction we want to update
     *   }
     * })
     */
    upsert<T extends CoinTransactionUpsertArgs>(args: SelectSubset<T, CoinTransactionUpsertArgs<ExtArgs>>): Prisma__CoinTransactionClient<$Result.GetResult<Prisma.$CoinTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CoinTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionCountArgs} args - Arguments to filter CoinTransactions to count.
     * @example
     * // Count the number of CoinTransactions
     * const count = await prisma.coinTransaction.count({
     *   where: {
     *     // ... the filter for the CoinTransactions we want to count
     *   }
     * })
    **/
    count<T extends CoinTransactionCountArgs>(
      args?: Subset<T, CoinTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoinTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoinTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoinTransactionAggregateArgs>(args: Subset<T, CoinTransactionAggregateArgs>): Prisma.PrismaPromise<GetCoinTransactionAggregateType<T>>

    /**
     * Group by CoinTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoinTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoinTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoinTransactionGroupByArgs['orderBy'] }
        : { orderBy?: CoinTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoinTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoinTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoinTransaction model
   */
  readonly fields: CoinTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoinTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoinTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends UserProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserProfileDefaultArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoinTransaction model
   */
  interface CoinTransactionFieldRefs {
    readonly id: FieldRef<"CoinTransaction", 'String'>
    readonly type: FieldRef<"CoinTransaction", 'TransactionType'>
    readonly amount: FieldRef<"CoinTransaction", 'Int'>
    readonly description: FieldRef<"CoinTransaction", 'String'>
    readonly transactionAt: FieldRef<"CoinTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"CoinTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"CoinTransaction", 'DateTime'>
    readonly profileId: FieldRef<"CoinTransaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CoinTransaction findUnique
   */
  export type CoinTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CoinTransaction to fetch.
     */
    where: CoinTransactionWhereUniqueInput
  }

  /**
   * CoinTransaction findUniqueOrThrow
   */
  export type CoinTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CoinTransaction to fetch.
     */
    where: CoinTransactionWhereUniqueInput
  }

  /**
   * CoinTransaction findFirst
   */
  export type CoinTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CoinTransaction to fetch.
     */
    where?: CoinTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinTransactions to fetch.
     */
    orderBy?: CoinTransactionOrderByWithRelationInput | CoinTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinTransactions.
     */
    cursor?: CoinTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinTransactions.
     */
    distinct?: CoinTransactionScalarFieldEnum | CoinTransactionScalarFieldEnum[]
  }

  /**
   * CoinTransaction findFirstOrThrow
   */
  export type CoinTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CoinTransaction to fetch.
     */
    where?: CoinTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinTransactions to fetch.
     */
    orderBy?: CoinTransactionOrderByWithRelationInput | CoinTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoinTransactions.
     */
    cursor?: CoinTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoinTransactions.
     */
    distinct?: CoinTransactionScalarFieldEnum | CoinTransactionScalarFieldEnum[]
  }

  /**
   * CoinTransaction findMany
   */
  export type CoinTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter, which CoinTransactions to fetch.
     */
    where?: CoinTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoinTransactions to fetch.
     */
    orderBy?: CoinTransactionOrderByWithRelationInput | CoinTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoinTransactions.
     */
    cursor?: CoinTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoinTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoinTransactions.
     */
    skip?: number
    distinct?: CoinTransactionScalarFieldEnum | CoinTransactionScalarFieldEnum[]
  }

  /**
   * CoinTransaction create
   */
  export type CoinTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CoinTransaction.
     */
    data: XOR<CoinTransactionCreateInput, CoinTransactionUncheckedCreateInput>
  }

  /**
   * CoinTransaction createMany
   */
  export type CoinTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoinTransactions.
     */
    data: CoinTransactionCreateManyInput | CoinTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CoinTransaction createManyAndReturn
   */
  export type CoinTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many CoinTransactions.
     */
    data: CoinTransactionCreateManyInput | CoinTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinTransaction update
   */
  export type CoinTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CoinTransaction.
     */
    data: XOR<CoinTransactionUpdateInput, CoinTransactionUncheckedUpdateInput>
    /**
     * Choose, which CoinTransaction to update.
     */
    where: CoinTransactionWhereUniqueInput
  }

  /**
   * CoinTransaction updateMany
   */
  export type CoinTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoinTransactions.
     */
    data: XOR<CoinTransactionUpdateManyMutationInput, CoinTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CoinTransactions to update
     */
    where?: CoinTransactionWhereInput
    /**
     * Limit how many CoinTransactions to update.
     */
    limit?: number
  }

  /**
   * CoinTransaction updateManyAndReturn
   */
  export type CoinTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * The data used to update CoinTransactions.
     */
    data: XOR<CoinTransactionUpdateManyMutationInput, CoinTransactionUncheckedUpdateManyInput>
    /**
     * Filter which CoinTransactions to update
     */
    where?: CoinTransactionWhereInput
    /**
     * Limit how many CoinTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoinTransaction upsert
   */
  export type CoinTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CoinTransaction to update in case it exists.
     */
    where: CoinTransactionWhereUniqueInput
    /**
     * In case the CoinTransaction found by the `where` argument doesn't exist, create a new CoinTransaction with this data.
     */
    create: XOR<CoinTransactionCreateInput, CoinTransactionUncheckedCreateInput>
    /**
     * In case the CoinTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoinTransactionUpdateInput, CoinTransactionUncheckedUpdateInput>
  }

  /**
   * CoinTransaction delete
   */
  export type CoinTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
    /**
     * Filter which CoinTransaction to delete.
     */
    where: CoinTransactionWhereUniqueInput
  }

  /**
   * CoinTransaction deleteMany
   */
  export type CoinTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoinTransactions to delete
     */
    where?: CoinTransactionWhereInput
    /**
     * Limit how many CoinTransactions to delete.
     */
    limit?: number
  }

  /**
   * CoinTransaction without action
   */
  export type CoinTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoinTransaction
     */
    select?: CoinTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CoinTransaction
     */
    omit?: CoinTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoinTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    type: $Enums.RoadmapType | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    type: $Enums.RoadmapType | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    type: number
    createdById: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RoadmapMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    type?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    title: string
    description: string | null
    category: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | Roadmap$stepsArgs<ExtArgs>
    roadmapProgress?: boolean | Roadmap$roadmapProgressArgs<ExtArgs>
    lastActivities?: boolean | Roadmap$lastActivitiesArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    type?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RoadmapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "type" | "createdById" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["roadmap"]>
  export type RoadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    steps?: boolean | Roadmap$stepsArgs<ExtArgs>
    roadmapProgress?: boolean | Roadmap$roadmapProgressArgs<ExtArgs>
    lastActivities?: boolean | Roadmap$lastActivitiesArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      steps: Prisma.$RoadmapStepPayload<ExtArgs>[]
      roadmapProgress: Prisma.$RoadmapProgressPayload<ExtArgs>[]
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      category: string | null
      type: $Enums.RoadmapType
      createdById: string
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {RoadmapCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps and returns the data updated in the database.
     * @param {RoadmapUpdateManyAndReturnArgs} args - Arguments to update many Roadmaps.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends Roadmap$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmapProgress<T extends Roadmap$roadmapProgressArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$roadmapProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastActivities<T extends Roadmap$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly title: FieldRef<"Roadmap", 'String'>
    readonly description: FieldRef<"Roadmap", 'String'>
    readonly category: FieldRef<"Roadmap", 'String'>
    readonly type: FieldRef<"Roadmap", 'RoadmapType'>
    readonly createdById: FieldRef<"Roadmap", 'String'>
    readonly createdAt: FieldRef<"Roadmap", 'DateTime'>
    readonly updatedAt: FieldRef<"Roadmap", 'DateTime'>
    readonly deletedAt: FieldRef<"Roadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap createManyAndReturn
   */
  export type RoadmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to update.
     */
    limit?: number
  }

  /**
   * Roadmap updateManyAndReturn
   */
  export type RoadmapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
    /**
     * Limit how many Roadmaps to delete.
     */
    limit?: number
  }

  /**
   * Roadmap.steps
   */
  export type Roadmap$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    cursor?: RoadmapStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * Roadmap.roadmapProgress
   */
  export type Roadmap$roadmapProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    cursor?: RoadmapProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * Roadmap.lastActivities
   */
  export type Roadmap$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapProgress
   */

  export type AggregateRoadmapProgress = {
    _count: RoadmapProgressCountAggregateOutputType | null
    _avg: RoadmapProgressAvgAggregateOutputType | null
    _sum: RoadmapProgressSumAggregateOutputType | null
    _min: RoadmapProgressMinAggregateOutputType | null
    _max: RoadmapProgressMaxAggregateOutputType | null
  }

  export type RoadmapProgressAvgAggregateOutputType = {
    progress: number | null
  }

  export type RoadmapProgressSumAggregateOutputType = {
    progress: number | null
  }

  export type RoadmapProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    progress: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    progress: number | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapProgressCountAggregateOutputType = {
    id: number
    userId: number
    roadmapId: number
    progress: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapProgressAvgAggregateInputType = {
    progress?: true
  }

  export type RoadmapProgressSumAggregateInputType = {
    progress?: true
  }

  export type RoadmapProgressMinAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    progress?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    progress?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapProgressCountAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    progress?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapProgress to aggregate.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapProgresses
    **/
    _count?: true | RoadmapProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapProgressMaxAggregateInputType
  }

  export type GetRoadmapProgressAggregateType<T extends RoadmapProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapProgress[P]>
      : GetScalarType<T[P], AggregateRoadmapProgress[P]>
  }




  export type RoadmapProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithAggregationInput | RoadmapProgressOrderByWithAggregationInput[]
    by: RoadmapProgressScalarFieldEnum[] | RoadmapProgressScalarFieldEnum
    having?: RoadmapProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapProgressCountAggregateInputType | true
    _avg?: RoadmapProgressAvgAggregateInputType
    _sum?: RoadmapProgressSumAggregateInputType
    _min?: RoadmapProgressMinAggregateInputType
    _max?: RoadmapProgressMaxAggregateInputType
  }

  export type RoadmapProgressGroupByOutputType = {
    id: string
    userId: string
    roadmapId: string
    progress: number
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoadmapProgressCountAggregateOutputType | null
    _avg: RoadmapProgressAvgAggregateOutputType | null
    _sum: RoadmapProgressSumAggregateOutputType | null
    _min: RoadmapProgressMinAggregateOutputType | null
    _max: RoadmapProgressMaxAggregateOutputType | null
  }

  type GetRoadmapProgressGroupByPayload<T extends RoadmapProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapProgressGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapProgressGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    progress?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapProgress"]>

  export type RoadmapProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    progress?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapProgress"]>

  export type RoadmapProgressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    progress?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapProgress"]>

  export type RoadmapProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    progress?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapProgressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "roadmapId" | "progress" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["roadmapProgress"]>
  export type RoadmapProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }
  export type RoadmapProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }
  export type RoadmapProgressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }

  export type $RoadmapProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roadmapId: string
      progress: number
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapProgress"]>
    composites: {}
  }

  type RoadmapProgressGetPayload<S extends boolean | null | undefined | RoadmapProgressDefaultArgs> = $Result.GetResult<Prisma.$RoadmapProgressPayload, S>

  type RoadmapProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapProgressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapProgressCountAggregateInputType | true
    }

  export interface RoadmapProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapProgress'], meta: { name: 'RoadmapProgress' } }
    /**
     * Find zero or one RoadmapProgress that matches the filter.
     * @param {RoadmapProgressFindUniqueArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapProgressFindUniqueArgs>(args: SelectSubset<T, RoadmapProgressFindUniqueArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapProgress that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapProgressFindUniqueOrThrowArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindFirstArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapProgressFindFirstArgs>(args?: SelectSubset<T, RoadmapProgressFindFirstArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindFirstOrThrowArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapProgresses
     * const roadmapProgresses = await prisma.roadmapProgress.findMany()
     * 
     * // Get first 10 RoadmapProgresses
     * const roadmapProgresses = await prisma.roadmapProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapProgressWithIdOnly = await prisma.roadmapProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapProgressFindManyArgs>(args?: SelectSubset<T, RoadmapProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapProgress.
     * @param {RoadmapProgressCreateArgs} args - Arguments to create a RoadmapProgress.
     * @example
     * // Create one RoadmapProgress
     * const RoadmapProgress = await prisma.roadmapProgress.create({
     *   data: {
     *     // ... data to create a RoadmapProgress
     *   }
     * })
     * 
     */
    create<T extends RoadmapProgressCreateArgs>(args: SelectSubset<T, RoadmapProgressCreateArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapProgresses.
     * @param {RoadmapProgressCreateManyArgs} args - Arguments to create many RoadmapProgresses.
     * @example
     * // Create many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapProgressCreateManyArgs>(args?: SelectSubset<T, RoadmapProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapProgresses and returns the data saved in the database.
     * @param {RoadmapProgressCreateManyAndReturnArgs} args - Arguments to create many RoadmapProgresses.
     * @example
     * // Create many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapProgresses and only return the `id`
     * const roadmapProgressWithIdOnly = await prisma.roadmapProgress.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoadmapProgress.
     * @param {RoadmapProgressDeleteArgs} args - Arguments to delete one RoadmapProgress.
     * @example
     * // Delete one RoadmapProgress
     * const RoadmapProgress = await prisma.roadmapProgress.delete({
     *   where: {
     *     // ... filter to delete one RoadmapProgress
     *   }
     * })
     * 
     */
    delete<T extends RoadmapProgressDeleteArgs>(args: SelectSubset<T, RoadmapProgressDeleteArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapProgress.
     * @param {RoadmapProgressUpdateArgs} args - Arguments to update one RoadmapProgress.
     * @example
     * // Update one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapProgressUpdateArgs>(args: SelectSubset<T, RoadmapProgressUpdateArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapProgresses.
     * @param {RoadmapProgressDeleteManyArgs} args - Arguments to filter RoadmapProgresses to delete.
     * @example
     * // Delete a few RoadmapProgresses
     * const { count } = await prisma.roadmapProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapProgressDeleteManyArgs>(args?: SelectSubset<T, RoadmapProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapProgressUpdateManyArgs>(args: SelectSubset<T, RoadmapProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapProgresses and returns the data updated in the database.
     * @param {RoadmapProgressUpdateManyAndReturnArgs} args - Arguments to update many RoadmapProgresses.
     * @example
     * // Update many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoadmapProgresses and only return the `id`
     * const roadmapProgressWithIdOnly = await prisma.roadmapProgress.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapProgressUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapProgressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoadmapProgress.
     * @param {RoadmapProgressUpsertArgs} args - Arguments to update or create a RoadmapProgress.
     * @example
     * // Update or create a RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.upsert({
     *   create: {
     *     // ... data to create a RoadmapProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapProgress we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapProgressUpsertArgs>(args: SelectSubset<T, RoadmapProgressUpsertArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoadmapProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressCountArgs} args - Arguments to filter RoadmapProgresses to count.
     * @example
     * // Count the number of RoadmapProgresses
     * const count = await prisma.roadmapProgress.count({
     *   where: {
     *     // ... the filter for the RoadmapProgresses we want to count
     *   }
     * })
    **/
    count<T extends RoadmapProgressCountArgs>(
      args?: Subset<T, RoadmapProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapProgressAggregateArgs>(args: Subset<T, RoadmapProgressAggregateArgs>): Prisma.PrismaPromise<GetRoadmapProgressAggregateType<T>>

    /**
     * Group by RoadmapProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapProgressGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapProgress model
   */
  readonly fields: RoadmapProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapProgress model
   */
  interface RoadmapProgressFieldRefs {
    readonly id: FieldRef<"RoadmapProgress", 'String'>
    readonly userId: FieldRef<"RoadmapProgress", 'String'>
    readonly roadmapId: FieldRef<"RoadmapProgress", 'String'>
    readonly progress: FieldRef<"RoadmapProgress", 'Int'>
    readonly completedAt: FieldRef<"RoadmapProgress", 'DateTime'>
    readonly createdAt: FieldRef<"RoadmapProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapProgress findUnique
   */
  export type RoadmapProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress findUniqueOrThrow
   */
  export type RoadmapProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress findFirst
   */
  export type RoadmapProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapProgresses.
     */
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress findFirstOrThrow
   */
  export type RoadmapProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapProgresses.
     */
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress findMany
   */
  export type RoadmapProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgresses to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress create
   */
  export type RoadmapProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapProgress.
     */
    data: XOR<RoadmapProgressCreateInput, RoadmapProgressUncheckedCreateInput>
  }

  /**
   * RoadmapProgress createMany
   */
  export type RoadmapProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapProgresses.
     */
    data: RoadmapProgressCreateManyInput | RoadmapProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapProgress createManyAndReturn
   */
  export type RoadmapProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * The data used to create many RoadmapProgresses.
     */
    data: RoadmapProgressCreateManyInput | RoadmapProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapProgress update
   */
  export type RoadmapProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapProgress.
     */
    data: XOR<RoadmapProgressUpdateInput, RoadmapProgressUncheckedUpdateInput>
    /**
     * Choose, which RoadmapProgress to update.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress updateMany
   */
  export type RoadmapProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapProgresses.
     */
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapProgresses to update
     */
    where?: RoadmapProgressWhereInput
    /**
     * Limit how many RoadmapProgresses to update.
     */
    limit?: number
  }

  /**
   * RoadmapProgress updateManyAndReturn
   */
  export type RoadmapProgressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * The data used to update RoadmapProgresses.
     */
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapProgresses to update
     */
    where?: RoadmapProgressWhereInput
    /**
     * Limit how many RoadmapProgresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapProgress upsert
   */
  export type RoadmapProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapProgress to update in case it exists.
     */
    where: RoadmapProgressWhereUniqueInput
    /**
     * In case the RoadmapProgress found by the `where` argument doesn't exist, create a new RoadmapProgress with this data.
     */
    create: XOR<RoadmapProgressCreateInput, RoadmapProgressUncheckedCreateInput>
    /**
     * In case the RoadmapProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapProgressUpdateInput, RoadmapProgressUncheckedUpdateInput>
  }

  /**
   * RoadmapProgress delete
   */
  export type RoadmapProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter which RoadmapProgress to delete.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress deleteMany
   */
  export type RoadmapProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapProgresses to delete
     */
    where?: RoadmapProgressWhereInput
    /**
     * Limit how many RoadmapProgresses to delete.
     */
    limit?: number
  }

  /**
   * RoadmapProgress without action
   */
  export type RoadmapProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapProgress
     */
    omit?: RoadmapProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapStep
   */

  export type AggregateRoadmapStep = {
    _count: RoadmapStepCountAggregateOutputType | null
    _avg: RoadmapStepAvgAggregateOutputType | null
    _sum: RoadmapStepSumAggregateOutputType | null
    _min: RoadmapStepMinAggregateOutputType | null
    _max: RoadmapStepMaxAggregateOutputType | null
  }

  export type RoadmapStepAvgAggregateOutputType = {
    order: number | null
    progress: number | null
  }

  export type RoadmapStepSumAggregateOutputType = {
    order: number | null
    progress: number | null
  }

  export type RoadmapStepMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    status: $Enums.StepStatus | null
    progress: number | null
    completedAt: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    roadmapId: string | null
  }

  export type RoadmapStepMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    order: number | null
    status: $Enums.StepStatus | null
    progress: number | null
    completedAt: Date | null
    completed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    parentId: string | null
    roadmapId: string | null
  }

  export type RoadmapStepCountAggregateOutputType = {
    id: number
    title: number
    description: number
    order: number
    status: number
    progress: number
    completedAt: number
    completed: number
    createdAt: number
    updatedAt: number
    parentId: number
    roadmapId: number
    _all: number
  }


  export type RoadmapStepAvgAggregateInputType = {
    order?: true
    progress?: true
  }

  export type RoadmapStepSumAggregateInputType = {
    order?: true
    progress?: true
  }

  export type RoadmapStepMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    status?: true
    progress?: true
    completedAt?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    roadmapId?: true
  }

  export type RoadmapStepMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    status?: true
    progress?: true
    completedAt?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    roadmapId?: true
  }

  export type RoadmapStepCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    order?: true
    status?: true
    progress?: true
    completedAt?: true
    completed?: true
    createdAt?: true
    updatedAt?: true
    parentId?: true
    roadmapId?: true
    _all?: true
  }

  export type RoadmapStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapStep to aggregate.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapSteps
    **/
    _count?: true | RoadmapStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapStepMaxAggregateInputType
  }

  export type GetRoadmapStepAggregateType<T extends RoadmapStepAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapStep[P]>
      : GetScalarType<T[P], AggregateRoadmapStep[P]>
  }




  export type RoadmapStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapStepWhereInput
    orderBy?: RoadmapStepOrderByWithAggregationInput | RoadmapStepOrderByWithAggregationInput[]
    by: RoadmapStepScalarFieldEnum[] | RoadmapStepScalarFieldEnum
    having?: RoadmapStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapStepCountAggregateInputType | true
    _avg?: RoadmapStepAvgAggregateInputType
    _sum?: RoadmapStepSumAggregateInputType
    _min?: RoadmapStepMinAggregateInputType
    _max?: RoadmapStepMaxAggregateInputType
  }

  export type RoadmapStepGroupByOutputType = {
    id: string
    title: string
    description: string | null
    order: number
    status: $Enums.StepStatus
    progress: number
    completedAt: Date | null
    completed: boolean
    createdAt: Date
    updatedAt: Date
    parentId: string | null
    roadmapId: string | null
    _count: RoadmapStepCountAggregateOutputType | null
    _avg: RoadmapStepAvgAggregateOutputType | null
    _sum: RoadmapStepSumAggregateOutputType | null
    _min: RoadmapStepMinAggregateOutputType | null
    _max: RoadmapStepMaxAggregateOutputType | null
  }

  type GetRoadmapStepGroupByPayload<T extends RoadmapStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapStepGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapStepGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    status?: boolean
    progress?: boolean
    completedAt?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    roadmapId?: boolean
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    children?: boolean | RoadmapStep$childrenArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
    tutorials?: boolean | RoadmapStep$tutorialsArgs<ExtArgs>
    quizzes?: boolean | RoadmapStep$quizzesArgs<ExtArgs>
    lastActivities?: boolean | RoadmapStep$lastActivitiesArgs<ExtArgs>
    _count?: boolean | RoadmapStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapStep"]>

  export type RoadmapStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    status?: boolean
    progress?: boolean
    completedAt?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    roadmapId?: boolean
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapStep"]>

  export type RoadmapStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    status?: boolean
    progress?: boolean
    completedAt?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    roadmapId?: boolean
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapStep"]>

  export type RoadmapStepSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    status?: boolean
    progress?: boolean
    completedAt?: boolean
    completed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentId?: boolean
    roadmapId?: boolean
  }

  export type RoadmapStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "order" | "status" | "progress" | "completedAt" | "completed" | "createdAt" | "updatedAt" | "parentId" | "roadmapId", ExtArgs["result"]["roadmapStep"]>
  export type RoadmapStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    children?: boolean | RoadmapStep$childrenArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
    tutorials?: boolean | RoadmapStep$tutorialsArgs<ExtArgs>
    quizzes?: boolean | RoadmapStep$quizzesArgs<ExtArgs>
    lastActivities?: boolean | RoadmapStep$lastActivitiesArgs<ExtArgs>
    _count?: boolean | RoadmapStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
  }
  export type RoadmapStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | RoadmapStep$parentArgs<ExtArgs>
    roadmap?: boolean | RoadmapStep$roadmapArgs<ExtArgs>
  }

  export type $RoadmapStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapStep"
    objects: {
      parent: Prisma.$RoadmapStepPayload<ExtArgs> | null
      children: Prisma.$RoadmapStepPayload<ExtArgs>[]
      roadmap: Prisma.$RoadmapPayload<ExtArgs> | null
      tutorials: Prisma.$TutorialPayload<ExtArgs>[]
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      order: number
      status: $Enums.StepStatus
      progress: number
      completedAt: Date | null
      completed: boolean
      createdAt: Date
      updatedAt: Date
      parentId: string | null
      roadmapId: string | null
    }, ExtArgs["result"]["roadmapStep"]>
    composites: {}
  }

  type RoadmapStepGetPayload<S extends boolean | null | undefined | RoadmapStepDefaultArgs> = $Result.GetResult<Prisma.$RoadmapStepPayload, S>

  type RoadmapStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoadmapStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoadmapStepCountAggregateInputType | true
    }

  export interface RoadmapStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapStep'], meta: { name: 'RoadmapStep' } }
    /**
     * Find zero or one RoadmapStep that matches the filter.
     * @param {RoadmapStepFindUniqueArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapStepFindUniqueArgs>(args: SelectSubset<T, RoadmapStepFindUniqueArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoadmapStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoadmapStepFindUniqueOrThrowArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapStepFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindFirstArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapStepFindFirstArgs>(args?: SelectSubset<T, RoadmapStepFindFirstArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoadmapStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindFirstOrThrowArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapStepFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoadmapSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapSteps
     * const roadmapSteps = await prisma.roadmapStep.findMany()
     * 
     * // Get first 10 RoadmapSteps
     * const roadmapSteps = await prisma.roadmapStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapStepWithIdOnly = await prisma.roadmapStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapStepFindManyArgs>(args?: SelectSubset<T, RoadmapStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoadmapStep.
     * @param {RoadmapStepCreateArgs} args - Arguments to create a RoadmapStep.
     * @example
     * // Create one RoadmapStep
     * const RoadmapStep = await prisma.roadmapStep.create({
     *   data: {
     *     // ... data to create a RoadmapStep
     *   }
     * })
     * 
     */
    create<T extends RoadmapStepCreateArgs>(args: SelectSubset<T, RoadmapStepCreateArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoadmapSteps.
     * @param {RoadmapStepCreateManyArgs} args - Arguments to create many RoadmapSteps.
     * @example
     * // Create many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapStepCreateManyArgs>(args?: SelectSubset<T, RoadmapStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapSteps and returns the data saved in the database.
     * @param {RoadmapStepCreateManyAndReturnArgs} args - Arguments to create many RoadmapSteps.
     * @example
     * // Create many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapSteps and only return the `id`
     * const roadmapStepWithIdOnly = await prisma.roadmapStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapStepCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoadmapStep.
     * @param {RoadmapStepDeleteArgs} args - Arguments to delete one RoadmapStep.
     * @example
     * // Delete one RoadmapStep
     * const RoadmapStep = await prisma.roadmapStep.delete({
     *   where: {
     *     // ... filter to delete one RoadmapStep
     *   }
     * })
     * 
     */
    delete<T extends RoadmapStepDeleteArgs>(args: SelectSubset<T, RoadmapStepDeleteArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoadmapStep.
     * @param {RoadmapStepUpdateArgs} args - Arguments to update one RoadmapStep.
     * @example
     * // Update one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapStepUpdateArgs>(args: SelectSubset<T, RoadmapStepUpdateArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoadmapSteps.
     * @param {RoadmapStepDeleteManyArgs} args - Arguments to filter RoadmapSteps to delete.
     * @example
     * // Delete a few RoadmapSteps
     * const { count } = await prisma.roadmapStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapStepDeleteManyArgs>(args?: SelectSubset<T, RoadmapStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapStepUpdateManyArgs>(args: SelectSubset<T, RoadmapStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapSteps and returns the data updated in the database.
     * @param {RoadmapStepUpdateManyAndReturnArgs} args - Arguments to update many RoadmapSteps.
     * @example
     * // Update many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoadmapSteps and only return the `id`
     * const roadmapStepWithIdOnly = await prisma.roadmapStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoadmapStepUpdateManyAndReturnArgs>(args: SelectSubset<T, RoadmapStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoadmapStep.
     * @param {RoadmapStepUpsertArgs} args - Arguments to update or create a RoadmapStep.
     * @example
     * // Update or create a RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.upsert({
     *   create: {
     *     // ... data to create a RoadmapStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapStep we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapStepUpsertArgs>(args: SelectSubset<T, RoadmapStepUpsertArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoadmapSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepCountArgs} args - Arguments to filter RoadmapSteps to count.
     * @example
     * // Count the number of RoadmapSteps
     * const count = await prisma.roadmapStep.count({
     *   where: {
     *     // ... the filter for the RoadmapSteps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapStepCountArgs>(
      args?: Subset<T, RoadmapStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapStepAggregateArgs>(args: Subset<T, RoadmapStepAggregateArgs>): Prisma.PrismaPromise<GetRoadmapStepAggregateType<T>>

    /**
     * Group by RoadmapStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapStepGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapStep model
   */
  readonly fields: RoadmapStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends RoadmapStep$parentArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$parentArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends RoadmapStep$childrenArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roadmap<T extends RoadmapStep$roadmapArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$roadmapArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutorials<T extends RoadmapStep$tutorialsArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$tutorialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizzes<T extends RoadmapStep$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastActivities<T extends RoadmapStep$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapStep model
   */
  interface RoadmapStepFieldRefs {
    readonly id: FieldRef<"RoadmapStep", 'String'>
    readonly title: FieldRef<"RoadmapStep", 'String'>
    readonly description: FieldRef<"RoadmapStep", 'String'>
    readonly order: FieldRef<"RoadmapStep", 'Int'>
    readonly status: FieldRef<"RoadmapStep", 'StepStatus'>
    readonly progress: FieldRef<"RoadmapStep", 'Int'>
    readonly completedAt: FieldRef<"RoadmapStep", 'DateTime'>
    readonly completed: FieldRef<"RoadmapStep", 'Boolean'>
    readonly createdAt: FieldRef<"RoadmapStep", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapStep", 'DateTime'>
    readonly parentId: FieldRef<"RoadmapStep", 'String'>
    readonly roadmapId: FieldRef<"RoadmapStep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapStep findUnique
   */
  export type RoadmapStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep findUniqueOrThrow
   */
  export type RoadmapStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep findFirst
   */
  export type RoadmapStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapSteps.
     */
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep findFirstOrThrow
   */
  export type RoadmapStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapSteps.
     */
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep findMany
   */
  export type RoadmapStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapSteps to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep create
   */
  export type RoadmapStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapStep.
     */
    data: XOR<RoadmapStepCreateInput, RoadmapStepUncheckedCreateInput>
  }

  /**
   * RoadmapStep createMany
   */
  export type RoadmapStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapSteps.
     */
    data: RoadmapStepCreateManyInput | RoadmapStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapStep createManyAndReturn
   */
  export type RoadmapStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * The data used to create many RoadmapSteps.
     */
    data: RoadmapStepCreateManyInput | RoadmapStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapStep update
   */
  export type RoadmapStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapStep.
     */
    data: XOR<RoadmapStepUpdateInput, RoadmapStepUncheckedUpdateInput>
    /**
     * Choose, which RoadmapStep to update.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep updateMany
   */
  export type RoadmapStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapSteps.
     */
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapSteps to update
     */
    where?: RoadmapStepWhereInput
    /**
     * Limit how many RoadmapSteps to update.
     */
    limit?: number
  }

  /**
   * RoadmapStep updateManyAndReturn
   */
  export type RoadmapStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * The data used to update RoadmapSteps.
     */
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapSteps to update
     */
    where?: RoadmapStepWhereInput
    /**
     * Limit how many RoadmapSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapStep upsert
   */
  export type RoadmapStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapStep to update in case it exists.
     */
    where: RoadmapStepWhereUniqueInput
    /**
     * In case the RoadmapStep found by the `where` argument doesn't exist, create a new RoadmapStep with this data.
     */
    create: XOR<RoadmapStepCreateInput, RoadmapStepUncheckedCreateInput>
    /**
     * In case the RoadmapStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapStepUpdateInput, RoadmapStepUncheckedUpdateInput>
  }

  /**
   * RoadmapStep delete
   */
  export type RoadmapStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter which RoadmapStep to delete.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep deleteMany
   */
  export type RoadmapStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapSteps to delete
     */
    where?: RoadmapStepWhereInput
    /**
     * Limit how many RoadmapSteps to delete.
     */
    limit?: number
  }

  /**
   * RoadmapStep.parent
   */
  export type RoadmapStep$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
  }

  /**
   * RoadmapStep.children
   */
  export type RoadmapStep$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    cursor?: RoadmapStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep.roadmap
   */
  export type RoadmapStep$roadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roadmap
     */
    omit?: RoadmapOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
  }

  /**
   * RoadmapStep.tutorials
   */
  export type RoadmapStep$tutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    cursor?: TutorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * RoadmapStep.quizzes
   */
  export type RoadmapStep$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * RoadmapStep.lastActivities
   */
  export type RoadmapStep$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * RoadmapStep without action
   */
  export type RoadmapStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
  }


  /**
   * Model Tutorial
   */

  export type AggregateTutorial = {
    _count: TutorialCountAggregateOutputType | null
    _avg: TutorialAvgAggregateOutputType | null
    _sum: TutorialSumAggregateOutputType | null
    _min: TutorialMinAggregateOutputType | null
    _max: TutorialMaxAggregateOutputType | null
  }

  export type TutorialAvgAggregateOutputType = {
    likes: number | null
    views: number | null
    cost: number | null
  }

  export type TutorialSumAggregateOutputType = {
    likes: number | null
    views: number | null
    cost: number | null
  }

  export type TutorialMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    category: string | null
    authorId: string | null
    likes: number | null
    views: number | null
    isLocked: boolean | null
    cost: number | null
    hasChallenge: boolean | null
    difficulty: $Enums.DifficultyLevel | null
    status: $Enums.TutorialStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    stepsId: string | null
    tutorialId: string | null
    nextTutorialId: string | null
  }

  export type TutorialMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    content: string | null
    category: string | null
    authorId: string | null
    likes: number | null
    views: number | null
    isLocked: boolean | null
    cost: number | null
    hasChallenge: boolean | null
    difficulty: $Enums.DifficultyLevel | null
    status: $Enums.TutorialStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    stepsId: string | null
    tutorialId: string | null
    nextTutorialId: string | null
  }

  export type TutorialCountAggregateOutputType = {
    id: number
    title: number
    description: number
    content: number
    category: number
    authorId: number
    likes: number
    views: number
    isLocked: number
    cost: number
    hasChallenge: number
    difficulty: number
    status: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    stepsId: number
    tutorialId: number
    nextTutorialId: number
    _all: number
  }


  export type TutorialAvgAggregateInputType = {
    likes?: true
    views?: true
    cost?: true
  }

  export type TutorialSumAggregateInputType = {
    likes?: true
    views?: true
    cost?: true
  }

  export type TutorialMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    authorId?: true
    likes?: true
    views?: true
    isLocked?: true
    cost?: true
    hasChallenge?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    stepsId?: true
    tutorialId?: true
    nextTutorialId?: true
  }

  export type TutorialMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    authorId?: true
    likes?: true
    views?: true
    isLocked?: true
    cost?: true
    hasChallenge?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    stepsId?: true
    tutorialId?: true
    nextTutorialId?: true
  }

  export type TutorialCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    content?: true
    category?: true
    authorId?: true
    likes?: true
    views?: true
    isLocked?: true
    cost?: true
    hasChallenge?: true
    difficulty?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    stepsId?: true
    tutorialId?: true
    nextTutorialId?: true
    _all?: true
  }

  export type TutorialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutorial to aggregate.
     */
    where?: TutorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutorials to fetch.
     */
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tutorials
    **/
    _count?: true | TutorialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutorialAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutorialSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutorialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutorialMaxAggregateInputType
  }

  export type GetTutorialAggregateType<T extends TutorialAggregateArgs> = {
        [P in keyof T & keyof AggregateTutorial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutorial[P]>
      : GetScalarType<T[P], AggregateTutorial[P]>
  }




  export type TutorialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutorialWhereInput
    orderBy?: TutorialOrderByWithAggregationInput | TutorialOrderByWithAggregationInput[]
    by: TutorialScalarFieldEnum[] | TutorialScalarFieldEnum
    having?: TutorialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutorialCountAggregateInputType | true
    _avg?: TutorialAvgAggregateInputType
    _sum?: TutorialSumAggregateInputType
    _min?: TutorialMinAggregateInputType
    _max?: TutorialMaxAggregateInputType
  }

  export type TutorialGroupByOutputType = {
    id: string
    title: string
    description: string | null
    content: string
    category: string | null
    authorId: string | null
    likes: number
    views: number
    isLocked: boolean
    cost: number
    hasChallenge: boolean
    difficulty: $Enums.DifficultyLevel
    status: $Enums.TutorialStatus
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    stepsId: string | null
    tutorialId: string | null
    nextTutorialId: string | null
    _count: TutorialCountAggregateOutputType | null
    _avg: TutorialAvgAggregateOutputType | null
    _sum: TutorialSumAggregateOutputType | null
    _min: TutorialMinAggregateOutputType | null
    _max: TutorialMaxAggregateOutputType | null
  }

  type GetTutorialGroupByPayload<T extends TutorialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutorialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutorialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutorialGroupByOutputType[P]>
            : GetScalarType<T[P], TutorialGroupByOutputType[P]>
        }
      >
    >


  export type TutorialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    likes?: boolean
    views?: boolean
    isLocked?: boolean
    cost?: boolean
    hasChallenge?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    stepsId?: boolean
    tutorialId?: boolean
    nextTutorialId?: boolean
    quizzes?: boolean | Tutorial$quizzesArgs<ExtArgs>
    progress?: boolean | Tutorial$progressArgs<ExtArgs>
    tutorialTags?: boolean | Tutorial$tutorialTagsArgs<ExtArgs>
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
    previousTutorials?: boolean | Tutorial$previousTutorialsArgs<ExtArgs>
    relatedTutorials?: boolean | Tutorial$relatedTutorialsArgs<ExtArgs>
    lastActivities?: boolean | Tutorial$lastActivitiesArgs<ExtArgs>
    _count?: boolean | TutorialCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutorial"]>

  export type TutorialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    likes?: boolean
    views?: boolean
    isLocked?: boolean
    cost?: boolean
    hasChallenge?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    stepsId?: boolean
    tutorialId?: boolean
    nextTutorialId?: boolean
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
  }, ExtArgs["result"]["tutorial"]>

  export type TutorialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    likes?: boolean
    views?: boolean
    isLocked?: boolean
    cost?: boolean
    hasChallenge?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    stepsId?: boolean
    tutorialId?: boolean
    nextTutorialId?: boolean
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
  }, ExtArgs["result"]["tutorial"]>

  export type TutorialSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    likes?: boolean
    views?: boolean
    isLocked?: boolean
    cost?: boolean
    hasChallenge?: boolean
    difficulty?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    stepsId?: boolean
    tutorialId?: boolean
    nextTutorialId?: boolean
  }

  export type TutorialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "content" | "category" | "authorId" | "likes" | "views" | "isLocked" | "cost" | "hasChallenge" | "difficulty" | "status" | "createdAt" | "updatedAt" | "deletedAt" | "stepsId" | "tutorialId" | "nextTutorialId", ExtArgs["result"]["tutorial"]>
  export type TutorialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | Tutorial$quizzesArgs<ExtArgs>
    progress?: boolean | Tutorial$progressArgs<ExtArgs>
    tutorialTags?: boolean | Tutorial$tutorialTagsArgs<ExtArgs>
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
    previousTutorials?: boolean | Tutorial$previousTutorialsArgs<ExtArgs>
    relatedTutorials?: boolean | Tutorial$relatedTutorialsArgs<ExtArgs>
    lastActivities?: boolean | Tutorial$lastActivitiesArgs<ExtArgs>
    _count?: boolean | TutorialCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutorialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
  }
  export type TutorialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | Tutorial$stepsArgs<ExtArgs>
    tutorial?: boolean | Tutorial$tutorialArgs<ExtArgs>
    nextTutorial?: boolean | Tutorial$nextTutorialArgs<ExtArgs>
  }

  export type $TutorialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tutorial"
    objects: {
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      tutorialTags: Prisma.$TagPayload<ExtArgs>[]
      steps: Prisma.$RoadmapStepPayload<ExtArgs> | null
      tutorial: Prisma.$TutorialPayload<ExtArgs> | null
      nextTutorial: Prisma.$TutorialPayload<ExtArgs> | null
      previousTutorials: Prisma.$TutorialPayload<ExtArgs>[]
      relatedTutorials: Prisma.$TutorialPayload<ExtArgs>[]
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      content: string
      category: string | null
      authorId: string | null
      likes: number
      views: number
      isLocked: boolean
      cost: number
      hasChallenge: boolean
      difficulty: $Enums.DifficultyLevel
      status: $Enums.TutorialStatus
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      stepsId: string | null
      tutorialId: string | null
      nextTutorialId: string | null
    }, ExtArgs["result"]["tutorial"]>
    composites: {}
  }

  type TutorialGetPayload<S extends boolean | null | undefined | TutorialDefaultArgs> = $Result.GetResult<Prisma.$TutorialPayload, S>

  type TutorialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TutorialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutorialCountAggregateInputType | true
    }

  export interface TutorialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tutorial'], meta: { name: 'Tutorial' } }
    /**
     * Find zero or one Tutorial that matches the filter.
     * @param {TutorialFindUniqueArgs} args - Arguments to find a Tutorial
     * @example
     * // Get one Tutorial
     * const tutorial = await prisma.tutorial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutorialFindUniqueArgs>(args: SelectSubset<T, TutorialFindUniqueArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutorial that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TutorialFindUniqueOrThrowArgs} args - Arguments to find a Tutorial
     * @example
     * // Get one Tutorial
     * const tutorial = await prisma.tutorial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutorialFindUniqueOrThrowArgs>(args: SelectSubset<T, TutorialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutorial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialFindFirstArgs} args - Arguments to find a Tutorial
     * @example
     * // Get one Tutorial
     * const tutorial = await prisma.tutorial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutorialFindFirstArgs>(args?: SelectSubset<T, TutorialFindFirstArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutorial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialFindFirstOrThrowArgs} args - Arguments to find a Tutorial
     * @example
     * // Get one Tutorial
     * const tutorial = await prisma.tutorial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutorialFindFirstOrThrowArgs>(args?: SelectSubset<T, TutorialFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutorials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutorials
     * const tutorials = await prisma.tutorial.findMany()
     * 
     * // Get first 10 Tutorials
     * const tutorials = await prisma.tutorial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutorialWithIdOnly = await prisma.tutorial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutorialFindManyArgs>(args?: SelectSubset<T, TutorialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutorial.
     * @param {TutorialCreateArgs} args - Arguments to create a Tutorial.
     * @example
     * // Create one Tutorial
     * const Tutorial = await prisma.tutorial.create({
     *   data: {
     *     // ... data to create a Tutorial
     *   }
     * })
     * 
     */
    create<T extends TutorialCreateArgs>(args: SelectSubset<T, TutorialCreateArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutorials.
     * @param {TutorialCreateManyArgs} args - Arguments to create many Tutorials.
     * @example
     * // Create many Tutorials
     * const tutorial = await prisma.tutorial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutorialCreateManyArgs>(args?: SelectSubset<T, TutorialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tutorials and returns the data saved in the database.
     * @param {TutorialCreateManyAndReturnArgs} args - Arguments to create many Tutorials.
     * @example
     * // Create many Tutorials
     * const tutorial = await prisma.tutorial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tutorials and only return the `id`
     * const tutorialWithIdOnly = await prisma.tutorial.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutorialCreateManyAndReturnArgs>(args?: SelectSubset<T, TutorialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tutorial.
     * @param {TutorialDeleteArgs} args - Arguments to delete one Tutorial.
     * @example
     * // Delete one Tutorial
     * const Tutorial = await prisma.tutorial.delete({
     *   where: {
     *     // ... filter to delete one Tutorial
     *   }
     * })
     * 
     */
    delete<T extends TutorialDeleteArgs>(args: SelectSubset<T, TutorialDeleteArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutorial.
     * @param {TutorialUpdateArgs} args - Arguments to update one Tutorial.
     * @example
     * // Update one Tutorial
     * const tutorial = await prisma.tutorial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutorialUpdateArgs>(args: SelectSubset<T, TutorialUpdateArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutorials.
     * @param {TutorialDeleteManyArgs} args - Arguments to filter Tutorials to delete.
     * @example
     * // Delete a few Tutorials
     * const { count } = await prisma.tutorial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutorialDeleteManyArgs>(args?: SelectSubset<T, TutorialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutorials
     * const tutorial = await prisma.tutorial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutorialUpdateManyArgs>(args: SelectSubset<T, TutorialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutorials and returns the data updated in the database.
     * @param {TutorialUpdateManyAndReturnArgs} args - Arguments to update many Tutorials.
     * @example
     * // Update many Tutorials
     * const tutorial = await prisma.tutorial.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tutorials and only return the `id`
     * const tutorialWithIdOnly = await prisma.tutorial.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TutorialUpdateManyAndReturnArgs>(args: SelectSubset<T, TutorialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tutorial.
     * @param {TutorialUpsertArgs} args - Arguments to update or create a Tutorial.
     * @example
     * // Update or create a Tutorial
     * const tutorial = await prisma.tutorial.upsert({
     *   create: {
     *     // ... data to create a Tutorial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutorial we want to update
     *   }
     * })
     */
    upsert<T extends TutorialUpsertArgs>(args: SelectSubset<T, TutorialUpsertArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialCountArgs} args - Arguments to filter Tutorials to count.
     * @example
     * // Count the number of Tutorials
     * const count = await prisma.tutorial.count({
     *   where: {
     *     // ... the filter for the Tutorials we want to count
     *   }
     * })
    **/
    count<T extends TutorialCountArgs>(
      args?: Subset<T, TutorialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutorialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutorialAggregateArgs>(args: Subset<T, TutorialAggregateArgs>): Prisma.PrismaPromise<GetTutorialAggregateType<T>>

    /**
     * Group by Tutorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutorialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutorialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutorialGroupByArgs['orderBy'] }
        : { orderBy?: TutorialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutorialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutorialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tutorial model
   */
  readonly fields: TutorialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tutorial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutorialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizzes<T extends Tutorial$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    progress<T extends Tutorial$progressArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutorialTags<T extends Tutorial$tutorialTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$tutorialTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    steps<T extends Tutorial$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$stepsArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tutorial<T extends Tutorial$tutorialArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$tutorialArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nextTutorial<T extends Tutorial$nextTutorialArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$nextTutorialArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    previousTutorials<T extends Tutorial$previousTutorialsArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$previousTutorialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedTutorials<T extends Tutorial$relatedTutorialsArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$relatedTutorialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lastActivities<T extends Tutorial$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Tutorial$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tutorial model
   */
  interface TutorialFieldRefs {
    readonly id: FieldRef<"Tutorial", 'String'>
    readonly title: FieldRef<"Tutorial", 'String'>
    readonly description: FieldRef<"Tutorial", 'String'>
    readonly content: FieldRef<"Tutorial", 'String'>
    readonly category: FieldRef<"Tutorial", 'String'>
    readonly authorId: FieldRef<"Tutorial", 'String'>
    readonly likes: FieldRef<"Tutorial", 'Int'>
    readonly views: FieldRef<"Tutorial", 'Int'>
    readonly isLocked: FieldRef<"Tutorial", 'Boolean'>
    readonly cost: FieldRef<"Tutorial", 'Int'>
    readonly hasChallenge: FieldRef<"Tutorial", 'Boolean'>
    readonly difficulty: FieldRef<"Tutorial", 'DifficultyLevel'>
    readonly status: FieldRef<"Tutorial", 'TutorialStatus'>
    readonly createdAt: FieldRef<"Tutorial", 'DateTime'>
    readonly updatedAt: FieldRef<"Tutorial", 'DateTime'>
    readonly deletedAt: FieldRef<"Tutorial", 'DateTime'>
    readonly stepsId: FieldRef<"Tutorial", 'String'>
    readonly tutorialId: FieldRef<"Tutorial", 'String'>
    readonly nextTutorialId: FieldRef<"Tutorial", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tutorial findUnique
   */
  export type TutorialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter, which Tutorial to fetch.
     */
    where: TutorialWhereUniqueInput
  }

  /**
   * Tutorial findUniqueOrThrow
   */
  export type TutorialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter, which Tutorial to fetch.
     */
    where: TutorialWhereUniqueInput
  }

  /**
   * Tutorial findFirst
   */
  export type TutorialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter, which Tutorial to fetch.
     */
    where?: TutorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutorials to fetch.
     */
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutorials.
     */
    cursor?: TutorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutorials.
     */
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tutorial findFirstOrThrow
   */
  export type TutorialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter, which Tutorial to fetch.
     */
    where?: TutorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutorials to fetch.
     */
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutorials.
     */
    cursor?: TutorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutorials.
     */
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tutorial findMany
   */
  export type TutorialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter, which Tutorials to fetch.
     */
    where?: TutorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutorials to fetch.
     */
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tutorials.
     */
    cursor?: TutorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutorials.
     */
    skip?: number
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tutorial create
   */
  export type TutorialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * The data needed to create a Tutorial.
     */
    data: XOR<TutorialCreateInput, TutorialUncheckedCreateInput>
  }

  /**
   * Tutorial createMany
   */
  export type TutorialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tutorials.
     */
    data: TutorialCreateManyInput | TutorialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tutorial createManyAndReturn
   */
  export type TutorialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * The data used to create many Tutorials.
     */
    data: TutorialCreateManyInput | TutorialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tutorial update
   */
  export type TutorialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * The data needed to update a Tutorial.
     */
    data: XOR<TutorialUpdateInput, TutorialUncheckedUpdateInput>
    /**
     * Choose, which Tutorial to update.
     */
    where: TutorialWhereUniqueInput
  }

  /**
   * Tutorial updateMany
   */
  export type TutorialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tutorials.
     */
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyInput>
    /**
     * Filter which Tutorials to update
     */
    where?: TutorialWhereInput
    /**
     * Limit how many Tutorials to update.
     */
    limit?: number
  }

  /**
   * Tutorial updateManyAndReturn
   */
  export type TutorialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * The data used to update Tutorials.
     */
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyInput>
    /**
     * Filter which Tutorials to update
     */
    where?: TutorialWhereInput
    /**
     * Limit how many Tutorials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tutorial upsert
   */
  export type TutorialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * The filter to search for the Tutorial to update in case it exists.
     */
    where: TutorialWhereUniqueInput
    /**
     * In case the Tutorial found by the `where` argument doesn't exist, create a new Tutorial with this data.
     */
    create: XOR<TutorialCreateInput, TutorialUncheckedCreateInput>
    /**
     * In case the Tutorial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutorialUpdateInput, TutorialUncheckedUpdateInput>
  }

  /**
   * Tutorial delete
   */
  export type TutorialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    /**
     * Filter which Tutorial to delete.
     */
    where: TutorialWhereUniqueInput
  }

  /**
   * Tutorial deleteMany
   */
  export type TutorialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutorials to delete
     */
    where?: TutorialWhereInput
    /**
     * Limit how many Tutorials to delete.
     */
    limit?: number
  }

  /**
   * Tutorial.quizzes
   */
  export type Tutorial$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Tutorial.progress
   */
  export type Tutorial$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProgress
     */
    omit?: UserProgressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * Tutorial.tutorialTags
   */
  export type Tutorial$tutorialTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tutorial.steps
   */
  export type Tutorial$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
  }

  /**
   * Tutorial.tutorial
   */
  export type Tutorial$tutorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
  }

  /**
   * Tutorial.nextTutorial
   */
  export type Tutorial$nextTutorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
  }

  /**
   * Tutorial.previousTutorials
   */
  export type Tutorial$previousTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    cursor?: TutorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tutorial.relatedTutorials
   */
  export type Tutorial$relatedTutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    cursor?: TutorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tutorial.lastActivities
   */
  export type Tutorial$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * Tutorial without action
   */
  export type TutorialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    timeLimit: number | null
    maxScore: number | null
    passPercentage: number | null
    order: number | null
    questionCount: number | null
    estimatedDuration: number | null
  }

  export type QuizSumAggregateOutputType = {
    timeLimit: number | null
    maxScore: number | null
    passPercentage: number | null
    order: number | null
    questionCount: number | null
    estimatedDuration: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    isTimed: boolean | null
    timeLimit: number | null
    maxScore: number | null
    passPercentage: number | null
    difficulty: $Enums.DifficultyLevel | null
    order: number | null
    tutorialLocked: boolean | null
    questionCount: number | null
    estimatedDuration: number | null
    tutorialId: string | null
    stepsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    isTimed: boolean | null
    timeLimit: number | null
    maxScore: number | null
    passPercentage: number | null
    difficulty: $Enums.DifficultyLevel | null
    order: number | null
    tutorialLocked: boolean | null
    questionCount: number | null
    estimatedDuration: number | null
    tutorialId: string | null
    stepsId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    isTimed: number
    timeLimit: number
    maxScore: number
    passPercentage: number
    difficulty: number
    order: number
    tutorialLocked: number
    questionCount: number
    estimatedDuration: number
    tutorialId: number
    stepsId: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    timeLimit?: true
    maxScore?: true
    passPercentage?: true
    order?: true
    questionCount?: true
    estimatedDuration?: true
  }

  export type QuizSumAggregateInputType = {
    timeLimit?: true
    maxScore?: true
    passPercentage?: true
    order?: true
    questionCount?: true
    estimatedDuration?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    isTimed?: true
    timeLimit?: true
    maxScore?: true
    passPercentage?: true
    difficulty?: true
    order?: true
    tutorialLocked?: true
    questionCount?: true
    estimatedDuration?: true
    tutorialId?: true
    stepsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    isTimed?: true
    timeLimit?: true
    maxScore?: true
    passPercentage?: true
    difficulty?: true
    order?: true
    tutorialLocked?: true
    questionCount?: true
    estimatedDuration?: true
    tutorialId?: true
    stepsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    isTimed?: true
    timeLimit?: true
    maxScore?: true
    passPercentage?: true
    difficulty?: true
    order?: true
    tutorialLocked?: true
    questionCount?: true
    estimatedDuration?: true
    tutorialId?: true
    stepsId?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    title: string
    slug: string
    isTimed: boolean
    timeLimit: number | null
    maxScore: number
    passPercentage: number
    difficulty: $Enums.DifficultyLevel
    order: number | null
    tutorialLocked: boolean | null
    questionCount: number | null
    estimatedDuration: number | null
    tutorialId: string
    stepsId: string | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    isTimed?: boolean
    timeLimit?: boolean
    maxScore?: boolean
    passPercentage?: boolean
    difficulty?: boolean
    order?: boolean
    tutorialLocked?: boolean
    questionCount?: boolean
    estimatedDuration?: boolean
    tutorialId?: boolean
    stepsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    tags?: boolean | Quiz$tagsArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
    lastActivities?: boolean | Quiz$lastActivitiesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    isTimed?: boolean
    timeLimit?: boolean
    maxScore?: boolean
    passPercentage?: boolean
    difficulty?: boolean
    order?: boolean
    tutorialLocked?: boolean
    questionCount?: boolean
    estimatedDuration?: boolean
    tutorialId?: boolean
    stepsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    isTimed?: boolean
    timeLimit?: boolean
    maxScore?: boolean
    passPercentage?: boolean
    difficulty?: boolean
    order?: boolean
    tutorialLocked?: boolean
    questionCount?: boolean
    estimatedDuration?: boolean
    tutorialId?: boolean
    stepsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    isTimed?: boolean
    timeLimit?: boolean
    maxScore?: boolean
    passPercentage?: boolean
    difficulty?: boolean
    order?: boolean
    tutorialLocked?: boolean
    questionCount?: boolean
    estimatedDuration?: boolean
    tutorialId?: boolean
    stepsId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "slug" | "isTimed" | "timeLimit" | "maxScore" | "passPercentage" | "difficulty" | "order" | "tutorialLocked" | "questionCount" | "estimatedDuration" | "tutorialId" | "stepsId" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    tags?: boolean | Quiz$tagsArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
    lastActivities?: boolean | Quiz$lastActivitiesArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
  }
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutorial?: boolean | TutorialDefaultArgs<ExtArgs>
    steps?: boolean | Quiz$stepsArgs<ExtArgs>
  }

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      attempts: Prisma.$UserQuizAttemptPayload<ExtArgs>[]
      tutorial: Prisma.$TutorialPayload<ExtArgs>
      tags: Prisma.$TagPayload<ExtArgs>[]
      steps: Prisma.$RoadmapStepPayload<ExtArgs> | null
      lastActivities: Prisma.$LastActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      isTimed: boolean
      timeLimit: number | null
      maxScore: number
      passPercentage: number
      difficulty: $Enums.DifficultyLevel
      order: number | null
      tutorialLocked: boolean | null
      questionCount: number | null
      estimatedDuration: number | null
      tutorialId: string
      stepsId: string | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserQuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutorial<T extends TutorialDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TutorialDefaultArgs<ExtArgs>>): Prisma__TutorialClient<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends Quiz$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    steps<T extends Quiz$stepsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$stepsArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lastActivities<T extends Quiz$lastActivitiesArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$lastActivitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LastActivityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly title: FieldRef<"Quiz", 'String'>
    readonly slug: FieldRef<"Quiz", 'String'>
    readonly isTimed: FieldRef<"Quiz", 'Boolean'>
    readonly timeLimit: FieldRef<"Quiz", 'Int'>
    readonly maxScore: FieldRef<"Quiz", 'Int'>
    readonly passPercentage: FieldRef<"Quiz", 'Int'>
    readonly difficulty: FieldRef<"Quiz", 'DifficultyLevel'>
    readonly order: FieldRef<"Quiz", 'Int'>
    readonly tutorialLocked: FieldRef<"Quiz", 'Boolean'>
    readonly questionCount: FieldRef<"Quiz", 'Int'>
    readonly estimatedDuration: FieldRef<"Quiz", 'Int'>
    readonly tutorialId: FieldRef<"Quiz", 'String'>
    readonly stepsId: FieldRef<"Quiz", 'String'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
    readonly deletedAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserQuizAttempt
     */
    select?: UserQuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserQuizAttempt
     */
    omit?: UserQuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserQuizAttemptInclude<ExtArgs> | null
    where?: UserQuizAttemptWhereInput
    orderBy?: UserQuizAttemptOrderByWithRelationInput | UserQuizAttemptOrderByWithRelationInput[]
    cursor?: UserQuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserQuizAttemptScalarFieldEnum | UserQuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz.tags
   */
  export type Quiz$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    where?: TagWhereInput
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    cursor?: TagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Quiz.steps
   */
  export type Quiz$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoadmapStep
     */
    omit?: RoadmapStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
  }

  /**
   * Quiz.lastActivities
   */
  export type Quiz$lastActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LastActivity
     */
    select?: LastActivitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the LastActivity
     */
    omit?: LastActivityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LastActivityInclude<ExtArgs> | null
    where?: LastActivityWhereInput
    orderBy?: LastActivityOrderByWithRelationInput | LastActivityOrderByWithRelationInput[]
    cursor?: LastActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LastActivityScalarFieldEnum | LastActivityScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    xp: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    xp: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    questionText: string | null
    correctAnswer: string | null
    xp: number | null
    quizId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    questionText: string | null
    correctAnswer: string | null
    xp: number | null
    quizId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    questionText: number
    options: number
    correctAnswer: number
    xp: number
    quizId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    xp?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    xp?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    questionText?: true
    correctAnswer?: true
    xp?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    questionText?: true
    correctAnswer?: true
    xp?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    questionText?: true
    options?: true
    correctAnswer?: true
    xp?: true
    quizId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    questionText: string
    options: string[]
    correctAnswer: string
    xp: number
    quizId: string
    createdAt: Date
    updatedAt: Date
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    xp?: boolean
    quizId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    xp?: boolean
    quizId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    xp?: boolean
    quizId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    questionText?: boolean
    options?: boolean
    correctAnswer?: boolean
    xp?: boolean
    quizId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionText" | "options" | "correctAnswer" | "xp" | "quizId" | "createdAt" | "updatedAt", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionText: string
      options: string[]
      correctAnswer: string
      xp: number
      quizId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly questionText: FieldRef<"QuizQuestion", 'String'>
    readonly options: FieldRef<"QuizQuestion", 'String[]'>
    readonly correctAnswer: FieldRef<"QuizQuestion", 'String'>
    readonly xp: FieldRef<"QuizQuestion", 'Int'>
    readonly quizId: FieldRef<"QuizQuestion", 'String'>
    readonly createdAt: FieldRef<"QuizQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model AdminActivityLog
   */

  export type AggregateAdminActivityLog = {
    _count: AdminActivityLogCountAggregateOutputType | null
    _min: AdminActivityLogMinAggregateOutputType | null
    _max: AdminActivityLogMaxAggregateOutputType | null
  }

  export type AdminActivityLogMinAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    target: string | null
    targetId: string | null
    timestamp: Date | null
  }

  export type AdminActivityLogMaxAggregateOutputType = {
    id: string | null
    adminId: string | null
    action: string | null
    target: string | null
    targetId: string | null
    timestamp: Date | null
  }

  export type AdminActivityLogCountAggregateOutputType = {
    id: number
    adminId: number
    action: number
    target: number
    targetId: number
    timestamp: number
    _all: number
  }


  export type AdminActivityLogMinAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    target?: true
    targetId?: true
    timestamp?: true
  }

  export type AdminActivityLogMaxAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    target?: true
    targetId?: true
    timestamp?: true
  }

  export type AdminActivityLogCountAggregateInputType = {
    id?: true
    adminId?: true
    action?: true
    target?: true
    targetId?: true
    timestamp?: true
    _all?: true
  }

  export type AdminActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActivityLog to aggregate.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminActivityLogs
    **/
    _count?: true | AdminActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminActivityLogMaxAggregateInputType
  }

  export type GetAdminActivityLogAggregateType<T extends AdminActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminActivityLog[P]>
      : GetScalarType<T[P], AggregateAdminActivityLog[P]>
  }




  export type AdminActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminActivityLogWhereInput
    orderBy?: AdminActivityLogOrderByWithAggregationInput | AdminActivityLogOrderByWithAggregationInput[]
    by: AdminActivityLogScalarFieldEnum[] | AdminActivityLogScalarFieldEnum
    having?: AdminActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminActivityLogCountAggregateInputType | true
    _min?: AdminActivityLogMinAggregateInputType
    _max?: AdminActivityLogMaxAggregateInputType
  }

  export type AdminActivityLogGroupByOutputType = {
    id: string
    adminId: string
    action: string
    target: string
    targetId: string
    timestamp: Date
    _count: AdminActivityLogCountAggregateOutputType | null
    _min: AdminActivityLogMinAggregateOutputType | null
    _max: AdminActivityLogMaxAggregateOutputType | null
  }

  type GetAdminActivityLogGroupByPayload<T extends AdminActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    targetId?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    targetId?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    targetId?: boolean
    timestamp?: boolean
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminActivityLog"]>

  export type AdminActivityLogSelectScalar = {
    id?: boolean
    adminId?: boolean
    action?: boolean
    target?: boolean
    targetId?: boolean
    timestamp?: boolean
  }

  export type AdminActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "adminId" | "action" | "target" | "targetId" | "timestamp", ExtArgs["result"]["adminActivityLog"]>
  export type AdminActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    admin?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminActivityLog"
    objects: {
      admin: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      adminId: string
      action: string
      target: string
      targetId: string
      timestamp: Date
    }, ExtArgs["result"]["adminActivityLog"]>
    composites: {}
  }

  type AdminActivityLogGetPayload<S extends boolean | null | undefined | AdminActivityLogDefaultArgs> = $Result.GetResult<Prisma.$AdminActivityLogPayload, S>

  type AdminActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminActivityLogCountAggregateInputType | true
    }

  export interface AdminActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminActivityLog'], meta: { name: 'AdminActivityLog' } }
    /**
     * Find zero or one AdminActivityLog that matches the filter.
     * @param {AdminActivityLogFindUniqueArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminActivityLogFindUniqueArgs>(args: SelectSubset<T, AdminActivityLogFindUniqueArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminActivityLogFindUniqueOrThrowArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindFirstArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminActivityLogFindFirstArgs>(args?: SelectSubset<T, AdminActivityLogFindFirstArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindFirstOrThrowArgs} args - Arguments to find a AdminActivityLog
     * @example
     * // Get one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminActivityLogs
     * const adminActivityLogs = await prisma.adminActivityLog.findMany()
     * 
     * // Get first 10 AdminActivityLogs
     * const adminActivityLogs = await prisma.adminActivityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminActivityLogFindManyArgs>(args?: SelectSubset<T, AdminActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminActivityLog.
     * @param {AdminActivityLogCreateArgs} args - Arguments to create a AdminActivityLog.
     * @example
     * // Create one AdminActivityLog
     * const AdminActivityLog = await prisma.adminActivityLog.create({
     *   data: {
     *     // ... data to create a AdminActivityLog
     *   }
     * })
     * 
     */
    create<T extends AdminActivityLogCreateArgs>(args: SelectSubset<T, AdminActivityLogCreateArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminActivityLogs.
     * @param {AdminActivityLogCreateManyArgs} args - Arguments to create many AdminActivityLogs.
     * @example
     * // Create many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminActivityLogCreateManyArgs>(args?: SelectSubset<T, AdminActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminActivityLogs and returns the data saved in the database.
     * @param {AdminActivityLogCreateManyAndReturnArgs} args - Arguments to create many AdminActivityLogs.
     * @example
     * // Create many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminActivityLogs and only return the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminActivityLog.
     * @param {AdminActivityLogDeleteArgs} args - Arguments to delete one AdminActivityLog.
     * @example
     * // Delete one AdminActivityLog
     * const AdminActivityLog = await prisma.adminActivityLog.delete({
     *   where: {
     *     // ... filter to delete one AdminActivityLog
     *   }
     * })
     * 
     */
    delete<T extends AdminActivityLogDeleteArgs>(args: SelectSubset<T, AdminActivityLogDeleteArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminActivityLog.
     * @param {AdminActivityLogUpdateArgs} args - Arguments to update one AdminActivityLog.
     * @example
     * // Update one AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminActivityLogUpdateArgs>(args: SelectSubset<T, AdminActivityLogUpdateArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminActivityLogs.
     * @param {AdminActivityLogDeleteManyArgs} args - Arguments to filter AdminActivityLogs to delete.
     * @example
     * // Delete a few AdminActivityLogs
     * const { count } = await prisma.adminActivityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminActivityLogDeleteManyArgs>(args?: SelectSubset<T, AdminActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminActivityLogUpdateManyArgs>(args: SelectSubset<T, AdminActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminActivityLogs and returns the data updated in the database.
     * @param {AdminActivityLogUpdateManyAndReturnArgs} args - Arguments to update many AdminActivityLogs.
     * @example
     * // Update many AdminActivityLogs
     * const adminActivityLog = await prisma.adminActivityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminActivityLogs and only return the `id`
     * const adminActivityLogWithIdOnly = await prisma.adminActivityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminActivityLog.
     * @param {AdminActivityLogUpsertArgs} args - Arguments to update or create a AdminActivityLog.
     * @example
     * // Update or create a AdminActivityLog
     * const adminActivityLog = await prisma.adminActivityLog.upsert({
     *   create: {
     *     // ... data to create a AdminActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminActivityLogUpsertArgs>(args: SelectSubset<T, AdminActivityLogUpsertArgs<ExtArgs>>): Prisma__AdminActivityLogClient<$Result.GetResult<Prisma.$AdminActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogCountArgs} args - Arguments to filter AdminActivityLogs to count.
     * @example
     * // Count the number of AdminActivityLogs
     * const count = await prisma.adminActivityLog.count({
     *   where: {
     *     // ... the filter for the AdminActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminActivityLogCountArgs>(
      args?: Subset<T, AdminActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminActivityLogAggregateArgs>(args: Subset<T, AdminActivityLogAggregateArgs>): Prisma.PrismaPromise<GetAdminActivityLogAggregateType<T>>

    /**
     * Group by AdminActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminActivityLog model
   */
  readonly fields: AdminActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    admin<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminActivityLog model
   */
  interface AdminActivityLogFieldRefs {
    readonly id: FieldRef<"AdminActivityLog", 'String'>
    readonly adminId: FieldRef<"AdminActivityLog", 'String'>
    readonly action: FieldRef<"AdminActivityLog", 'String'>
    readonly target: FieldRef<"AdminActivityLog", 'String'>
    readonly targetId: FieldRef<"AdminActivityLog", 'String'>
    readonly timestamp: FieldRef<"AdminActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminActivityLog findUnique
   */
  export type AdminActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog findUniqueOrThrow
   */
  export type AdminActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog findFirst
   */
  export type AdminActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActivityLogs.
     */
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog findFirstOrThrow
   */
  export type AdminActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLog to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminActivityLogs.
     */
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog findMany
   */
  export type AdminActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminActivityLogs to fetch.
     */
    where?: AdminActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminActivityLogs to fetch.
     */
    orderBy?: AdminActivityLogOrderByWithRelationInput | AdminActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminActivityLogs.
     */
    cursor?: AdminActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminActivityLogs.
     */
    skip?: number
    distinct?: AdminActivityLogScalarFieldEnum | AdminActivityLogScalarFieldEnum[]
  }

  /**
   * AdminActivityLog create
   */
  export type AdminActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminActivityLog.
     */
    data: XOR<AdminActivityLogCreateInput, AdminActivityLogUncheckedCreateInput>
  }

  /**
   * AdminActivityLog createMany
   */
  export type AdminActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminActivityLogs.
     */
    data: AdminActivityLogCreateManyInput | AdminActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminActivityLog createManyAndReturn
   */
  export type AdminActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many AdminActivityLogs.
     */
    data: AdminActivityLogCreateManyInput | AdminActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminActivityLog update
   */
  export type AdminActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminActivityLog.
     */
    data: XOR<AdminActivityLogUpdateInput, AdminActivityLogUncheckedUpdateInput>
    /**
     * Choose, which AdminActivityLog to update.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog updateMany
   */
  export type AdminActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminActivityLogs.
     */
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminActivityLogs to update
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to update.
     */
    limit?: number
  }

  /**
   * AdminActivityLog updateManyAndReturn
   */
  export type AdminActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update AdminActivityLogs.
     */
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminActivityLogs to update
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminActivityLog upsert
   */
  export type AdminActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminActivityLog to update in case it exists.
     */
    where: AdminActivityLogWhereUniqueInput
    /**
     * In case the AdminActivityLog found by the `where` argument doesn't exist, create a new AdminActivityLog with this data.
     */
    create: XOR<AdminActivityLogCreateInput, AdminActivityLogUncheckedCreateInput>
    /**
     * In case the AdminActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminActivityLogUpdateInput, AdminActivityLogUncheckedUpdateInput>
  }

  /**
   * AdminActivityLog delete
   */
  export type AdminActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
    /**
     * Filter which AdminActivityLog to delete.
     */
    where: AdminActivityLogWhereUniqueInput
  }

  /**
   * AdminActivityLog deleteMany
   */
  export type AdminActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminActivityLogs to delete
     */
    where?: AdminActivityLogWhereInput
    /**
     * Limit how many AdminActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * AdminActivityLog without action
   */
  export type AdminActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminActivityLog
     */
    select?: AdminActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminActivityLog
     */
    omit?: AdminActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type TagSumAggregateOutputType = {
    usageCount: number | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    usageCount: number | null
    type: $Enums.TagType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    usageCount: number | null
    type: $Enums.TagType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    usageCount: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    usageCount?: true
  }

  export type TagSumAggregateInputType = {
    usageCount?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    usageCount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    usageCount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    usageCount?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    usageCount: number
    type: $Enums.TagType
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    usageCount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    quizzes?: boolean | Tag$quizzesArgs<ExtArgs>
    tutorials?: boolean | Tag$tutorialsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    usageCount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    usageCount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    usageCount?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "usageCount" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quizzes?: boolean | Tag$quizzesArgs<ExtArgs>
    tutorials?: boolean | Tag$tutorialsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      quizzes: Prisma.$QuizPayload<ExtArgs>[]
      tutorials: Prisma.$TutorialPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      usageCount: number
      type: $Enums.TagType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quizzes<T extends Tag$quizzesArgs<ExtArgs> = {}>(args?: Subset<T, Tag$quizzesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tutorials<T extends Tag$tutorialsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$tutorialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutorialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly usageCount: FieldRef<"Tag", 'Int'>
    readonly type: FieldRef<"Tag", 'TagType'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.quizzes
   */
  export type Tag$quizzesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    cursor?: QuizWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Tag.tutorials
   */
  export type Tag$tutorialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutorial
     */
    select?: TutorialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutorial
     */
    omit?: TutorialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutorialInclude<ExtArgs> | null
    where?: TutorialWhereInput
    orderBy?: TutorialOrderByWithRelationInput | TutorialOrderByWithRelationInput[]
    cursor?: TutorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TutorialScalarFieldEnum | TutorialScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    failedAttempts: 'failedAttempts',
    lockedUntil: 'lockedUntil',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    emailVerified: 'emailVerified',
    verificationToken: 'verificationToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    userId: 'userId',
    bio: 'bio',
    location: 'location',
    website: 'website',
    socialLinks: 'socialLinks',
    avatar: 'avatar',
    rank: 'rank',
    level: 'level',
    xp: 'xp',
    levelProgress: 'levelProgress',
    levelProgressMax: 'levelProgressMax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    lastLogin: 'lastLogin',
    completedQuizzes: 'completedQuizzes',
    completedTutorials: 'completedTutorials',
    completedRoadmaps: 'completedRoadmaps',
    completedSteps: 'completedSteps',
    completedChallenges: 'completedChallenges',
    completedInterviews: 'completedInterviews',
    completedProjects: 'completedProjects',
    theme: 'theme'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    tutorialId: 'tutorialId',
    bestAttemptId: 'bestAttemptId',
    lastAttemptId: 'lastAttemptId',
    userQuizAttemptId: 'userQuizAttemptId',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    attempts: 'attempts',
    bestScore: 'bestScore',
    percentageCompleted: 'percentageCompleted',
    interviewCompleted: 'interviewCompleted',
    challengeCompleted: 'challengeCompleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const UserStreakScalarFieldEnum: {
    profileId: 'profileId',
    streak: 'streak',
    streakDays: 'streakDays',
    lastLogin: 'lastLogin',
    currentStart: 'currentStart',
    currentEnd: 'currentEnd',
    longestStreak: 'longestStreak',
    longestStart: 'longestStart',
    longestEnd: 'longestEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserStreakScalarFieldEnum = (typeof UserStreakScalarFieldEnum)[keyof typeof UserStreakScalarFieldEnum]


  export const UserQuizAttemptScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    score: 'score',
    isPassed: 'isPassed',
    feedback: 'feedback',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type UserQuizAttemptScalarFieldEnum = (typeof UserQuizAttemptScalarFieldEnum)[keyof typeof UserQuizAttemptScalarFieldEnum]


  export const UserQuestionAttemptScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    selectedOption: 'selectedOption',
    isCorrect: 'isCorrect',
    xpEarned: 'xpEarned',
    userQuizAttemptId: 'userQuizAttemptId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserQuestionAttemptScalarFieldEnum = (typeof UserQuestionAttemptScalarFieldEnum)[keyof typeof UserQuestionAttemptScalarFieldEnum]


  export const LastActivityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    description: 'description',
    xpAwarded: 'xpAwarded',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    quizId: 'quizId',
    tutorialId: 'tutorialId',
    roadmapId: 'roadmapId',
    roadmapStepId: 'roadmapStepId',
    quizAttemptId: 'quizAttemptId',
    questionAttemptId: 'questionAttemptId'
  };

  export type LastActivityScalarFieldEnum = (typeof LastActivityScalarFieldEnum)[keyof typeof LastActivityScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    badgeId: 'badgeId',
    earnedAt: 'earnedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const BadgeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    xpReq: 'xpReq',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BadgeScalarFieldEnum = (typeof BadgeScalarFieldEnum)[keyof typeof BadgeScalarFieldEnum]


  export const CoinWalletScalarFieldEnum: {
    profileId: 'profileId',
    balance: 'balance',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoinWalletScalarFieldEnum = (typeof CoinWalletScalarFieldEnum)[keyof typeof CoinWalletScalarFieldEnum]


  export const CoinTransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    amount: 'amount',
    description: 'description',
    transactionAt: 'transactionAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    profileId: 'profileId'
  };

  export type CoinTransactionScalarFieldEnum = (typeof CoinTransactionScalarFieldEnum)[keyof typeof CoinTransactionScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    type: 'type',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const RoadmapProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roadmapId: 'roadmapId',
    progress: 'progress',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapProgressScalarFieldEnum = (typeof RoadmapProgressScalarFieldEnum)[keyof typeof RoadmapProgressScalarFieldEnum]


  export const RoadmapStepScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    order: 'order',
    status: 'status',
    progress: 'progress',
    completedAt: 'completedAt',
    completed: 'completed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    parentId: 'parentId',
    roadmapId: 'roadmapId'
  };

  export type RoadmapStepScalarFieldEnum = (typeof RoadmapStepScalarFieldEnum)[keyof typeof RoadmapStepScalarFieldEnum]


  export const TutorialScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    content: 'content',
    category: 'category',
    authorId: 'authorId',
    likes: 'likes',
    views: 'views',
    isLocked: 'isLocked',
    cost: 'cost',
    hasChallenge: 'hasChallenge',
    difficulty: 'difficulty',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    stepsId: 'stepsId',
    tutorialId: 'tutorialId',
    nextTutorialId: 'nextTutorialId'
  };

  export type TutorialScalarFieldEnum = (typeof TutorialScalarFieldEnum)[keyof typeof TutorialScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    isTimed: 'isTimed',
    timeLimit: 'timeLimit',
    maxScore: 'maxScore',
    passPercentage: 'passPercentage',
    difficulty: 'difficulty',
    order: 'order',
    tutorialLocked: 'tutorialLocked',
    questionCount: 'questionCount',
    estimatedDuration: 'estimatedDuration',
    tutorialId: 'tutorialId',
    stepsId: 'stepsId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    questionText: 'questionText',
    options: 'options',
    correctAnswer: 'correctAnswer',
    xp: 'xp',
    quizId: 'quizId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const AdminActivityLogScalarFieldEnum: {
    id: 'id',
    adminId: 'adminId',
    action: 'action',
    target: 'target',
    targetId: 'targetId',
    timestamp: 'timestamp'
  };

  export type AdminActivityLogScalarFieldEnum = (typeof AdminActivityLogScalarFieldEnum)[keyof typeof AdminActivityLogScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    usageCount: 'usageCount',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'ThemeName'
   */
  export type EnumThemeNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThemeName'>
    


  /**
   * Reference to a field of type 'ThemeName[]'
   */
  export type ListEnumThemeNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ThemeName[]'>
    


  /**
   * Reference to a field of type 'ActivityType'
   */
  export type EnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType'>
    


  /**
   * Reference to a field of type 'ActivityType[]'
   */
  export type ListEnumActivityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'RoadmapType'
   */
  export type EnumRoadmapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadmapType'>
    


  /**
   * Reference to a field of type 'RoadmapType[]'
   */
  export type ListEnumRoadmapTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoadmapType[]'>
    


  /**
   * Reference to a field of type 'StepStatus'
   */
  export type EnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus'>
    


  /**
   * Reference to a field of type 'StepStatus[]'
   */
  export type ListEnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus[]'>
    


  /**
   * Reference to a field of type 'DifficultyLevel'
   */
  export type EnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel'>
    


  /**
   * Reference to a field of type 'DifficultyLevel[]'
   */
  export type ListEnumDifficultyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DifficultyLevel[]'>
    


  /**
   * Reference to a field of type 'TutorialStatus'
   */
  export type EnumTutorialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutorialStatus'>
    


  /**
   * Reference to a field of type 'TutorialStatus[]'
   */
  export type ListEnumTutorialStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TutorialStatus[]'>
    


  /**
   * Reference to a field of type 'TagType'
   */
  export type EnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType'>
    


  /**
   * Reference to a field of type 'TagType[]'
   */
  export type ListEnumTagTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TagType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    failedAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    verificationToken?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    roadmaps?: RoadmapListRelationFilter
    roadmapProgress?: RoadmapProgressListRelationFilter
    adminActivityLogs?: AdminActivityLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    profile?: UserProfileOrderByWithRelationInput
    roadmaps?: RoadmapOrderByRelationAggregateInput
    roadmapProgress?: RoadmapProgressOrderByRelationAggregateInput
    adminActivityLogs?: AdminActivityLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    resetToken?: string
    verificationToken?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    failedAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    profile?: XOR<UserProfileNullableScalarRelationFilter, UserProfileWhereInput> | null
    roadmaps?: RoadmapListRelationFilter
    roadmapProgress?: RoadmapProgressListRelationFilter
    adminActivityLogs?: AdminActivityLogListRelationFilter
  }, "id" | "username" | "email" | "resetToken" | "verificationToken">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    role?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    failedAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    verificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    userId?: StringFilter<"UserProfile"> | string
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    socialLinks?: StringNullableListFilter<"UserProfile">
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    rank?: StringFilter<"UserProfile"> | string
    level?: IntFilter<"UserProfile"> | number
    xp?: IntFilter<"UserProfile"> | number
    levelProgress?: IntFilter<"UserProfile"> | number
    levelProgressMax?: IntFilter<"UserProfile"> | number
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    completedQuizzes?: StringNullableListFilter<"UserProfile">
    completedTutorials?: StringNullableListFilter<"UserProfile">
    completedRoadmaps?: StringNullableListFilter<"UserProfile">
    completedSteps?: StringNullableListFilter<"UserProfile">
    completedChallenges?: StringNullableListFilter<"UserProfile">
    completedInterviews?: StringNullableListFilter<"UserProfile">
    completedProjects?: StringNullableListFilter<"UserProfile">
    theme?: EnumThemeNameFilter<"UserProfile"> | $Enums.ThemeName
    coinWallet?: XOR<CoinWalletNullableScalarRelationFilter, CoinWalletWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coinTransaction?: CoinTransactionListRelationFilter
    lastActivities?: LastActivityListRelationFilter
    progress?: UserProgressListRelationFilter
    quizAttempts?: UserQuizAttemptListRelationFilter
    userBadges?: UserBadgeListRelationFilter
    streaks?: XOR<UserStreakNullableScalarRelationFilter, UserStreakWhereInput> | null
  }

  export type UserProfileOrderByWithRelationInput = {
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialLinks?: SortOrder
    avatar?: SortOrderInput | SortOrder
    rank?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    completedQuizzes?: SortOrder
    completedTutorials?: SortOrder
    completedRoadmaps?: SortOrder
    completedSteps?: SortOrder
    completedChallenges?: SortOrder
    completedInterviews?: SortOrder
    completedProjects?: SortOrder
    theme?: SortOrder
    coinWallet?: CoinWalletOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    coinTransaction?: CoinTransactionOrderByRelationAggregateInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
    progress?: UserProgressOrderByRelationAggregateInput
    quizAttempts?: UserQuizAttemptOrderByRelationAggregateInput
    userBadges?: UserBadgeOrderByRelationAggregateInput
    streaks?: UserStreakOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    socialLinks?: StringNullableListFilter<"UserProfile">
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    rank?: StringFilter<"UserProfile"> | string
    level?: IntFilter<"UserProfile"> | number
    xp?: IntFilter<"UserProfile"> | number
    levelProgress?: IntFilter<"UserProfile"> | number
    levelProgressMax?: IntFilter<"UserProfile"> | number
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    completedQuizzes?: StringNullableListFilter<"UserProfile">
    completedTutorials?: StringNullableListFilter<"UserProfile">
    completedRoadmaps?: StringNullableListFilter<"UserProfile">
    completedSteps?: StringNullableListFilter<"UserProfile">
    completedChallenges?: StringNullableListFilter<"UserProfile">
    completedInterviews?: StringNullableListFilter<"UserProfile">
    completedProjects?: StringNullableListFilter<"UserProfile">
    theme?: EnumThemeNameFilter<"UserProfile"> | $Enums.ThemeName
    coinWallet?: XOR<CoinWalletNullableScalarRelationFilter, CoinWalletWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    coinTransaction?: CoinTransactionListRelationFilter
    lastActivities?: LastActivityListRelationFilter
    progress?: UserProgressListRelationFilter
    quizAttempts?: UserQuizAttemptListRelationFilter
    userBadges?: UserBadgeListRelationFilter
    streaks?: XOR<UserStreakNullableScalarRelationFilter, UserStreakWhereInput> | null
  }, "userId">

  export type UserProfileOrderByWithAggregationInput = {
    userId?: SortOrder
    bio?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    website?: SortOrderInput | SortOrder
    socialLinks?: SortOrder
    avatar?: SortOrderInput | SortOrder
    rank?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    completedQuizzes?: SortOrder
    completedTutorials?: SortOrder
    completedRoadmaps?: SortOrder
    completedSteps?: SortOrder
    completedChallenges?: SortOrder
    completedInterviews?: SortOrder
    completedProjects?: SortOrder
    theme?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _avg?: UserProfileAvgOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
    _sum?: UserProfileSumOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    location?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    website?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    socialLinks?: StringNullableListFilter<"UserProfile">
    avatar?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    rank?: StringWithAggregatesFilter<"UserProfile"> | string
    level?: IntWithAggregatesFilter<"UserProfile"> | number
    xp?: IntWithAggregatesFilter<"UserProfile"> | number
    levelProgress?: IntWithAggregatesFilter<"UserProfile"> | number
    levelProgressMax?: IntWithAggregatesFilter<"UserProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    completedQuizzes?: StringNullableListFilter<"UserProfile">
    completedTutorials?: StringNullableListFilter<"UserProfile">
    completedRoadmaps?: StringNullableListFilter<"UserProfile">
    completedSteps?: StringNullableListFilter<"UserProfile">
    completedChallenges?: StringNullableListFilter<"UserProfile">
    completedInterviews?: StringNullableListFilter<"UserProfile">
    completedProjects?: StringNullableListFilter<"UserProfile">
    theme?: EnumThemeNameWithAggregatesFilter<"UserProfile"> | $Enums.ThemeName
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    tutorialId?: StringFilter<"UserProgress"> | string
    bestAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    lastAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    userQuizAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    isCompleted?: BoolFilter<"UserProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    attempts?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    percentageCompleted?: IntFilter<"UserProgress"> | number
    interviewCompleted?: BoolFilter<"UserProgress"> | boolean
    challengeCompleted?: BoolFilter<"UserProgress"> | boolean
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    profileId?: StringFilter<"UserProgress"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    tutorial?: XOR<TutorialScalarRelationFilter, TutorialWhereInput>
    userQuizAttempt?: XOR<UserQuizAttemptNullableScalarRelationFilter, UserQuizAttemptWhereInput> | null
  }

  export type UserProgressOrderByWithRelationInput = {
    tutorialId?: SortOrder
    bestAttemptId?: SortOrderInput | SortOrder
    lastAttemptId?: SortOrderInput | SortOrder
    userQuizAttemptId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
    interviewCompleted?: SortOrder
    challengeCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    tutorial?: TutorialOrderByWithRelationInput
    userQuizAttempt?: UserQuizAttemptOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    profileId_tutorialId?: UserProgressProfileIdTutorialIdCompoundUniqueInput
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    tutorialId?: StringFilter<"UserProgress"> | string
    bestAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    lastAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    userQuizAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    isCompleted?: BoolFilter<"UserProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    attempts?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    percentageCompleted?: IntFilter<"UserProgress"> | number
    interviewCompleted?: BoolFilter<"UserProgress"> | boolean
    challengeCompleted?: BoolFilter<"UserProgress"> | boolean
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    profileId?: StringFilter<"UserProgress"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    tutorial?: XOR<TutorialScalarRelationFilter, TutorialWhereInput>
    userQuizAttempt?: XOR<UserQuizAttemptNullableScalarRelationFilter, UserQuizAttemptWhereInput> | null
  }, "profileId_tutorialId">

  export type UserProgressOrderByWithAggregationInput = {
    tutorialId?: SortOrder
    bestAttemptId?: SortOrderInput | SortOrder
    lastAttemptId?: SortOrderInput | SortOrder
    userQuizAttemptId?: SortOrderInput | SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
    interviewCompleted?: SortOrder
    challengeCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _avg?: UserProgressAvgOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
    _sum?: UserProgressSumOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    tutorialId?: StringWithAggregatesFilter<"UserProgress"> | string
    bestAttemptId?: StringNullableWithAggregatesFilter<"UserProgress"> | string | null
    lastAttemptId?: StringNullableWithAggregatesFilter<"UserProgress"> | string | null
    userQuizAttemptId?: StringNullableWithAggregatesFilter<"UserProgress"> | string | null
    isCompleted?: BoolWithAggregatesFilter<"UserProgress"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserProgress"> | Date | string | null
    attempts?: IntWithAggregatesFilter<"UserProgress"> | number
    bestScore?: IntWithAggregatesFilter<"UserProgress"> | number
    percentageCompleted?: IntWithAggregatesFilter<"UserProgress"> | number
    interviewCompleted?: BoolWithAggregatesFilter<"UserProgress"> | boolean
    challengeCompleted?: BoolWithAggregatesFilter<"UserProgress"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    profileId?: StringWithAggregatesFilter<"UserProgress"> | string
  }

  export type UserStreakWhereInput = {
    AND?: UserStreakWhereInput | UserStreakWhereInput[]
    OR?: UserStreakWhereInput[]
    NOT?: UserStreakWhereInput | UserStreakWhereInput[]
    profileId?: StringFilter<"UserStreak"> | string
    streak?: IntFilter<"UserStreak"> | number
    streakDays?: IntFilter<"UserStreak"> | number
    lastLogin?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    currentStart?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    currentEnd?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    longestStreak?: IntFilter<"UserStreak"> | number
    longestStart?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    longestEnd?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    createdAt?: DateTimeFilter<"UserStreak"> | Date | string
    updatedAt?: DateTimeFilter<"UserStreak"> | Date | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type UserStreakOrderByWithRelationInput = {
    profileId?: SortOrder
    streak?: SortOrder
    streakDays?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    currentStart?: SortOrderInput | SortOrder
    currentEnd?: SortOrderInput | SortOrder
    longestStreak?: SortOrder
    longestStart?: SortOrderInput | SortOrder
    longestEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
  }

  export type UserStreakWhereUniqueInput = Prisma.AtLeast<{
    profileId?: string
    AND?: UserStreakWhereInput | UserStreakWhereInput[]
    OR?: UserStreakWhereInput[]
    NOT?: UserStreakWhereInput | UserStreakWhereInput[]
    streak?: IntFilter<"UserStreak"> | number
    streakDays?: IntFilter<"UserStreak"> | number
    lastLogin?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    currentStart?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    currentEnd?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    longestStreak?: IntFilter<"UserStreak"> | number
    longestStart?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    longestEnd?: DateTimeNullableFilter<"UserStreak"> | Date | string | null
    createdAt?: DateTimeFilter<"UserStreak"> | Date | string
    updatedAt?: DateTimeFilter<"UserStreak"> | Date | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "profileId">

  export type UserStreakOrderByWithAggregationInput = {
    profileId?: SortOrder
    streak?: SortOrder
    streakDays?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    currentStart?: SortOrderInput | SortOrder
    currentEnd?: SortOrderInput | SortOrder
    longestStreak?: SortOrder
    longestStart?: SortOrderInput | SortOrder
    longestEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserStreakCountOrderByAggregateInput
    _avg?: UserStreakAvgOrderByAggregateInput
    _max?: UserStreakMaxOrderByAggregateInput
    _min?: UserStreakMinOrderByAggregateInput
    _sum?: UserStreakSumOrderByAggregateInput
  }

  export type UserStreakScalarWhereWithAggregatesInput = {
    AND?: UserStreakScalarWhereWithAggregatesInput | UserStreakScalarWhereWithAggregatesInput[]
    OR?: UserStreakScalarWhereWithAggregatesInput[]
    NOT?: UserStreakScalarWhereWithAggregatesInput | UserStreakScalarWhereWithAggregatesInput[]
    profileId?: StringWithAggregatesFilter<"UserStreak"> | string
    streak?: IntWithAggregatesFilter<"UserStreak"> | number
    streakDays?: IntWithAggregatesFilter<"UserStreak"> | number
    lastLogin?: DateTimeNullableWithAggregatesFilter<"UserStreak"> | Date | string | null
    currentStart?: DateTimeNullableWithAggregatesFilter<"UserStreak"> | Date | string | null
    currentEnd?: DateTimeNullableWithAggregatesFilter<"UserStreak"> | Date | string | null
    longestStreak?: IntWithAggregatesFilter<"UserStreak"> | number
    longestStart?: DateTimeNullableWithAggregatesFilter<"UserStreak"> | Date | string | null
    longestEnd?: DateTimeNullableWithAggregatesFilter<"UserStreak"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserStreak"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserStreak"> | Date | string
  }

  export type UserQuizAttemptWhereInput = {
    AND?: UserQuizAttemptWhereInput | UserQuizAttemptWhereInput[]
    OR?: UserQuizAttemptWhereInput[]
    NOT?: UserQuizAttemptWhereInput | UserQuizAttemptWhereInput[]
    id?: StringFilter<"UserQuizAttempt"> | string
    quizId?: StringFilter<"UserQuizAttempt"> | string
    startedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserQuizAttempt"> | Date | string | null
    score?: IntFilter<"UserQuizAttempt"> | number
    isPassed?: BoolFilter<"UserQuizAttempt"> | boolean
    feedback?: StringNullableFilter<"UserQuizAttempt"> | string | null
    createdAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    profileId?: StringFilter<"UserQuizAttempt"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    questionAttempts?: UserQuestionAttemptListRelationFilter
    lastActivities?: LastActivityListRelationFilter
    userProgress?: UserProgressListRelationFilter
  }

  export type UserQuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    isPassed?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    quiz?: QuizOrderByWithRelationInput
    questionAttempts?: UserQuestionAttemptOrderByRelationAggregateInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
    userProgress?: UserProgressOrderByRelationAggregateInput
  }

  export type UserQuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_quizId?: UserQuizAttemptProfileIdQuizIdCompoundUniqueInput
    AND?: UserQuizAttemptWhereInput | UserQuizAttemptWhereInput[]
    OR?: UserQuizAttemptWhereInput[]
    NOT?: UserQuizAttemptWhereInput | UserQuizAttemptWhereInput[]
    quizId?: StringFilter<"UserQuizAttempt"> | string
    startedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserQuizAttempt"> | Date | string | null
    score?: IntFilter<"UserQuizAttempt"> | number
    isPassed?: BoolFilter<"UserQuizAttempt"> | boolean
    feedback?: StringNullableFilter<"UserQuizAttempt"> | string | null
    createdAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    profileId?: StringFilter<"UserQuizAttempt"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    questionAttempts?: UserQuestionAttemptListRelationFilter
    lastActivities?: LastActivityListRelationFilter
    userProgress?: UserProgressListRelationFilter
  }, "id" | "profileId_quizId">

  export type UserQuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    score?: SortOrder
    isPassed?: SortOrder
    feedback?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: UserQuizAttemptCountOrderByAggregateInput
    _avg?: UserQuizAttemptAvgOrderByAggregateInput
    _max?: UserQuizAttemptMaxOrderByAggregateInput
    _min?: UserQuizAttemptMinOrderByAggregateInput
    _sum?: UserQuizAttemptSumOrderByAggregateInput
  }

  export type UserQuizAttemptScalarWhereWithAggregatesInput = {
    AND?: UserQuizAttemptScalarWhereWithAggregatesInput | UserQuizAttemptScalarWhereWithAggregatesInput[]
    OR?: UserQuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: UserQuizAttemptScalarWhereWithAggregatesInput | UserQuizAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQuizAttempt"> | string
    quizId?: StringWithAggregatesFilter<"UserQuizAttempt"> | string
    startedAt?: DateTimeWithAggregatesFilter<"UserQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserQuizAttempt"> | Date | string | null
    score?: IntWithAggregatesFilter<"UserQuizAttempt"> | number
    isPassed?: BoolWithAggregatesFilter<"UserQuizAttempt"> | boolean
    feedback?: StringNullableWithAggregatesFilter<"UserQuizAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserQuizAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserQuizAttempt"> | Date | string
    profileId?: StringWithAggregatesFilter<"UserQuizAttempt"> | string
  }

  export type UserQuestionAttemptWhereInput = {
    AND?: UserQuestionAttemptWhereInput | UserQuestionAttemptWhereInput[]
    OR?: UserQuestionAttemptWhereInput[]
    NOT?: UserQuestionAttemptWhereInput | UserQuestionAttemptWhereInput[]
    id?: StringFilter<"UserQuestionAttempt"> | string
    questionId?: StringFilter<"UserQuestionAttempt"> | string
    selectedOption?: StringFilter<"UserQuestionAttempt"> | string
    isCorrect?: BoolFilter<"UserQuestionAttempt"> | boolean
    xpEarned?: IntFilter<"UserQuestionAttempt"> | number
    userQuizAttemptId?: StringFilter<"UserQuestionAttempt"> | string
    createdAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
    quizAttempts?: XOR<UserQuizAttemptScalarRelationFilter, UserQuizAttemptWhereInput>
    lastActivities?: LastActivityListRelationFilter
  }

  export type UserQuestionAttemptOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    xpEarned?: SortOrder
    userQuizAttemptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizAttempts?: UserQuizAttemptOrderByWithRelationInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
  }

  export type UserQuestionAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserQuestionAttemptWhereInput | UserQuestionAttemptWhereInput[]
    OR?: UserQuestionAttemptWhereInput[]
    NOT?: UserQuestionAttemptWhereInput | UserQuestionAttemptWhereInput[]
    questionId?: StringFilter<"UserQuestionAttempt"> | string
    selectedOption?: StringFilter<"UserQuestionAttempt"> | string
    isCorrect?: BoolFilter<"UserQuestionAttempt"> | boolean
    xpEarned?: IntFilter<"UserQuestionAttempt"> | number
    userQuizAttemptId?: StringFilter<"UserQuestionAttempt"> | string
    createdAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
    quizAttempts?: XOR<UserQuizAttemptScalarRelationFilter, UserQuizAttemptWhereInput>
    lastActivities?: LastActivityListRelationFilter
  }, "id">

  export type UserQuestionAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    xpEarned?: SortOrder
    userQuizAttemptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserQuestionAttemptCountOrderByAggregateInput
    _avg?: UserQuestionAttemptAvgOrderByAggregateInput
    _max?: UserQuestionAttemptMaxOrderByAggregateInput
    _min?: UserQuestionAttemptMinOrderByAggregateInput
    _sum?: UserQuestionAttemptSumOrderByAggregateInput
  }

  export type UserQuestionAttemptScalarWhereWithAggregatesInput = {
    AND?: UserQuestionAttemptScalarWhereWithAggregatesInput | UserQuestionAttemptScalarWhereWithAggregatesInput[]
    OR?: UserQuestionAttemptScalarWhereWithAggregatesInput[]
    NOT?: UserQuestionAttemptScalarWhereWithAggregatesInput | UserQuestionAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserQuestionAttempt"> | string
    questionId?: StringWithAggregatesFilter<"UserQuestionAttempt"> | string
    selectedOption?: StringWithAggregatesFilter<"UserQuestionAttempt"> | string
    isCorrect?: BoolWithAggregatesFilter<"UserQuestionAttempt"> | boolean
    xpEarned?: IntWithAggregatesFilter<"UserQuestionAttempt"> | number
    userQuizAttemptId?: StringWithAggregatesFilter<"UserQuestionAttempt"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserQuestionAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserQuestionAttempt"> | Date | string
  }

  export type LastActivityWhereInput = {
    AND?: LastActivityWhereInput | LastActivityWhereInput[]
    OR?: LastActivityWhereInput[]
    NOT?: LastActivityWhereInput | LastActivityWhereInput[]
    id?: StringFilter<"LastActivity"> | string
    userId?: StringFilter<"LastActivity"> | string
    type?: EnumActivityTypeFilter<"LastActivity"> | $Enums.ActivityType
    description?: StringNullableFilter<"LastActivity"> | string | null
    xpAwarded?: IntNullableFilter<"LastActivity"> | number | null
    createdAt?: DateTimeFilter<"LastActivity"> | Date | string
    updatedAt?: DateTimeFilter<"LastActivity"> | Date | string
    quizId?: StringNullableFilter<"LastActivity"> | string | null
    tutorialId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapStepId?: StringNullableFilter<"LastActivity"> | string | null
    quizAttemptId?: StringNullableFilter<"LastActivity"> | string | null
    questionAttemptId?: StringNullableFilter<"LastActivity"> | string | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    tutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, RoadmapWhereInput> | null
    roadmapStep?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    quizAttempt?: XOR<UserQuizAttemptNullableScalarRelationFilter, UserQuizAttemptWhereInput> | null
    questionAttempt?: XOR<UserQuestionAttemptNullableScalarRelationFilter, UserQuestionAttemptWhereInput> | null
    profile?: UserProfileListRelationFilter
  }

  export type LastActivityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    xpAwarded?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizId?: SortOrderInput | SortOrder
    tutorialId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    roadmapStepId?: SortOrderInput | SortOrder
    quizAttemptId?: SortOrderInput | SortOrder
    questionAttemptId?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
    tutorial?: TutorialOrderByWithRelationInput
    roadmap?: RoadmapOrderByWithRelationInput
    roadmapStep?: RoadmapStepOrderByWithRelationInput
    quizAttempt?: UserQuizAttemptOrderByWithRelationInput
    questionAttempt?: UserQuestionAttemptOrderByWithRelationInput
    profile?: UserProfileOrderByRelationAggregateInput
  }

  export type LastActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LastActivityWhereInput | LastActivityWhereInput[]
    OR?: LastActivityWhereInput[]
    NOT?: LastActivityWhereInput | LastActivityWhereInput[]
    userId?: StringFilter<"LastActivity"> | string
    type?: EnumActivityTypeFilter<"LastActivity"> | $Enums.ActivityType
    description?: StringNullableFilter<"LastActivity"> | string | null
    xpAwarded?: IntNullableFilter<"LastActivity"> | number | null
    createdAt?: DateTimeFilter<"LastActivity"> | Date | string
    updatedAt?: DateTimeFilter<"LastActivity"> | Date | string
    quizId?: StringNullableFilter<"LastActivity"> | string | null
    tutorialId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapStepId?: StringNullableFilter<"LastActivity"> | string | null
    quizAttemptId?: StringNullableFilter<"LastActivity"> | string | null
    questionAttemptId?: StringNullableFilter<"LastActivity"> | string | null
    quiz?: XOR<QuizNullableScalarRelationFilter, QuizWhereInput> | null
    tutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, RoadmapWhereInput> | null
    roadmapStep?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    quizAttempt?: XOR<UserQuizAttemptNullableScalarRelationFilter, UserQuizAttemptWhereInput> | null
    questionAttempt?: XOR<UserQuestionAttemptNullableScalarRelationFilter, UserQuestionAttemptWhereInput> | null
    profile?: UserProfileListRelationFilter
  }, "id">

  export type LastActivityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrderInput | SortOrder
    xpAwarded?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizId?: SortOrderInput | SortOrder
    tutorialId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    roadmapStepId?: SortOrderInput | SortOrder
    quizAttemptId?: SortOrderInput | SortOrder
    questionAttemptId?: SortOrderInput | SortOrder
    _count?: LastActivityCountOrderByAggregateInput
    _avg?: LastActivityAvgOrderByAggregateInput
    _max?: LastActivityMaxOrderByAggregateInput
    _min?: LastActivityMinOrderByAggregateInput
    _sum?: LastActivitySumOrderByAggregateInput
  }

  export type LastActivityScalarWhereWithAggregatesInput = {
    AND?: LastActivityScalarWhereWithAggregatesInput | LastActivityScalarWhereWithAggregatesInput[]
    OR?: LastActivityScalarWhereWithAggregatesInput[]
    NOT?: LastActivityScalarWhereWithAggregatesInput | LastActivityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LastActivity"> | string
    userId?: StringWithAggregatesFilter<"LastActivity"> | string
    type?: EnumActivityTypeWithAggregatesFilter<"LastActivity"> | $Enums.ActivityType
    description?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    xpAwarded?: IntNullableWithAggregatesFilter<"LastActivity"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LastActivity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LastActivity"> | Date | string
    quizId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    tutorialId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    roadmapId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    roadmapStepId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    quizAttemptId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
    questionAttemptId?: StringNullableWithAggregatesFilter<"LastActivity"> | string | null
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    updatedAt?: DateTimeFilter<"UserBadge"> | Date | string
    profileId?: StringFilter<"UserBadge"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    badgeId?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    badge?: BadgeOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    profileId?: string
    profileId_badgeId?: UserBadgeProfileIdBadgeIdCompoundUniqueInput
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    updatedAt?: DateTimeFilter<"UserBadge"> | Date | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
    badge?: XOR<BadgeScalarRelationFilter, BadgeWhereInput>
  }, "profileId" | "profileId_badgeId">

  export type UserBadgeOrderByWithAggregationInput = {
    badgeId?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    badgeId?: StringWithAggregatesFilter<"UserBadge"> | string
    earnedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
    profileId?: StringWithAggregatesFilter<"UserBadge"> | string
  }

  export type BadgeWhereInput = {
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    id?: StringFilter<"Badge"> | string
    name?: StringFilter<"Badge"> | string
    imageUrl?: StringFilter<"Badge"> | string
    xpReq?: IntFilter<"Badge"> | number
    description?: StringNullableFilter<"Badge"> | string | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    badges?: UserBadgeListRelationFilter
  }

  export type BadgeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    xpReq?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    badges?: UserBadgeOrderByRelationAggregateInput
  }

  export type BadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BadgeWhereInput | BadgeWhereInput[]
    OR?: BadgeWhereInput[]
    NOT?: BadgeWhereInput | BadgeWhereInput[]
    name?: StringFilter<"Badge"> | string
    imageUrl?: StringFilter<"Badge"> | string
    xpReq?: IntFilter<"Badge"> | number
    description?: StringNullableFilter<"Badge"> | string | null
    createdAt?: DateTimeFilter<"Badge"> | Date | string
    updatedAt?: DateTimeFilter<"Badge"> | Date | string
    badges?: UserBadgeListRelationFilter
  }, "id">

  export type BadgeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    xpReq?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BadgeCountOrderByAggregateInput
    _avg?: BadgeAvgOrderByAggregateInput
    _max?: BadgeMaxOrderByAggregateInput
    _min?: BadgeMinOrderByAggregateInput
    _sum?: BadgeSumOrderByAggregateInput
  }

  export type BadgeScalarWhereWithAggregatesInput = {
    AND?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    OR?: BadgeScalarWhereWithAggregatesInput[]
    NOT?: BadgeScalarWhereWithAggregatesInput | BadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Badge"> | string
    name?: StringWithAggregatesFilter<"Badge"> | string
    imageUrl?: StringWithAggregatesFilter<"Badge"> | string
    xpReq?: IntWithAggregatesFilter<"Badge"> | number
    description?: StringNullableWithAggregatesFilter<"Badge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Badge"> | Date | string
  }

  export type CoinWalletWhereInput = {
    AND?: CoinWalletWhereInput | CoinWalletWhereInput[]
    OR?: CoinWalletWhereInput[]
    NOT?: CoinWalletWhereInput | CoinWalletWhereInput[]
    profileId?: StringFilter<"CoinWallet"> | string
    balance?: IntFilter<"CoinWallet"> | number
    createdAt?: DateTimeFilter<"CoinWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CoinWallet"> | Date | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type CoinWalletOrderByWithRelationInput = {
    profileId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
  }

  export type CoinWalletWhereUniqueInput = Prisma.AtLeast<{
    profileId?: string
    AND?: CoinWalletWhereInput | CoinWalletWhereInput[]
    OR?: CoinWalletWhereInput[]
    NOT?: CoinWalletWhereInput | CoinWalletWhereInput[]
    balance?: IntFilter<"CoinWallet"> | number
    createdAt?: DateTimeFilter<"CoinWallet"> | Date | string
    updatedAt?: DateTimeFilter<"CoinWallet"> | Date | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "profileId">

  export type CoinWalletOrderByWithAggregationInput = {
    profileId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoinWalletCountOrderByAggregateInput
    _avg?: CoinWalletAvgOrderByAggregateInput
    _max?: CoinWalletMaxOrderByAggregateInput
    _min?: CoinWalletMinOrderByAggregateInput
    _sum?: CoinWalletSumOrderByAggregateInput
  }

  export type CoinWalletScalarWhereWithAggregatesInput = {
    AND?: CoinWalletScalarWhereWithAggregatesInput | CoinWalletScalarWhereWithAggregatesInput[]
    OR?: CoinWalletScalarWhereWithAggregatesInput[]
    NOT?: CoinWalletScalarWhereWithAggregatesInput | CoinWalletScalarWhereWithAggregatesInput[]
    profileId?: StringWithAggregatesFilter<"CoinWallet"> | string
    balance?: IntWithAggregatesFilter<"CoinWallet"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CoinWallet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoinWallet"> | Date | string
  }

  export type CoinTransactionWhereInput = {
    AND?: CoinTransactionWhereInput | CoinTransactionWhereInput[]
    OR?: CoinTransactionWhereInput[]
    NOT?: CoinTransactionWhereInput | CoinTransactionWhereInput[]
    id?: StringFilter<"CoinTransaction"> | string
    type?: EnumTransactionTypeFilter<"CoinTransaction"> | $Enums.TransactionType
    amount?: IntFilter<"CoinTransaction"> | number
    description?: StringFilter<"CoinTransaction"> | string
    transactionAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    createdAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    profileId?: StringFilter<"CoinTransaction"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }

  export type CoinTransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
  }

  export type CoinTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_transactionAt?: CoinTransactionProfileIdTransactionAtCompoundUniqueInput
    AND?: CoinTransactionWhereInput | CoinTransactionWhereInput[]
    OR?: CoinTransactionWhereInput[]
    NOT?: CoinTransactionWhereInput | CoinTransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"CoinTransaction"> | $Enums.TransactionType
    amount?: IntFilter<"CoinTransaction"> | number
    description?: StringFilter<"CoinTransaction"> | string
    transactionAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    createdAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    profileId?: StringFilter<"CoinTransaction"> | string
    profile?: XOR<UserProfileScalarRelationFilter, UserProfileWhereInput>
  }, "id" | "profileId_transactionAt">

  export type CoinTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
    _count?: CoinTransactionCountOrderByAggregateInput
    _avg?: CoinTransactionAvgOrderByAggregateInput
    _max?: CoinTransactionMaxOrderByAggregateInput
    _min?: CoinTransactionMinOrderByAggregateInput
    _sum?: CoinTransactionSumOrderByAggregateInput
  }

  export type CoinTransactionScalarWhereWithAggregatesInput = {
    AND?: CoinTransactionScalarWhereWithAggregatesInput | CoinTransactionScalarWhereWithAggregatesInput[]
    OR?: CoinTransactionScalarWhereWithAggregatesInput[]
    NOT?: CoinTransactionScalarWhereWithAggregatesInput | CoinTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CoinTransaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"CoinTransaction"> | $Enums.TransactionType
    amount?: IntWithAggregatesFilter<"CoinTransaction"> | number
    description?: StringWithAggregatesFilter<"CoinTransaction"> | string
    transactionAt?: DateTimeWithAggregatesFilter<"CoinTransaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CoinTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoinTransaction"> | Date | string
    profileId?: StringWithAggregatesFilter<"CoinTransaction"> | string
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    title?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    category?: StringNullableFilter<"Roadmap"> | string | null
    type?: EnumRoadmapTypeFilter<"Roadmap"> | $Enums.RoadmapType
    createdById?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: RoadmapStepListRelationFilter
    roadmapProgress?: RoadmapProgressListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    steps?: RoadmapStepOrderByRelationAggregateInput
    roadmapProgress?: RoadmapProgressOrderByRelationAggregateInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    title?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    category?: StringNullableFilter<"Roadmap"> | string | null
    type?: EnumRoadmapTypeFilter<"Roadmap"> | $Enums.RoadmapType
    createdById?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    steps?: RoadmapStepListRelationFilter
    roadmapProgress?: RoadmapProgressListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }, "id">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    title?: StringWithAggregatesFilter<"Roadmap"> | string
    description?: StringNullableWithAggregatesFilter<"Roadmap"> | string | null
    category?: StringNullableWithAggregatesFilter<"Roadmap"> | string | null
    type?: EnumRoadmapTypeWithAggregatesFilter<"Roadmap"> | $Enums.RoadmapType
    createdById?: StringWithAggregatesFilter<"Roadmap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Roadmap"> | Date | string | null
  }

  export type RoadmapProgressWhereInput = {
    AND?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    OR?: RoadmapProgressWhereInput[]
    NOT?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    id?: StringFilter<"RoadmapProgress"> | string
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    progress?: IntFilter<"RoadmapProgress"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
  }

  export type RoadmapProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    roadmap?: RoadmapOrderByWithRelationInput
  }

  export type RoadmapProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_roadmapId?: RoadmapProgressUserIdRoadmapIdCompoundUniqueInput
    AND?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    OR?: RoadmapProgressWhereInput[]
    NOT?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    progress?: IntFilter<"RoadmapProgress"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    roadmap?: XOR<RoadmapScalarRelationFilter, RoadmapWhereInput>
  }, "id" | "userId_roadmapId">

  export type RoadmapProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapProgressCountOrderByAggregateInput
    _avg?: RoadmapProgressAvgOrderByAggregateInput
    _max?: RoadmapProgressMaxOrderByAggregateInput
    _min?: RoadmapProgressMinOrderByAggregateInput
    _sum?: RoadmapProgressSumOrderByAggregateInput
  }

  export type RoadmapProgressScalarWhereWithAggregatesInput = {
    AND?: RoadmapProgressScalarWhereWithAggregatesInput | RoadmapProgressScalarWhereWithAggregatesInput[]
    OR?: RoadmapProgressScalarWhereWithAggregatesInput[]
    NOT?: RoadmapProgressScalarWhereWithAggregatesInput | RoadmapProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    userId?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    roadmapId?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    progress?: IntWithAggregatesFilter<"RoadmapProgress"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapProgress"> | Date | string
  }

  export type RoadmapStepWhereInput = {
    AND?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    OR?: RoadmapStepWhereInput[]
    NOT?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    id?: StringFilter<"RoadmapStep"> | string
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringNullableFilter<"RoadmapStep"> | string | null
    order?: IntFilter<"RoadmapStep"> | number
    status?: EnumStepStatusFilter<"RoadmapStep"> | $Enums.StepStatus
    progress?: IntFilter<"RoadmapStep"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapStep"> | Date | string | null
    completed?: BoolFilter<"RoadmapStep"> | boolean
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    parentId?: StringNullableFilter<"RoadmapStep"> | string | null
    roadmapId?: StringNullableFilter<"RoadmapStep"> | string | null
    parent?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    children?: RoadmapStepListRelationFilter
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, RoadmapWhereInput> | null
    tutorials?: TutorialListRelationFilter
    quizzes?: QuizListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }

  export type RoadmapStepOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    parent?: RoadmapStepOrderByWithRelationInput
    children?: RoadmapStepOrderByRelationAggregateInput
    roadmap?: RoadmapOrderByWithRelationInput
    tutorials?: TutorialOrderByRelationAggregateInput
    quizzes?: QuizOrderByRelationAggregateInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
  }

  export type RoadmapStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    OR?: RoadmapStepWhereInput[]
    NOT?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringNullableFilter<"RoadmapStep"> | string | null
    order?: IntFilter<"RoadmapStep"> | number
    status?: EnumStepStatusFilter<"RoadmapStep"> | $Enums.StepStatus
    progress?: IntFilter<"RoadmapStep"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapStep"> | Date | string | null
    completed?: BoolFilter<"RoadmapStep"> | boolean
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    parentId?: StringNullableFilter<"RoadmapStep"> | string | null
    roadmapId?: StringNullableFilter<"RoadmapStep"> | string | null
    parent?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    children?: RoadmapStepListRelationFilter
    roadmap?: XOR<RoadmapNullableScalarRelationFilter, RoadmapWhereInput> | null
    tutorials?: TutorialListRelationFilter
    quizzes?: QuizListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }, "id">

  export type RoadmapStepOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrderInput | SortOrder
    roadmapId?: SortOrderInput | SortOrder
    _count?: RoadmapStepCountOrderByAggregateInput
    _avg?: RoadmapStepAvgOrderByAggregateInput
    _max?: RoadmapStepMaxOrderByAggregateInput
    _min?: RoadmapStepMinOrderByAggregateInput
    _sum?: RoadmapStepSumOrderByAggregateInput
  }

  export type RoadmapStepScalarWhereWithAggregatesInput = {
    AND?: RoadmapStepScalarWhereWithAggregatesInput | RoadmapStepScalarWhereWithAggregatesInput[]
    OR?: RoadmapStepScalarWhereWithAggregatesInput[]
    NOT?: RoadmapStepScalarWhereWithAggregatesInput | RoadmapStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapStep"> | string
    title?: StringWithAggregatesFilter<"RoadmapStep"> | string
    description?: StringNullableWithAggregatesFilter<"RoadmapStep"> | string | null
    order?: IntWithAggregatesFilter<"RoadmapStep"> | number
    status?: EnumStepStatusWithAggregatesFilter<"RoadmapStep"> | $Enums.StepStatus
    progress?: IntWithAggregatesFilter<"RoadmapStep"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"RoadmapStep"> | Date | string | null
    completed?: BoolWithAggregatesFilter<"RoadmapStep"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapStep"> | Date | string
    parentId?: StringNullableWithAggregatesFilter<"RoadmapStep"> | string | null
    roadmapId?: StringNullableWithAggregatesFilter<"RoadmapStep"> | string | null
  }

  export type TutorialWhereInput = {
    AND?: TutorialWhereInput | TutorialWhereInput[]
    OR?: TutorialWhereInput[]
    NOT?: TutorialWhereInput | TutorialWhereInput[]
    id?: StringFilter<"Tutorial"> | string
    title?: StringFilter<"Tutorial"> | string
    description?: StringNullableFilter<"Tutorial"> | string | null
    content?: StringFilter<"Tutorial"> | string
    category?: StringNullableFilter<"Tutorial"> | string | null
    authorId?: StringNullableFilter<"Tutorial"> | string | null
    likes?: IntFilter<"Tutorial"> | number
    views?: IntFilter<"Tutorial"> | number
    isLocked?: BoolFilter<"Tutorial"> | boolean
    cost?: IntFilter<"Tutorial"> | number
    hasChallenge?: BoolFilter<"Tutorial"> | boolean
    difficulty?: EnumDifficultyLevelFilter<"Tutorial"> | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFilter<"Tutorial"> | $Enums.TutorialStatus
    createdAt?: DateTimeFilter<"Tutorial"> | Date | string
    updatedAt?: DateTimeFilter<"Tutorial"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tutorial"> | Date | string | null
    stepsId?: StringNullableFilter<"Tutorial"> | string | null
    tutorialId?: StringNullableFilter<"Tutorial"> | string | null
    nextTutorialId?: StringNullableFilter<"Tutorial"> | string | null
    quizzes?: QuizListRelationFilter
    progress?: UserProgressListRelationFilter
    tutorialTags?: TagListRelationFilter
    steps?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    tutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    nextTutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    previousTutorials?: TutorialListRelationFilter
    relatedTutorials?: TutorialListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }

  export type TutorialOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isLocked?: SortOrder
    cost?: SortOrder
    hasChallenge?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    stepsId?: SortOrderInput | SortOrder
    tutorialId?: SortOrderInput | SortOrder
    nextTutorialId?: SortOrderInput | SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    progress?: UserProgressOrderByRelationAggregateInput
    tutorialTags?: TagOrderByRelationAggregateInput
    steps?: RoadmapStepOrderByWithRelationInput
    tutorial?: TutorialOrderByWithRelationInput
    nextTutorial?: TutorialOrderByWithRelationInput
    previousTutorials?: TutorialOrderByRelationAggregateInput
    relatedTutorials?: TutorialOrderByRelationAggregateInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
  }

  export type TutorialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TutorialWhereInput | TutorialWhereInput[]
    OR?: TutorialWhereInput[]
    NOT?: TutorialWhereInput | TutorialWhereInput[]
    title?: StringFilter<"Tutorial"> | string
    description?: StringNullableFilter<"Tutorial"> | string | null
    content?: StringFilter<"Tutorial"> | string
    category?: StringNullableFilter<"Tutorial"> | string | null
    authorId?: StringNullableFilter<"Tutorial"> | string | null
    likes?: IntFilter<"Tutorial"> | number
    views?: IntFilter<"Tutorial"> | number
    isLocked?: BoolFilter<"Tutorial"> | boolean
    cost?: IntFilter<"Tutorial"> | number
    hasChallenge?: BoolFilter<"Tutorial"> | boolean
    difficulty?: EnumDifficultyLevelFilter<"Tutorial"> | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFilter<"Tutorial"> | $Enums.TutorialStatus
    createdAt?: DateTimeFilter<"Tutorial"> | Date | string
    updatedAt?: DateTimeFilter<"Tutorial"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tutorial"> | Date | string | null
    stepsId?: StringNullableFilter<"Tutorial"> | string | null
    tutorialId?: StringNullableFilter<"Tutorial"> | string | null
    nextTutorialId?: StringNullableFilter<"Tutorial"> | string | null
    quizzes?: QuizListRelationFilter
    progress?: UserProgressListRelationFilter
    tutorialTags?: TagListRelationFilter
    steps?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    tutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    nextTutorial?: XOR<TutorialNullableScalarRelationFilter, TutorialWhereInput> | null
    previousTutorials?: TutorialListRelationFilter
    relatedTutorials?: TutorialListRelationFilter
    lastActivities?: LastActivityListRelationFilter
  }, "id">

  export type TutorialOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    content?: SortOrder
    category?: SortOrderInput | SortOrder
    authorId?: SortOrderInput | SortOrder
    likes?: SortOrder
    views?: SortOrder
    isLocked?: SortOrder
    cost?: SortOrder
    hasChallenge?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    stepsId?: SortOrderInput | SortOrder
    tutorialId?: SortOrderInput | SortOrder
    nextTutorialId?: SortOrderInput | SortOrder
    _count?: TutorialCountOrderByAggregateInput
    _avg?: TutorialAvgOrderByAggregateInput
    _max?: TutorialMaxOrderByAggregateInput
    _min?: TutorialMinOrderByAggregateInput
    _sum?: TutorialSumOrderByAggregateInput
  }

  export type TutorialScalarWhereWithAggregatesInput = {
    AND?: TutorialScalarWhereWithAggregatesInput | TutorialScalarWhereWithAggregatesInput[]
    OR?: TutorialScalarWhereWithAggregatesInput[]
    NOT?: TutorialScalarWhereWithAggregatesInput | TutorialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tutorial"> | string
    title?: StringWithAggregatesFilter<"Tutorial"> | string
    description?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
    content?: StringWithAggregatesFilter<"Tutorial"> | string
    category?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
    authorId?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
    likes?: IntWithAggregatesFilter<"Tutorial"> | number
    views?: IntWithAggregatesFilter<"Tutorial"> | number
    isLocked?: BoolWithAggregatesFilter<"Tutorial"> | boolean
    cost?: IntWithAggregatesFilter<"Tutorial"> | number
    hasChallenge?: BoolWithAggregatesFilter<"Tutorial"> | boolean
    difficulty?: EnumDifficultyLevelWithAggregatesFilter<"Tutorial"> | $Enums.DifficultyLevel
    status?: EnumTutorialStatusWithAggregatesFilter<"Tutorial"> | $Enums.TutorialStatus
    createdAt?: DateTimeWithAggregatesFilter<"Tutorial"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tutorial"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Tutorial"> | Date | string | null
    stepsId?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
    tutorialId?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
    nextTutorialId?: StringNullableWithAggregatesFilter<"Tutorial"> | string | null
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    slug?: StringFilter<"Quiz"> | string
    isTimed?: BoolFilter<"Quiz"> | boolean
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    maxScore?: IntFilter<"Quiz"> | number
    passPercentage?: IntFilter<"Quiz"> | number
    difficulty?: EnumDifficultyLevelFilter<"Quiz"> | $Enums.DifficultyLevel
    order?: IntNullableFilter<"Quiz"> | number | null
    tutorialLocked?: BoolNullableFilter<"Quiz"> | boolean | null
    questionCount?: IntNullableFilter<"Quiz"> | number | null
    estimatedDuration?: IntNullableFilter<"Quiz"> | number | null
    tutorialId?: StringFilter<"Quiz"> | string
    stepsId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    questions?: QuizQuestionListRelationFilter
    attempts?: UserQuizAttemptListRelationFilter
    tutorial?: XOR<TutorialScalarRelationFilter, TutorialWhereInput>
    tags?: TagListRelationFilter
    steps?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    lastActivities?: LastActivityListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    isTimed?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    difficulty?: SortOrder
    order?: SortOrderInput | SortOrder
    tutorialLocked?: SortOrderInput | SortOrder
    questionCount?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    tutorialId?: SortOrder
    stepsId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    questions?: QuizQuestionOrderByRelationAggregateInput
    attempts?: UserQuizAttemptOrderByRelationAggregateInput
    tutorial?: TutorialOrderByWithRelationInput
    tags?: TagOrderByRelationAggregateInput
    steps?: RoadmapStepOrderByWithRelationInput
    lastActivities?: LastActivityOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    slug_tutorialId?: QuizSlugTutorialIdCompoundUniqueInput
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    title?: StringFilter<"Quiz"> | string
    isTimed?: BoolFilter<"Quiz"> | boolean
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    maxScore?: IntFilter<"Quiz"> | number
    passPercentage?: IntFilter<"Quiz"> | number
    difficulty?: EnumDifficultyLevelFilter<"Quiz"> | $Enums.DifficultyLevel
    order?: IntNullableFilter<"Quiz"> | number | null
    tutorialLocked?: BoolNullableFilter<"Quiz"> | boolean | null
    questionCount?: IntNullableFilter<"Quiz"> | number | null
    estimatedDuration?: IntNullableFilter<"Quiz"> | number | null
    tutorialId?: StringFilter<"Quiz"> | string
    stepsId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    questions?: QuizQuestionListRelationFilter
    attempts?: UserQuizAttemptListRelationFilter
    tutorial?: XOR<TutorialScalarRelationFilter, TutorialWhereInput>
    tags?: TagListRelationFilter
    steps?: XOR<RoadmapStepNullableScalarRelationFilter, RoadmapStepWhereInput> | null
    lastActivities?: LastActivityListRelationFilter
  }, "id" | "slug" | "slug_tutorialId">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    isTimed?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    difficulty?: SortOrder
    order?: SortOrderInput | SortOrder
    tutorialLocked?: SortOrderInput | SortOrder
    questionCount?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    tutorialId?: SortOrder
    stepsId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    title?: StringWithAggregatesFilter<"Quiz"> | string
    slug?: StringWithAggregatesFilter<"Quiz"> | string
    isTimed?: BoolWithAggregatesFilter<"Quiz"> | boolean
    timeLimit?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    maxScore?: IntWithAggregatesFilter<"Quiz"> | number
    passPercentage?: IntWithAggregatesFilter<"Quiz"> | number
    difficulty?: EnumDifficultyLevelWithAggregatesFilter<"Quiz"> | $Enums.DifficultyLevel
    order?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    tutorialLocked?: BoolNullableWithAggregatesFilter<"Quiz"> | boolean | null
    questionCount?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Quiz"> | number | null
    tutorialId?: StringWithAggregatesFilter<"Quiz"> | string
    stepsId?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    questionText?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    xp?: IntFilter<"QuizQuestion"> | number
    quizId?: StringFilter<"QuizQuestion"> | string
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    xp?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    quizId_questionText?: QuizQuestionQuizIdQuestionTextCompoundUniqueInput
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    questionText?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    xp?: IntFilter<"QuizQuestion"> | number
    quizId?: StringFilter<"QuizQuestion"> | string
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id" | "quizId_questionText">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    xp?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    questionText?: StringWithAggregatesFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringWithAggregatesFilter<"QuizQuestion"> | string
    xp?: IntWithAggregatesFilter<"QuizQuestion"> | number
    quizId?: StringWithAggregatesFilter<"QuizQuestion"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
  }

  export type AdminActivityLogWhereInput = {
    AND?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    OR?: AdminActivityLogWhereInput[]
    NOT?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    id?: StringFilter<"AdminActivityLog"> | string
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    target?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringFilter<"AdminActivityLog"> | string
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AdminActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    timestamp?: SortOrder
    admin?: UserOrderByWithRelationInput
  }

  export type AdminActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    OR?: AdminActivityLogWhereInput[]
    NOT?: AdminActivityLogWhereInput | AdminActivityLogWhereInput[]
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    target?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringFilter<"AdminActivityLog"> | string
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
    admin?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AdminActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    timestamp?: SortOrder
    _count?: AdminActivityLogCountOrderByAggregateInput
    _max?: AdminActivityLogMaxOrderByAggregateInput
    _min?: AdminActivityLogMinOrderByAggregateInput
  }

  export type AdminActivityLogScalarWhereWithAggregatesInput = {
    AND?: AdminActivityLogScalarWhereWithAggregatesInput | AdminActivityLogScalarWhereWithAggregatesInput[]
    OR?: AdminActivityLogScalarWhereWithAggregatesInput[]
    NOT?: AdminActivityLogScalarWhereWithAggregatesInput | AdminActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    adminId?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    action?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    target?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    targetId?: StringWithAggregatesFilter<"AdminActivityLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AdminActivityLog"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    usageCount?: IntFilter<"Tag"> | number
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    quizzes?: QuizListRelationFilter
    tutorials?: TutorialListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    usageCount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizzes?: QuizOrderByRelationAggregateInput
    tutorials?: TutorialOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    usageCount?: IntFilter<"Tag"> | number
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    quizzes?: QuizListRelationFilter
    tutorials?: TutorialListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    usageCount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    usageCount?: IntWithAggregatesFilter<"Tag"> | number
    type?: EnumTagTypeWithAggregatesFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProfileCreateInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUpdateInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileCreateManyInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
  }

  export type UserProfileUpdateManyMutationInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
  }

  export type UserProfileUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
  }

  export type UserProgressCreateInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutProgressInput
    tutorial: TutorialCreateNestedOneWithoutProgressInput
    userQuizAttempt?: UserQuizAttemptCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserProgressUpdateInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutProgressNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutProgressNestedInput
    userQuizAttempt?: UserQuizAttemptUpdateOneWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressCreateManyInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserProgressUpdateManyMutationInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserStreakCreateInput = {
    streak?: number
    streakDays?: number
    lastLogin?: Date | string | null
    currentStart?: Date | string | null
    currentEnd?: Date | string | null
    longestStreak?: number
    longestStart?: Date | string | null
    longestEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutStreaksInput
  }

  export type UserStreakUncheckedCreateInput = {
    profileId: string
    streak?: number
    streakDays?: number
    lastLogin?: Date | string | null
    currentStart?: Date | string | null
    currentEnd?: Date | string | null
    longestStreak?: number
    longestStart?: Date | string | null
    longestEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStreakUpdateInput = {
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutStreaksNestedInput
  }

  export type UserStreakUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStreakCreateManyInput = {
    profileId: string
    streak?: number
    streakDays?: number
    lastLogin?: Date | string | null
    currentStart?: Date | string | null
    currentEnd?: Date | string | null
    longestStreak?: number
    longestStart?: Date | string | null
    longestEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStreakUpdateManyMutationInput = {
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStreakUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuizAttemptCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    questionAttempts?: UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    questionAttempts?: UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    questionAttempts?: UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    questionAttempts?: UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptCreateManyInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserQuizAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuizAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserQuestionAttemptCreateInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizAttempts: UserQuizAttemptCreateNestedOneWithoutQuestionAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuestionAttemptInput
  }

  export type UserQuestionAttemptUncheckedCreateInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    userQuizAttemptId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuestionAttemptInput
  }

  export type UserQuestionAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAttempts?: UserQuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuestionAttemptNestedInput
  }

  export type UserQuestionAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    userQuizAttemptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuestionAttemptNestedInput
  }

  export type UserQuestionAttemptCreateManyInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    userQuizAttemptId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuestionAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestionAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    userQuizAttemptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityCreateInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type LastActivityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBadgeCreateInput = {
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutUserBadgesInput
    badge: BadgeCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateInput = {
    badgeId: string
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserBadgeUpdateInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutUserBadgesNestedInput
    badge?: BadgeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserBadgeCreateManyInput = {
    badgeId: string
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserBadgeUpdateManyMutationInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type BadgeCreateInput = {
    id?: string
    name: string
    imageUrl: string
    xpReq?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    badges?: UserBadgeCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUncheckedCreateInput = {
    id?: string
    name: string
    imageUrl: string
    xpReq?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    badges?: UserBadgeUncheckedCreateNestedManyWithoutBadgeInput
  }

  export type BadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: UserBadgeUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badges?: UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput
  }

  export type BadgeCreateManyInput = {
    id?: string
    name: string
    imageUrl: string
    xpReq?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinWalletCreateInput = {
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutCoinWalletInput
  }

  export type CoinWalletUncheckedCreateInput = {
    profileId: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinWalletUpdateInput = {
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutCoinWalletNestedInput
  }

  export type CoinWalletUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinWalletCreateManyInput = {
    profileId: string
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinWalletUpdateManyMutationInput = {
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinWalletUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinTransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutCoinTransactionInput
  }

  export type CoinTransactionUncheckedCreateInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type CoinTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutCoinTransactionNestedInput
  }

  export type CoinTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type CoinTransactionCreateManyInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type CoinTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutRoadmapsInput
    steps?: RoadmapStepCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
    steps?: RoadmapStepUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: RoadmapStepUncheckedUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoadmapProgressCreateInput = {
    id?: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoadmapProgressInput
    roadmap: RoadmapCreateNestedOneWithoutRoadmapProgressInput
  }

  export type RoadmapProgressUncheckedCreateInput = {
    id?: string
    userId: string
    roadmapId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoadmapProgressNestedInput
    roadmap?: RoadmapUpdateOneRequiredWithoutRoadmapProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressCreateManyInput = {
    id?: string
    userId: string
    roadmapId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapStepCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
  }

  export type RoadmapStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutorialCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
  }

  export type TutorialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TutorialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizCreateInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizQuestionCreateInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    quizId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    quizId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    quizId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    quizId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogCreateInput = {
    id?: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
    admin: UserCreateNestedOneWithoutAdminActivityLogsInput
  }

  export type AdminActivityLogUncheckedCreateInput = {
    id?: string
    adminId: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
  }

  export type AdminActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    admin?: UserUpdateOneRequiredWithoutAdminActivityLogsNestedInput
  }

  export type AdminActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogCreateManyInput = {
    id?: string
    adminId: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
  }

  export type AdminActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    adminId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizCreateNestedManyWithoutTagsInput
    tutorials?: TutorialCreateNestedManyWithoutTutorialTagsInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutTagsInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialTagsInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUpdateManyWithoutTagsNestedInput
    tutorials?: TutorialUpdateManyWithoutTutorialTagsNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutTagsNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutTutorialTagsNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProfileNullableScalarRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type RoadmapListRelationFilter = {
    every?: RoadmapWhereInput
    some?: RoadmapWhereInput
    none?: RoadmapWhereInput
  }

  export type RoadmapProgressListRelationFilter = {
    every?: RoadmapProgressWhereInput
    some?: RoadmapProgressWhereInput
    none?: RoadmapProgressWhereInput
  }

  export type AdminActivityLogListRelationFilter = {
    every?: AdminActivityLogWhereInput
    some?: AdminActivityLogWhereInput
    none?: AdminActivityLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RoadmapOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    failedAttempts?: SortOrder
    lockedUntil?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    emailVerified?: SortOrder
    verificationToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    failedAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumThemeNameFilter<$PrismaModel = never> = {
    equals?: $Enums.ThemeName | EnumThemeNameFieldRefInput<$PrismaModel>
    in?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeNameFilter<$PrismaModel> | $Enums.ThemeName
  }

  export type CoinWalletNullableScalarRelationFilter = {
    is?: CoinWalletWhereInput | null
    isNot?: CoinWalletWhereInput | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CoinTransactionListRelationFilter = {
    every?: CoinTransactionWhereInput
    some?: CoinTransactionWhereInput
    none?: CoinTransactionWhereInput
  }

  export type LastActivityListRelationFilter = {
    every?: LastActivityWhereInput
    some?: LastActivityWhereInput
    none?: LastActivityWhereInput
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type UserQuizAttemptListRelationFilter = {
    every?: UserQuizAttemptWhereInput
    some?: UserQuizAttemptWhereInput
    none?: UserQuizAttemptWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type UserStreakNullableScalarRelationFilter = {
    is?: UserStreakWhereInput | null
    isNot?: UserStreakWhereInput | null
  }

  export type CoinTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LastActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    socialLinks?: SortOrder
    avatar?: SortOrder
    rank?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLogin?: SortOrder
    completedQuizzes?: SortOrder
    completedTutorials?: SortOrder
    completedRoadmaps?: SortOrder
    completedSteps?: SortOrder
    completedChallenges?: SortOrder
    completedInterviews?: SortOrder
    completedProjects?: SortOrder
    theme?: SortOrder
  }

  export type UserProfileAvgOrderByAggregateInput = {
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    avatar?: SortOrder
    rank?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLogin?: SortOrder
    theme?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    userId?: SortOrder
    bio?: SortOrder
    location?: SortOrder
    website?: SortOrder
    avatar?: SortOrder
    rank?: SortOrder
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    lastLogin?: SortOrder
    theme?: SortOrder
  }

  export type UserProfileSumOrderByAggregateInput = {
    level?: SortOrder
    xp?: SortOrder
    levelProgress?: SortOrder
    levelProgressMax?: SortOrder
  }

  export type EnumThemeNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThemeName | EnumThemeNameFieldRefInput<$PrismaModel>
    in?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeNameWithAggregatesFilter<$PrismaModel> | $Enums.ThemeName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeNameFilter<$PrismaModel>
    _max?: NestedEnumThemeNameFilter<$PrismaModel>
  }

  export type UserProfileScalarRelationFilter = {
    is?: UserProfileWhereInput
    isNot?: UserProfileWhereInput
  }

  export type TutorialScalarRelationFilter = {
    is?: TutorialWhereInput
    isNot?: TutorialWhereInput
  }

  export type UserQuizAttemptNullableScalarRelationFilter = {
    is?: UserQuizAttemptWhereInput | null
    isNot?: UserQuizAttemptWhereInput | null
  }

  export type UserProgressProfileIdTutorialIdCompoundUniqueInput = {
    profileId: string
    tutorialId: string
  }

  export type UserProgressCountOrderByAggregateInput = {
    tutorialId?: SortOrder
    bestAttemptId?: SortOrder
    lastAttemptId?: SortOrder
    userQuizAttemptId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
    interviewCompleted?: SortOrder
    challengeCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserProgressAvgOrderByAggregateInput = {
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    tutorialId?: SortOrder
    bestAttemptId?: SortOrder
    lastAttemptId?: SortOrder
    userQuizAttemptId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
    interviewCompleted?: SortOrder
    challengeCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    tutorialId?: SortOrder
    bestAttemptId?: SortOrder
    lastAttemptId?: SortOrder
    userQuizAttemptId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
    interviewCompleted?: SortOrder
    challengeCompleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserProgressSumOrderByAggregateInput = {
    attempts?: SortOrder
    bestScore?: SortOrder
    percentageCompleted?: SortOrder
  }

  export type UserStreakCountOrderByAggregateInput = {
    profileId?: SortOrder
    streak?: SortOrder
    streakDays?: SortOrder
    lastLogin?: SortOrder
    currentStart?: SortOrder
    currentEnd?: SortOrder
    longestStreak?: SortOrder
    longestStart?: SortOrder
    longestEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStreakAvgOrderByAggregateInput = {
    streak?: SortOrder
    streakDays?: SortOrder
    longestStreak?: SortOrder
  }

  export type UserStreakMaxOrderByAggregateInput = {
    profileId?: SortOrder
    streak?: SortOrder
    streakDays?: SortOrder
    lastLogin?: SortOrder
    currentStart?: SortOrder
    currentEnd?: SortOrder
    longestStreak?: SortOrder
    longestStart?: SortOrder
    longestEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStreakMinOrderByAggregateInput = {
    profileId?: SortOrder
    streak?: SortOrder
    streakDays?: SortOrder
    lastLogin?: SortOrder
    currentStart?: SortOrder
    currentEnd?: SortOrder
    longestStreak?: SortOrder
    longestStart?: SortOrder
    longestEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserStreakSumOrderByAggregateInput = {
    streak?: SortOrder
    streakDays?: SortOrder
    longestStreak?: SortOrder
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type UserQuestionAttemptListRelationFilter = {
    every?: UserQuestionAttemptWhereInput
    some?: UserQuestionAttemptWhereInput
    none?: UserQuestionAttemptWhereInput
  }

  export type UserQuestionAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserQuizAttemptProfileIdQuizIdCompoundUniqueInput = {
    profileId: string
    quizId: string
  }

  export type UserQuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    isPassed?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserQuizAttemptAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserQuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    isPassed?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserQuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    score?: SortOrder
    isPassed?: SortOrder
    feedback?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserQuizAttemptSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type UserQuizAttemptScalarRelationFilter = {
    is?: UserQuizAttemptWhereInput
    isNot?: UserQuizAttemptWhereInput
  }

  export type UserQuestionAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    xpEarned?: SortOrder
    userQuizAttemptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuestionAttemptAvgOrderByAggregateInput = {
    xpEarned?: SortOrder
  }

  export type UserQuestionAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    xpEarned?: SortOrder
    userQuizAttemptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuestionAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    selectedOption?: SortOrder
    isCorrect?: SortOrder
    xpEarned?: SortOrder
    userQuizAttemptId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserQuestionAttemptSumOrderByAggregateInput = {
    xpEarned?: SortOrder
  }

  export type EnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type QuizNullableScalarRelationFilter = {
    is?: QuizWhereInput | null
    isNot?: QuizWhereInput | null
  }

  export type TutorialNullableScalarRelationFilter = {
    is?: TutorialWhereInput | null
    isNot?: TutorialWhereInput | null
  }

  export type RoadmapNullableScalarRelationFilter = {
    is?: RoadmapWhereInput | null
    isNot?: RoadmapWhereInput | null
  }

  export type RoadmapStepNullableScalarRelationFilter = {
    is?: RoadmapStepWhereInput | null
    isNot?: RoadmapStepWhereInput | null
  }

  export type UserQuestionAttemptNullableScalarRelationFilter = {
    is?: UserQuestionAttemptWhereInput | null
    isNot?: UserQuestionAttemptWhereInput | null
  }

  export type UserProfileListRelationFilter = {
    every?: UserProfileWhereInput
    some?: UserProfileWhereInput
    none?: UserProfileWhereInput
  }

  export type UserProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LastActivityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizId?: SortOrder
    tutorialId?: SortOrder
    roadmapId?: SortOrder
    roadmapStepId?: SortOrder
    quizAttemptId?: SortOrder
    questionAttemptId?: SortOrder
  }

  export type LastActivityAvgOrderByAggregateInput = {
    xpAwarded?: SortOrder
  }

  export type LastActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizId?: SortOrder
    tutorialId?: SortOrder
    roadmapId?: SortOrder
    roadmapStepId?: SortOrder
    quizAttemptId?: SortOrder
    questionAttemptId?: SortOrder
  }

  export type LastActivityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    description?: SortOrder
    xpAwarded?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    quizId?: SortOrder
    tutorialId?: SortOrder
    roadmapId?: SortOrder
    roadmapStepId?: SortOrder
    quizAttemptId?: SortOrder
    questionAttemptId?: SortOrder
  }

  export type LastActivitySumOrderByAggregateInput = {
    xpAwarded?: SortOrder
  }

  export type EnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BadgeScalarRelationFilter = {
    is?: BadgeWhereInput
    isNot?: BadgeWhereInput
  }

  export type UserBadgeProfileIdBadgeIdCompoundUniqueInput = {
    profileId: string
    badgeId: string
  }

  export type UserBadgeCountOrderByAggregateInput = {
    badgeId?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    badgeId?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    badgeId?: SortOrder
    earnedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type BadgeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    xpReq?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeAvgOrderByAggregateInput = {
    xpReq?: SortOrder
  }

  export type BadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    xpReq?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    xpReq?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BadgeSumOrderByAggregateInput = {
    xpReq?: SortOrder
  }

  export type CoinWalletCountOrderByAggregateInput = {
    profileId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoinWalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type CoinWalletMaxOrderByAggregateInput = {
    profileId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoinWalletMinOrderByAggregateInput = {
    profileId?: SortOrder
    balance?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoinWalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type CoinTransactionProfileIdTransactionAtCompoundUniqueInput = {
    profileId: string
    transactionAt: Date | string
  }

  export type CoinTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type CoinTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type CoinTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type CoinTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    transactionAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profileId?: SortOrder
  }

  export type CoinTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumRoadmapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadmapType | EnumRoadmapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadmapTypeFilter<$PrismaModel> | $Enums.RoadmapType
  }

  export type RoadmapStepListRelationFilter = {
    every?: RoadmapStepWhereInput
    some?: RoadmapStepWhereInput
    none?: RoadmapStepWhereInput
  }

  export type RoadmapStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    type?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumRoadmapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadmapType | EnumRoadmapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadmapTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoadmapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoadmapTypeFilter<$PrismaModel>
    _max?: NestedEnumRoadmapTypeFilter<$PrismaModel>
  }

  export type RoadmapScalarRelationFilter = {
    is?: RoadmapWhereInput
    isNot?: RoadmapWhereInput
  }

  export type RoadmapProgressUserIdRoadmapIdCompoundUniqueInput = {
    userId: string
    roadmapId: string
  }

  export type RoadmapProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapProgressAvgOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type RoadmapProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapProgressSumOrderByAggregateInput = {
    progress?: SortOrder
  }

  export type EnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type TutorialListRelationFilter = {
    every?: TutorialWhereInput
    some?: TutorialWhereInput
    none?: TutorialWhereInput
  }

  export type QuizListRelationFilter = {
    every?: QuizWhereInput
    some?: QuizWhereInput
    none?: QuizWhereInput
  }

  export type TutorialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapStepCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    roadmapId?: SortOrder
  }

  export type RoadmapStepAvgOrderByAggregateInput = {
    order?: SortOrder
    progress?: SortOrder
  }

  export type RoadmapStepMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    roadmapId?: SortOrder
  }

  export type RoadmapStepMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    status?: SortOrder
    progress?: SortOrder
    completedAt?: SortOrder
    completed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentId?: SortOrder
    roadmapId?: SortOrder
  }

  export type RoadmapStepSumOrderByAggregateInput = {
    order?: SortOrder
    progress?: SortOrder
  }

  export type EnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type EnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }

  export type EnumTutorialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutorialStatus | EnumTutorialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutorialStatusFilter<$PrismaModel> | $Enums.TutorialStatus
  }

  export type TagListRelationFilter = {
    every?: TagWhereInput
    some?: TagWhereInput
    none?: TagWhereInput
  }

  export type TagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutorialCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isLocked?: SortOrder
    cost?: SortOrder
    hasChallenge?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    stepsId?: SortOrder
    tutorialId?: SortOrder
    nextTutorialId?: SortOrder
  }

  export type TutorialAvgOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
    cost?: SortOrder
  }

  export type TutorialMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isLocked?: SortOrder
    cost?: SortOrder
    hasChallenge?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    stepsId?: SortOrder
    tutorialId?: SortOrder
    nextTutorialId?: SortOrder
  }

  export type TutorialMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    likes?: SortOrder
    views?: SortOrder
    isLocked?: SortOrder
    cost?: SortOrder
    hasChallenge?: SortOrder
    difficulty?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    stepsId?: SortOrder
    tutorialId?: SortOrder
    nextTutorialId?: SortOrder
  }

  export type TutorialSumOrderByAggregateInput = {
    likes?: SortOrder
    views?: SortOrder
    cost?: SortOrder
  }

  export type EnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type EnumTutorialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutorialStatus | EnumTutorialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutorialStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutorialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutorialStatusFilter<$PrismaModel>
    _max?: NestedEnumTutorialStatusFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizSlugTutorialIdCompoundUniqueInput = {
    slug: string
    tutorialId: string
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    isTimed?: SortOrder
    timeLimit?: SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    tutorialLocked?: SortOrder
    questionCount?: SortOrder
    estimatedDuration?: SortOrder
    tutorialId?: SortOrder
    stepsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    order?: SortOrder
    questionCount?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    isTimed?: SortOrder
    timeLimit?: SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    tutorialLocked?: SortOrder
    questionCount?: SortOrder
    estimatedDuration?: SortOrder
    tutorialId?: SortOrder
    stepsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    isTimed?: SortOrder
    timeLimit?: SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    tutorialLocked?: SortOrder
    questionCount?: SortOrder
    estimatedDuration?: SortOrder
    tutorialId?: SortOrder
    stepsId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    timeLimit?: SortOrder
    maxScore?: SortOrder
    passPercentage?: SortOrder
    order?: SortOrder
    questionCount?: SortOrder
    estimatedDuration?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type QuizQuestionQuizIdQuestionTextCompoundUniqueInput = {
    quizId: string
    questionText: string
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    xp?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    xp?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    correctAnswer?: SortOrder
    xp?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    questionText?: SortOrder
    correctAnswer?: SortOrder
    xp?: SortOrder
    quizId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    xp?: SortOrder
  }

  export type AdminActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    timestamp?: SortOrder
  }

  export type AdminActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    adminId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    usageCount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    usageCount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    usageCount?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type EnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type RoadmapCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput> | RoadmapCreateWithoutCreatedByInput[] | RoadmapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutCreatedByInput | RoadmapCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoadmapCreateManyCreatedByInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type RoadmapProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput> | RoadmapProgressCreateWithoutUserInput[] | RoadmapProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutUserInput | RoadmapProgressCreateOrConnectWithoutUserInput[]
    createMany?: RoadmapProgressCreateManyUserInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type AdminActivityLogCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type RoadmapUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput> | RoadmapCreateWithoutCreatedByInput[] | RoadmapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutCreatedByInput | RoadmapCreateOrConnectWithoutCreatedByInput[]
    createMany?: RoadmapCreateManyCreatedByInputEnvelope
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
  }

  export type RoadmapProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput> | RoadmapProgressCreateWithoutUserInput[] | RoadmapProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutUserInput | RoadmapProgressCreateOrConnectWithoutUserInput[]
    createMany?: RoadmapProgressCreateManyUserInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type RoadmapUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput> | RoadmapCreateWithoutCreatedByInput[] | RoadmapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutCreatedByInput | RoadmapCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutCreatedByInput | RoadmapUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoadmapCreateManyCreatedByInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutCreatedByInput | RoadmapUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutCreatedByInput | RoadmapUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type RoadmapProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput> | RoadmapProgressCreateWithoutUserInput[] | RoadmapProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutUserInput | RoadmapProgressCreateOrConnectWithoutUserInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutUserInput | RoadmapProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoadmapProgressCreateManyUserInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutUserInput | RoadmapProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutUserInput | RoadmapProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type AdminActivityLogUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput | AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    set?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    disconnect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    delete?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    update?: AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput | AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActivityLogUpdateManyWithWhereWithoutAdminInput | AdminActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type RoadmapUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput> | RoadmapCreateWithoutCreatedByInput[] | RoadmapUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: RoadmapCreateOrConnectWithoutCreatedByInput | RoadmapCreateOrConnectWithoutCreatedByInput[]
    upsert?: RoadmapUpsertWithWhereUniqueWithoutCreatedByInput | RoadmapUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: RoadmapCreateManyCreatedByInputEnvelope
    set?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    disconnect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    delete?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    connect?: RoadmapWhereUniqueInput | RoadmapWhereUniqueInput[]
    update?: RoadmapUpdateWithWhereUniqueWithoutCreatedByInput | RoadmapUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: RoadmapUpdateManyWithWhereWithoutCreatedByInput | RoadmapUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput> | RoadmapProgressCreateWithoutUserInput[] | RoadmapProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutUserInput | RoadmapProgressCreateOrConnectWithoutUserInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutUserInput | RoadmapProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoadmapProgressCreateManyUserInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutUserInput | RoadmapProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutUserInput | RoadmapProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput = {
    create?: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput> | AdminActivityLogCreateWithoutAdminInput[] | AdminActivityLogUncheckedCreateWithoutAdminInput[]
    connectOrCreate?: AdminActivityLogCreateOrConnectWithoutAdminInput | AdminActivityLogCreateOrConnectWithoutAdminInput[]
    upsert?: AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput | AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput[]
    createMany?: AdminActivityLogCreateManyAdminInputEnvelope
    set?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    disconnect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    delete?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    connect?: AdminActivityLogWhereUniqueInput | AdminActivityLogWhereUniqueInput[]
    update?: AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput | AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput[]
    updateMany?: AdminActivityLogUpdateManyWithWhereWithoutAdminInput | AdminActivityLogUpdateManyWithWhereWithoutAdminInput[]
    deleteMany?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
  }

  export type UserProfileCreatesocialLinksInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedQuizzesInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedTutorialsInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedRoadmapsInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedStepsInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedChallengesInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedInterviewsInput = {
    set: string[]
  }

  export type UserProfileCreatecompletedProjectsInput = {
    set: string[]
  }

  export type CoinWalletCreateNestedOneWithoutProfileInput = {
    create?: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
    connectOrCreate?: CoinWalletCreateOrConnectWithoutProfileInput
    connect?: CoinWalletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type CoinTransactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput> | CoinTransactionCreateWithoutProfileInput[] | CoinTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CoinTransactionCreateOrConnectWithoutProfileInput | CoinTransactionCreateOrConnectWithoutProfileInput[]
    createMany?: CoinTransactionCreateManyProfileInputEnvelope
    connect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
  }

  export type LastActivityCreateNestedManyWithoutProfileInput = {
    create?: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput> | LastActivityCreateWithoutProfileInput[] | LastActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutProfileInput | LastActivityCreateOrConnectWithoutProfileInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput> | UserProgressCreateWithoutProfileInput[] | UserProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProfileInput | UserProgressCreateOrConnectWithoutProfileInput[]
    createMany?: UserProgressCreateManyProfileInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserQuizAttemptCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput> | UserQuizAttemptCreateWithoutProfileInput[] | UserQuizAttemptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutProfileInput | UserQuizAttemptCreateOrConnectWithoutProfileInput[]
    createMany?: UserQuizAttemptCreateManyProfileInputEnvelope
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput> | UserBadgeCreateWithoutProfileInput[] | UserBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutProfileInput | UserBadgeCreateOrConnectWithoutProfileInput[]
    createMany?: UserBadgeCreateManyProfileInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserStreakCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserStreakCreateOrConnectWithoutProfileInput
    connect?: UserStreakWhereUniqueInput
  }

  export type CoinWalletUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
    connectOrCreate?: CoinWalletCreateOrConnectWithoutProfileInput
    connect?: CoinWalletWhereUniqueInput
  }

  export type CoinTransactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput> | CoinTransactionCreateWithoutProfileInput[] | CoinTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CoinTransactionCreateOrConnectWithoutProfileInput | CoinTransactionCreateOrConnectWithoutProfileInput[]
    createMany?: CoinTransactionCreateManyProfileInputEnvelope
    connect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput> | LastActivityCreateWithoutProfileInput[] | LastActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutProfileInput | LastActivityCreateOrConnectWithoutProfileInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput> | UserProgressCreateWithoutProfileInput[] | UserProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProfileInput | UserProgressCreateOrConnectWithoutProfileInput[]
    createMany?: UserProgressCreateManyProfileInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput> | UserQuizAttemptCreateWithoutProfileInput[] | UserQuizAttemptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutProfileInput | UserQuizAttemptCreateOrConnectWithoutProfileInput[]
    createMany?: UserQuizAttemptCreateManyProfileInputEnvelope
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput> | UserBadgeCreateWithoutProfileInput[] | UserBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutProfileInput | UserBadgeCreateOrConnectWithoutProfileInput[]
    createMany?: UserBadgeCreateManyProfileInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserStreakUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserStreakCreateOrConnectWithoutProfileInput
    connect?: UserStreakWhereUniqueInput
  }

  export type UserProfileUpdatesocialLinksInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedQuizzesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedTutorialsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedRoadmapsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedStepsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedChallengesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedInterviewsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProfileUpdatecompletedProjectsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumThemeNameFieldUpdateOperationsInput = {
    set?: $Enums.ThemeName
  }

  export type CoinWalletUpdateOneWithoutProfileNestedInput = {
    create?: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
    connectOrCreate?: CoinWalletCreateOrConnectWithoutProfileInput
    upsert?: CoinWalletUpsertWithoutProfileInput
    disconnect?: CoinWalletWhereInput | boolean
    delete?: CoinWalletWhereInput | boolean
    connect?: CoinWalletWhereUniqueInput
    update?: XOR<XOR<CoinWalletUpdateToOneWithWhereWithoutProfileInput, CoinWalletUpdateWithoutProfileInput>, CoinWalletUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type CoinTransactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput> | CoinTransactionCreateWithoutProfileInput[] | CoinTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CoinTransactionCreateOrConnectWithoutProfileInput | CoinTransactionCreateOrConnectWithoutProfileInput[]
    upsert?: CoinTransactionUpsertWithWhereUniqueWithoutProfileInput | CoinTransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CoinTransactionCreateManyProfileInputEnvelope
    set?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    disconnect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    delete?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    connect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    update?: CoinTransactionUpdateWithWhereUniqueWithoutProfileInput | CoinTransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CoinTransactionUpdateManyWithWhereWithoutProfileInput | CoinTransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CoinTransactionScalarWhereInput | CoinTransactionScalarWhereInput[]
  }

  export type LastActivityUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput> | LastActivityCreateWithoutProfileInput[] | LastActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutProfileInput | LastActivityCreateOrConnectWithoutProfileInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutProfileInput | LastActivityUpsertWithWhereUniqueWithoutProfileInput[]
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutProfileInput | LastActivityUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutProfileInput | LastActivityUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput> | UserProgressCreateWithoutProfileInput[] | UserProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProfileInput | UserProgressCreateOrConnectWithoutProfileInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutProfileInput | UserProgressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserProgressCreateManyProfileInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutProfileInput | UserProgressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutProfileInput | UserProgressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserQuizAttemptUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput> | UserQuizAttemptCreateWithoutProfileInput[] | UserQuizAttemptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutProfileInput | UserQuizAttemptCreateOrConnectWithoutProfileInput[]
    upsert?: UserQuizAttemptUpsertWithWhereUniqueWithoutProfileInput | UserQuizAttemptUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserQuizAttemptCreateManyProfileInputEnvelope
    set?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    disconnect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    delete?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    update?: UserQuizAttemptUpdateWithWhereUniqueWithoutProfileInput | UserQuizAttemptUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserQuizAttemptUpdateManyWithWhereWithoutProfileInput | UserQuizAttemptUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput> | UserBadgeCreateWithoutProfileInput[] | UserBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutProfileInput | UserBadgeCreateOrConnectWithoutProfileInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutProfileInput | UserBadgeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserBadgeCreateManyProfileInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutProfileInput | UserBadgeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutProfileInput | UserBadgeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserStreakUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserStreakCreateOrConnectWithoutProfileInput
    upsert?: UserStreakUpsertWithoutProfileInput
    disconnect?: UserStreakWhereInput | boolean
    delete?: UserStreakWhereInput | boolean
    connect?: UserStreakWhereUniqueInput
    update?: XOR<XOR<UserStreakUpdateToOneWithWhereWithoutProfileInput, UserStreakUpdateWithoutProfileInput>, UserStreakUncheckedUpdateWithoutProfileInput>
  }

  export type CoinWalletUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
    connectOrCreate?: CoinWalletCreateOrConnectWithoutProfileInput
    upsert?: CoinWalletUpsertWithoutProfileInput
    disconnect?: CoinWalletWhereInput | boolean
    delete?: CoinWalletWhereInput | boolean
    connect?: CoinWalletWhereUniqueInput
    update?: XOR<XOR<CoinWalletUpdateToOneWithWhereWithoutProfileInput, CoinWalletUpdateWithoutProfileInput>, CoinWalletUncheckedUpdateWithoutProfileInput>
  }

  export type CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput> | CoinTransactionCreateWithoutProfileInput[] | CoinTransactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CoinTransactionCreateOrConnectWithoutProfileInput | CoinTransactionCreateOrConnectWithoutProfileInput[]
    upsert?: CoinTransactionUpsertWithWhereUniqueWithoutProfileInput | CoinTransactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CoinTransactionCreateManyProfileInputEnvelope
    set?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    disconnect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    delete?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    connect?: CoinTransactionWhereUniqueInput | CoinTransactionWhereUniqueInput[]
    update?: CoinTransactionUpdateWithWhereUniqueWithoutProfileInput | CoinTransactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CoinTransactionUpdateManyWithWhereWithoutProfileInput | CoinTransactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CoinTransactionScalarWhereInput | CoinTransactionScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput> | LastActivityCreateWithoutProfileInput[] | LastActivityUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutProfileInput | LastActivityCreateOrConnectWithoutProfileInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutProfileInput | LastActivityUpsertWithWhereUniqueWithoutProfileInput[]
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutProfileInput | LastActivityUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutProfileInput | LastActivityUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput> | UserProgressCreateWithoutProfileInput[] | UserProgressUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProfileInput | UserProgressCreateOrConnectWithoutProfileInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutProfileInput | UserProgressUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserProgressCreateManyProfileInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutProfileInput | UserProgressUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutProfileInput | UserProgressUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput> | UserQuizAttemptCreateWithoutProfileInput[] | UserQuizAttemptUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutProfileInput | UserQuizAttemptCreateOrConnectWithoutProfileInput[]
    upsert?: UserQuizAttemptUpsertWithWhereUniqueWithoutProfileInput | UserQuizAttemptUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserQuizAttemptCreateManyProfileInputEnvelope
    set?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    disconnect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    delete?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    update?: UserQuizAttemptUpdateWithWhereUniqueWithoutProfileInput | UserQuizAttemptUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserQuizAttemptUpdateManyWithWhereWithoutProfileInput | UserQuizAttemptUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput> | UserBadgeCreateWithoutProfileInput[] | UserBadgeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutProfileInput | UserBadgeCreateOrConnectWithoutProfileInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutProfileInput | UserBadgeUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: UserBadgeCreateManyProfileInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutProfileInput | UserBadgeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutProfileInput | UserBadgeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserStreakUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserStreakCreateOrConnectWithoutProfileInput
    upsert?: UserStreakUpsertWithoutProfileInput
    disconnect?: UserStreakWhereInput | boolean
    delete?: UserStreakWhereInput | boolean
    connect?: UserStreakWhereUniqueInput
    update?: XOR<XOR<UserStreakUpdateToOneWithWhereWithoutProfileInput, UserStreakUpdateWithoutProfileInput>, UserStreakUncheckedUpdateWithoutProfileInput>
  }

  export type UserProfileCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserProfileCreateWithoutProgressInput, UserProfileUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutProgressInput
    connect?: UserProfileWhereUniqueInput
  }

  export type TutorialCreateNestedOneWithoutProgressInput = {
    create?: XOR<TutorialCreateWithoutProgressInput, TutorialUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutProgressInput
    connect?: TutorialWhereUniqueInput
  }

  export type UserQuizAttemptCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<UserQuizAttemptCreateWithoutUserProgressInput, UserQuizAttemptUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutUserProgressInput
    connect?: UserQuizAttemptWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserProfileCreateWithoutProgressInput, UserProfileUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutProgressInput
    upsert?: UserProfileUpsertWithoutProgressInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutProgressInput, UserProfileUpdateWithoutProgressInput>, UserProfileUncheckedUpdateWithoutProgressInput>
  }

  export type TutorialUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<TutorialCreateWithoutProgressInput, TutorialUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutProgressInput
    upsert?: TutorialUpsertWithoutProgressInput
    connect?: TutorialWhereUniqueInput
    update?: XOR<XOR<TutorialUpdateToOneWithWhereWithoutProgressInput, TutorialUpdateWithoutProgressInput>, TutorialUncheckedUpdateWithoutProgressInput>
  }

  export type UserQuizAttemptUpdateOneWithoutUserProgressNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutUserProgressInput, UserQuizAttemptUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutUserProgressInput
    upsert?: UserQuizAttemptUpsertWithoutUserProgressInput
    disconnect?: UserQuizAttemptWhereInput | boolean
    delete?: UserQuizAttemptWhereInput | boolean
    connect?: UserQuizAttemptWhereUniqueInput
    update?: XOR<XOR<UserQuizAttemptUpdateToOneWithWhereWithoutUserProgressInput, UserQuizAttemptUpdateWithoutUserProgressInput>, UserQuizAttemptUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserProfileCreateNestedOneWithoutStreaksInput = {
    create?: XOR<UserProfileCreateWithoutStreaksInput, UserProfileUncheckedCreateWithoutStreaksInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutStreaksInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutStreaksNestedInput = {
    create?: XOR<UserProfileCreateWithoutStreaksInput, UserProfileUncheckedCreateWithoutStreaksInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutStreaksInput
    upsert?: UserProfileUpsertWithoutStreaksInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutStreaksInput, UserProfileUpdateWithoutStreaksInput>, UserProfileUncheckedUpdateWithoutStreaksInput>
  }

  export type UserProfileCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UserProfileCreateWithoutQuizAttemptsInput, UserProfileUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutQuizAttemptsInput
    connect?: UserProfileWhereUniqueInput
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput> | UserQuestionAttemptCreateWithoutQuizAttemptsInput[] | UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput | UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput[]
    createMany?: UserQuestionAttemptCreateManyQuizAttemptsInputEnvelope
    connect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
  }

  export type LastActivityCreateNestedManyWithoutQuizAttemptInput = {
    create?: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput> | LastActivityCreateWithoutQuizAttemptInput[] | LastActivityUncheckedCreateWithoutQuizAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizAttemptInput | LastActivityCreateOrConnectWithoutQuizAttemptInput[]
    createMany?: LastActivityCreateManyQuizAttemptInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutUserQuizAttemptInput = {
    create?: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput> | UserProgressCreateWithoutUserQuizAttemptInput[] | UserProgressUncheckedCreateWithoutUserQuizAttemptInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserQuizAttemptInput | UserProgressCreateOrConnectWithoutUserQuizAttemptInput[]
    createMany?: UserProgressCreateManyUserQuizAttemptInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput> | UserQuestionAttemptCreateWithoutQuizAttemptsInput[] | UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput | UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput[]
    createMany?: UserQuestionAttemptCreateManyQuizAttemptsInputEnvelope
    connect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput = {
    create?: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput> | LastActivityCreateWithoutQuizAttemptInput[] | LastActivityUncheckedCreateWithoutQuizAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizAttemptInput | LastActivityCreateOrConnectWithoutQuizAttemptInput[]
    createMany?: LastActivityCreateManyQuizAttemptInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput = {
    create?: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput> | UserProgressCreateWithoutUserQuizAttemptInput[] | UserProgressUncheckedCreateWithoutUserQuizAttemptInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserQuizAttemptInput | UserProgressCreateOrConnectWithoutUserQuizAttemptInput[]
    createMany?: UserProgressCreateManyUserQuizAttemptInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserProfileCreateWithoutQuizAttemptsInput, UserProfileUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UserProfileUpsertWithoutQuizAttemptsInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutQuizAttemptsInput, UserProfileUpdateWithoutQuizAttemptsInput>, UserProfileUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput> | UserQuestionAttemptCreateWithoutQuizAttemptsInput[] | UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput | UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput[]
    upsert?: UserQuestionAttemptUpsertWithWhereUniqueWithoutQuizAttemptsInput | UserQuestionAttemptUpsertWithWhereUniqueWithoutQuizAttemptsInput[]
    createMany?: UserQuestionAttemptCreateManyQuizAttemptsInputEnvelope
    set?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    disconnect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    delete?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    connect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    update?: UserQuestionAttemptUpdateWithWhereUniqueWithoutQuizAttemptsInput | UserQuestionAttemptUpdateWithWhereUniqueWithoutQuizAttemptsInput[]
    updateMany?: UserQuestionAttemptUpdateManyWithWhereWithoutQuizAttemptsInput | UserQuestionAttemptUpdateManyWithWhereWithoutQuizAttemptsInput[]
    deleteMany?: UserQuestionAttemptScalarWhereInput | UserQuestionAttemptScalarWhereInput[]
  }

  export type LastActivityUpdateManyWithoutQuizAttemptNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput> | LastActivityCreateWithoutQuizAttemptInput[] | LastActivityUncheckedCreateWithoutQuizAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizAttemptInput | LastActivityCreateOrConnectWithoutQuizAttemptInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuizAttemptInput | LastActivityUpsertWithWhereUniqueWithoutQuizAttemptInput[]
    createMany?: LastActivityCreateManyQuizAttemptInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuizAttemptInput | LastActivityUpdateWithWhereUniqueWithoutQuizAttemptInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuizAttemptInput | LastActivityUpdateManyWithWhereWithoutQuizAttemptInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutUserQuizAttemptNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput> | UserProgressCreateWithoutUserQuizAttemptInput[] | UserProgressUncheckedCreateWithoutUserQuizAttemptInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserQuizAttemptInput | UserProgressCreateOrConnectWithoutUserQuizAttemptInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserQuizAttemptInput | UserProgressUpsertWithWhereUniqueWithoutUserQuizAttemptInput[]
    createMany?: UserProgressCreateManyUserQuizAttemptInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserQuizAttemptInput | UserProgressUpdateWithWhereUniqueWithoutUserQuizAttemptInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserQuizAttemptInput | UserProgressUpdateManyWithWhereWithoutUserQuizAttemptInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput> | UserQuestionAttemptCreateWithoutQuizAttemptsInput[] | UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput[]
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput | UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput[]
    upsert?: UserQuestionAttemptUpsertWithWhereUniqueWithoutQuizAttemptsInput | UserQuestionAttemptUpsertWithWhereUniqueWithoutQuizAttemptsInput[]
    createMany?: UserQuestionAttemptCreateManyQuizAttemptsInputEnvelope
    set?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    disconnect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    delete?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    connect?: UserQuestionAttemptWhereUniqueInput | UserQuestionAttemptWhereUniqueInput[]
    update?: UserQuestionAttemptUpdateWithWhereUniqueWithoutQuizAttemptsInput | UserQuestionAttemptUpdateWithWhereUniqueWithoutQuizAttemptsInput[]
    updateMany?: UserQuestionAttemptUpdateManyWithWhereWithoutQuizAttemptsInput | UserQuestionAttemptUpdateManyWithWhereWithoutQuizAttemptsInput[]
    deleteMany?: UserQuestionAttemptScalarWhereInput | UserQuestionAttemptScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput> | LastActivityCreateWithoutQuizAttemptInput[] | LastActivityUncheckedCreateWithoutQuizAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizAttemptInput | LastActivityCreateOrConnectWithoutQuizAttemptInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuizAttemptInput | LastActivityUpsertWithWhereUniqueWithoutQuizAttemptInput[]
    createMany?: LastActivityCreateManyQuizAttemptInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuizAttemptInput | LastActivityUpdateWithWhereUniqueWithoutQuizAttemptInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuizAttemptInput | LastActivityUpdateManyWithWhereWithoutQuizAttemptInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput> | UserProgressCreateWithoutUserQuizAttemptInput[] | UserProgressUncheckedCreateWithoutUserQuizAttemptInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserQuizAttemptInput | UserProgressCreateOrConnectWithoutUserQuizAttemptInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserQuizAttemptInput | UserProgressUpsertWithWhereUniqueWithoutUserQuizAttemptInput[]
    createMany?: UserProgressCreateManyUserQuizAttemptInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserQuizAttemptInput | UserProgressUpdateWithWhereUniqueWithoutUserQuizAttemptInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserQuizAttemptInput | UserProgressUpdateManyWithWhereWithoutUserQuizAttemptInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type UserQuizAttemptCreateNestedOneWithoutQuestionAttemptsInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuestionAttemptsInput
    connect?: UserQuizAttemptWhereUniqueInput
  }

  export type LastActivityCreateNestedManyWithoutQuestionAttemptInput = {
    create?: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput> | LastActivityCreateWithoutQuestionAttemptInput[] | LastActivityUncheckedCreateWithoutQuestionAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuestionAttemptInput | LastActivityCreateOrConnectWithoutQuestionAttemptInput[]
    createMany?: LastActivityCreateManyQuestionAttemptInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutQuestionAttemptInput = {
    create?: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput> | LastActivityCreateWithoutQuestionAttemptInput[] | LastActivityUncheckedCreateWithoutQuestionAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuestionAttemptInput | LastActivityCreateOrConnectWithoutQuestionAttemptInput[]
    createMany?: LastActivityCreateManyQuestionAttemptInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type UserQuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuestionAttemptsInput
    upsert?: UserQuizAttemptUpsertWithoutQuestionAttemptsInput
    connect?: UserQuizAttemptWhereUniqueInput
    update?: XOR<XOR<UserQuizAttemptUpdateToOneWithWhereWithoutQuestionAttemptsInput, UserQuizAttemptUpdateWithoutQuestionAttemptsInput>, UserQuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type LastActivityUpdateManyWithoutQuestionAttemptNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput> | LastActivityCreateWithoutQuestionAttemptInput[] | LastActivityUncheckedCreateWithoutQuestionAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuestionAttemptInput | LastActivityCreateOrConnectWithoutQuestionAttemptInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuestionAttemptInput | LastActivityUpsertWithWhereUniqueWithoutQuestionAttemptInput[]
    createMany?: LastActivityCreateManyQuestionAttemptInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuestionAttemptInput | LastActivityUpdateWithWhereUniqueWithoutQuestionAttemptInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuestionAttemptInput | LastActivityUpdateManyWithWhereWithoutQuestionAttemptInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutQuestionAttemptNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput> | LastActivityCreateWithoutQuestionAttemptInput[] | LastActivityUncheckedCreateWithoutQuestionAttemptInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuestionAttemptInput | LastActivityCreateOrConnectWithoutQuestionAttemptInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuestionAttemptInput | LastActivityUpsertWithWhereUniqueWithoutQuestionAttemptInput[]
    createMany?: LastActivityCreateManyQuestionAttemptInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuestionAttemptInput | LastActivityUpdateWithWhereUniqueWithoutQuestionAttemptInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuestionAttemptInput | LastActivityUpdateManyWithWhereWithoutQuestionAttemptInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<QuizCreateWithoutLastActivitiesInput, QuizUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLastActivitiesInput
    connect?: QuizWhereUniqueInput
  }

  export type TutorialCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<TutorialCreateWithoutLastActivitiesInput, TutorialUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutLastActivitiesInput
    connect?: TutorialWhereUniqueInput
  }

  export type RoadmapCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<RoadmapCreateWithoutLastActivitiesInput, RoadmapUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutLastActivitiesInput
    connect?: RoadmapWhereUniqueInput
  }

  export type RoadmapStepCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<RoadmapStepCreateWithoutLastActivitiesInput, RoadmapStepUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutLastActivitiesInput
    connect?: RoadmapStepWhereUniqueInput
  }

  export type UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<UserQuizAttemptCreateWithoutLastActivitiesInput, UserQuizAttemptUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutLastActivitiesInput
    connect?: UserQuizAttemptWhereUniqueInput
  }

  export type UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutLastActivitiesInput
    connect?: UserQuestionAttemptWhereUniqueInput
  }

  export type UserProfileCreateNestedManyWithoutLastActivitiesInput = {
    create?: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput> | UserProfileCreateWithoutLastActivitiesInput[] | UserProfileUncheckedCreateWithoutLastActivitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutLastActivitiesInput | UserProfileCreateOrConnectWithoutLastActivitiesInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput = {
    create?: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput> | UserProfileCreateWithoutLastActivitiesInput[] | UserProfileUncheckedCreateWithoutLastActivitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutLastActivitiesInput | UserProfileCreateOrConnectWithoutLastActivitiesInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
  }

  export type EnumActivityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type QuizUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<QuizCreateWithoutLastActivitiesInput, QuizUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: QuizCreateOrConnectWithoutLastActivitiesInput
    upsert?: QuizUpsertWithoutLastActivitiesInput
    disconnect?: QuizWhereInput | boolean
    delete?: QuizWhereInput | boolean
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutLastActivitiesInput, QuizUpdateWithoutLastActivitiesInput>, QuizUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type TutorialUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<TutorialCreateWithoutLastActivitiesInput, TutorialUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutLastActivitiesInput
    upsert?: TutorialUpsertWithoutLastActivitiesInput
    disconnect?: TutorialWhereInput | boolean
    delete?: TutorialWhereInput | boolean
    connect?: TutorialWhereUniqueInput
    update?: XOR<XOR<TutorialUpdateToOneWithWhereWithoutLastActivitiesInput, TutorialUpdateWithoutLastActivitiesInput>, TutorialUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type RoadmapUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<RoadmapCreateWithoutLastActivitiesInput, RoadmapUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutLastActivitiesInput
    upsert?: RoadmapUpsertWithoutLastActivitiesInput
    disconnect?: RoadmapWhereInput | boolean
    delete?: RoadmapWhereInput | boolean
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutLastActivitiesInput, RoadmapUpdateWithoutLastActivitiesInput>, RoadmapUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type RoadmapStepUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutLastActivitiesInput, RoadmapStepUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutLastActivitiesInput
    upsert?: RoadmapStepUpsertWithoutLastActivitiesInput
    disconnect?: RoadmapStepWhereInput | boolean
    delete?: RoadmapStepWhereInput | boolean
    connect?: RoadmapStepWhereUniqueInput
    update?: XOR<XOR<RoadmapStepUpdateToOneWithWhereWithoutLastActivitiesInput, RoadmapStepUpdateWithoutLastActivitiesInput>, RoadmapStepUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutLastActivitiesInput, UserQuizAttemptUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutLastActivitiesInput
    upsert?: UserQuizAttemptUpsertWithoutLastActivitiesInput
    disconnect?: UserQuizAttemptWhereInput | boolean
    delete?: UserQuizAttemptWhereInput | boolean
    connect?: UserQuizAttemptWhereUniqueInput
    update?: XOR<XOR<UserQuizAttemptUpdateToOneWithWhereWithoutLastActivitiesInput, UserQuizAttemptUpdateWithoutLastActivitiesInput>, UserQuizAttemptUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput = {
    create?: XOR<UserQuestionAttemptCreateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedCreateWithoutLastActivitiesInput>
    connectOrCreate?: UserQuestionAttemptCreateOrConnectWithoutLastActivitiesInput
    upsert?: UserQuestionAttemptUpsertWithoutLastActivitiesInput
    disconnect?: UserQuestionAttemptWhereInput | boolean
    delete?: UserQuestionAttemptWhereInput | boolean
    connect?: UserQuestionAttemptWhereUniqueInput
    update?: XOR<XOR<UserQuestionAttemptUpdateToOneWithWhereWithoutLastActivitiesInput, UserQuestionAttemptUpdateWithoutLastActivitiesInput>, UserQuestionAttemptUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserProfileUpdateManyWithoutLastActivitiesNestedInput = {
    create?: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput> | UserProfileCreateWithoutLastActivitiesInput[] | UserProfileUncheckedCreateWithoutLastActivitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutLastActivitiesInput | UserProfileCreateOrConnectWithoutLastActivitiesInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutLastActivitiesInput | UserProfileUpsertWithWhereUniqueWithoutLastActivitiesInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutLastActivitiesInput | UserProfileUpdateWithWhereUniqueWithoutLastActivitiesInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutLastActivitiesInput | UserProfileUpdateManyWithWhereWithoutLastActivitiesInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput = {
    create?: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput> | UserProfileCreateWithoutLastActivitiesInput[] | UserProfileUncheckedCreateWithoutLastActivitiesInput[]
    connectOrCreate?: UserProfileCreateOrConnectWithoutLastActivitiesInput | UserProfileCreateOrConnectWithoutLastActivitiesInput[]
    upsert?: UserProfileUpsertWithWhereUniqueWithoutLastActivitiesInput | UserProfileUpsertWithWhereUniqueWithoutLastActivitiesInput[]
    set?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    disconnect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    delete?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    connect?: UserProfileWhereUniqueInput | UserProfileWhereUniqueInput[]
    update?: UserProfileUpdateWithWhereUniqueWithoutLastActivitiesInput | UserProfileUpdateWithWhereUniqueWithoutLastActivitiesInput[]
    updateMany?: UserProfileUpdateManyWithWhereWithoutLastActivitiesInput | UserProfileUpdateManyWithWhereWithoutLastActivitiesInput[]
    deleteMany?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutUserBadgesInput = {
    create?: XOR<UserProfileCreateWithoutUserBadgesInput, UserProfileUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserBadgesInput
    connect?: UserProfileWhereUniqueInput
  }

  export type BadgeCreateNestedOneWithoutBadgesInput = {
    create?: XOR<BadgeCreateWithoutBadgesInput, BadgeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgesInput
    connect?: BadgeWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutUserBadgesNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserBadgesInput, UserProfileUncheckedCreateWithoutUserBadgesInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserBadgesInput
    upsert?: UserProfileUpsertWithoutUserBadgesInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserBadgesInput, UserProfileUpdateWithoutUserBadgesInput>, UserProfileUncheckedUpdateWithoutUserBadgesInput>
  }

  export type BadgeUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<BadgeCreateWithoutBadgesInput, BadgeUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: BadgeCreateOrConnectWithoutBadgesInput
    upsert?: BadgeUpsertWithoutBadgesInput
    connect?: BadgeWhereUniqueInput
    update?: XOR<XOR<BadgeUpdateToOneWithWhereWithoutBadgesInput, BadgeUpdateWithoutBadgesInput>, BadgeUncheckedUpdateWithoutBadgesInput>
  }

  export type UserBadgeCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutBadgeInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserBadgeUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeNestedInput = {
    create?: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput> | UserBadgeCreateWithoutBadgeInput[] | UserBadgeUncheckedCreateWithoutBadgeInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutBadgeInput | UserBadgeCreateOrConnectWithoutBadgeInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutBadgeInput | UserBadgeUpsertWithWhereUniqueWithoutBadgeInput[]
    createMany?: UserBadgeCreateManyBadgeInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutBadgeInput | UserBadgeUpdateWithWhereUniqueWithoutBadgeInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutBadgeInput | UserBadgeUpdateManyWithWhereWithoutBadgeInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserProfileCreateNestedOneWithoutCoinWalletInput = {
    create?: XOR<UserProfileCreateWithoutCoinWalletInput, UserProfileUncheckedCreateWithoutCoinWalletInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCoinWalletInput
    connect?: UserProfileWhereUniqueInput
  }

  export type UserProfileUpdateOneRequiredWithoutCoinWalletNestedInput = {
    create?: XOR<UserProfileCreateWithoutCoinWalletInput, UserProfileUncheckedCreateWithoutCoinWalletInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCoinWalletInput
    upsert?: UserProfileUpsertWithoutCoinWalletInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutCoinWalletInput, UserProfileUpdateWithoutCoinWalletInput>, UserProfileUncheckedUpdateWithoutCoinWalletInput>
  }

  export type UserProfileCreateNestedOneWithoutCoinTransactionInput = {
    create?: XOR<UserProfileCreateWithoutCoinTransactionInput, UserProfileUncheckedCreateWithoutCoinTransactionInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCoinTransactionInput
    connect?: UserProfileWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type UserProfileUpdateOneRequiredWithoutCoinTransactionNestedInput = {
    create?: XOR<UserProfileCreateWithoutCoinTransactionInput, UserProfileUncheckedCreateWithoutCoinTransactionInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutCoinTransactionInput
    upsert?: UserProfileUpsertWithoutCoinTransactionInput
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutCoinTransactionInput, UserProfileUpdateWithoutCoinTransactionInput>, UserProfileUncheckedUpdateWithoutCoinTransactionInput>
  }

  export type UserCreateNestedOneWithoutRoadmapsInput = {
    create?: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapsInput
    connect?: UserWhereUniqueInput
  }

  export type RoadmapStepCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput> | RoadmapStepCreateWithoutRoadmapInput[] | RoadmapStepUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutRoadmapInput | RoadmapStepCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapStepCreateManyRoadmapInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type RoadmapProgressCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type LastActivityCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput> | LastActivityCreateWithoutRoadmapInput[] | LastActivityUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapInput | LastActivityCreateOrConnectWithoutRoadmapInput[]
    createMany?: LastActivityCreateManyRoadmapInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type RoadmapStepUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput> | RoadmapStepCreateWithoutRoadmapInput[] | RoadmapStepUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutRoadmapInput | RoadmapStepCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapStepCreateManyRoadmapInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput> | LastActivityCreateWithoutRoadmapInput[] | LastActivityUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapInput | LastActivityCreateOrConnectWithoutRoadmapInput[]
    createMany?: LastActivityCreateManyRoadmapInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type EnumRoadmapTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoadmapType
  }

  export type UserUpdateOneRequiredWithoutRoadmapsNestedInput = {
    create?: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapsInput
    upsert?: UserUpsertWithoutRoadmapsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoadmapsInput, UserUpdateWithoutRoadmapsInput>, UserUncheckedUpdateWithoutRoadmapsInput>
  }

  export type RoadmapStepUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput> | RoadmapStepCreateWithoutRoadmapInput[] | RoadmapStepUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutRoadmapInput | RoadmapStepCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapStepUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapStepCreateManyRoadmapInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapStepUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutRoadmapInput | RoadmapStepUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type RoadmapProgressUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput | RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type LastActivityUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput> | LastActivityCreateWithoutRoadmapInput[] | LastActivityUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapInput | LastActivityCreateOrConnectWithoutRoadmapInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutRoadmapInput | LastActivityUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: LastActivityCreateManyRoadmapInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutRoadmapInput | LastActivityUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutRoadmapInput | LastActivityUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type RoadmapStepUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput> | RoadmapStepCreateWithoutRoadmapInput[] | RoadmapStepUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutRoadmapInput | RoadmapStepCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapStepUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapStepCreateManyRoadmapInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapStepUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutRoadmapInput | RoadmapStepUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput | RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput> | LastActivityCreateWithoutRoadmapInput[] | LastActivityUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapInput | LastActivityCreateOrConnectWithoutRoadmapInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutRoadmapInput | LastActivityUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: LastActivityCreateManyRoadmapInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutRoadmapInput | LastActivityUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutRoadmapInput | LastActivityUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRoadmapProgressInput = {
    create?: XOR<UserCreateWithoutRoadmapProgressInput, UserUncheckedCreateWithoutRoadmapProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapProgressInput
    connect?: UserWhereUniqueInput
  }

  export type RoadmapCreateNestedOneWithoutRoadmapProgressInput = {
    create?: XOR<RoadmapCreateWithoutRoadmapProgressInput, RoadmapUncheckedCreateWithoutRoadmapProgressInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutRoadmapProgressInput
    connect?: RoadmapWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRoadmapProgressNestedInput = {
    create?: XOR<UserCreateWithoutRoadmapProgressInput, UserUncheckedCreateWithoutRoadmapProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoadmapProgressInput
    upsert?: UserUpsertWithoutRoadmapProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoadmapProgressInput, UserUpdateWithoutRoadmapProgressInput>, UserUncheckedUpdateWithoutRoadmapProgressInput>
  }

  export type RoadmapUpdateOneRequiredWithoutRoadmapProgressNestedInput = {
    create?: XOR<RoadmapCreateWithoutRoadmapProgressInput, RoadmapUncheckedCreateWithoutRoadmapProgressInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutRoadmapProgressInput
    upsert?: RoadmapUpsertWithoutRoadmapProgressInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutRoadmapProgressInput, RoadmapUpdateWithoutRoadmapProgressInput>, RoadmapUncheckedUpdateWithoutRoadmapProgressInput>
  }

  export type RoadmapStepCreateNestedOneWithoutChildrenInput = {
    create?: XOR<RoadmapStepCreateWithoutChildrenInput, RoadmapStepUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutChildrenInput
    connect?: RoadmapStepWhereUniqueInput
  }

  export type RoadmapStepCreateNestedManyWithoutParentInput = {
    create?: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput> | RoadmapStepCreateWithoutParentInput[] | RoadmapStepUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutParentInput | RoadmapStepCreateOrConnectWithoutParentInput[]
    createMany?: RoadmapStepCreateManyParentInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type RoadmapCreateNestedOneWithoutStepsInput = {
    create?: XOR<RoadmapCreateWithoutStepsInput, RoadmapUncheckedCreateWithoutStepsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutStepsInput
    connect?: RoadmapWhereUniqueInput
  }

  export type TutorialCreateNestedManyWithoutStepsInput = {
    create?: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput> | TutorialCreateWithoutStepsInput[] | TutorialUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutStepsInput | TutorialCreateOrConnectWithoutStepsInput[]
    createMany?: TutorialCreateManyStepsInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type QuizCreateNestedManyWithoutStepsInput = {
    create?: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput> | QuizCreateWithoutStepsInput[] | QuizUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutStepsInput | QuizCreateOrConnectWithoutStepsInput[]
    createMany?: QuizCreateManyStepsInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LastActivityCreateNestedManyWithoutRoadmapStepInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput> | LastActivityCreateWithoutRoadmapStepInput[] | LastActivityUncheckedCreateWithoutRoadmapStepInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapStepInput | LastActivityCreateOrConnectWithoutRoadmapStepInput[]
    createMany?: LastActivityCreateManyRoadmapStepInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type RoadmapStepUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput> | RoadmapStepCreateWithoutParentInput[] | RoadmapStepUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutParentInput | RoadmapStepCreateOrConnectWithoutParentInput[]
    createMany?: RoadmapStepCreateManyParentInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type TutorialUncheckedCreateNestedManyWithoutStepsInput = {
    create?: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput> | TutorialCreateWithoutStepsInput[] | TutorialUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutStepsInput | TutorialCreateOrConnectWithoutStepsInput[]
    createMany?: TutorialCreateManyStepsInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutStepsInput = {
    create?: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput> | QuizCreateWithoutStepsInput[] | QuizUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutStepsInput | QuizCreateOrConnectWithoutStepsInput[]
    createMany?: QuizCreateManyStepsInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput> | LastActivityCreateWithoutRoadmapStepInput[] | LastActivityUncheckedCreateWithoutRoadmapStepInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapStepInput | LastActivityCreateOrConnectWithoutRoadmapStepInput[]
    createMany?: LastActivityCreateManyRoadmapStepInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type EnumStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.StepStatus
  }

  export type RoadmapStepUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutChildrenInput, RoadmapStepUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutChildrenInput
    upsert?: RoadmapStepUpsertWithoutChildrenInput
    disconnect?: RoadmapStepWhereInput | boolean
    delete?: RoadmapStepWhereInput | boolean
    connect?: RoadmapStepWhereUniqueInput
    update?: XOR<XOR<RoadmapStepUpdateToOneWithWhereWithoutChildrenInput, RoadmapStepUpdateWithoutChildrenInput>, RoadmapStepUncheckedUpdateWithoutChildrenInput>
  }

  export type RoadmapStepUpdateManyWithoutParentNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput> | RoadmapStepCreateWithoutParentInput[] | RoadmapStepUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutParentInput | RoadmapStepCreateOrConnectWithoutParentInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutParentInput | RoadmapStepUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RoadmapStepCreateManyParentInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutParentInput | RoadmapStepUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutParentInput | RoadmapStepUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type RoadmapUpdateOneWithoutStepsNestedInput = {
    create?: XOR<RoadmapCreateWithoutStepsInput, RoadmapUncheckedCreateWithoutStepsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutStepsInput
    upsert?: RoadmapUpsertWithoutStepsInput
    disconnect?: RoadmapWhereInput | boolean
    delete?: RoadmapWhereInput | boolean
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutStepsInput, RoadmapUpdateWithoutStepsInput>, RoadmapUncheckedUpdateWithoutStepsInput>
  }

  export type TutorialUpdateManyWithoutStepsNestedInput = {
    create?: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput> | TutorialCreateWithoutStepsInput[] | TutorialUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutStepsInput | TutorialCreateOrConnectWithoutStepsInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutStepsInput | TutorialUpsertWithWhereUniqueWithoutStepsInput[]
    createMany?: TutorialCreateManyStepsInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutStepsInput | TutorialUpdateWithWhereUniqueWithoutStepsInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutStepsInput | TutorialUpdateManyWithWhereWithoutStepsInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type QuizUpdateManyWithoutStepsNestedInput = {
    create?: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput> | QuizCreateWithoutStepsInput[] | QuizUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutStepsInput | QuizCreateOrConnectWithoutStepsInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutStepsInput | QuizUpsertWithWhereUniqueWithoutStepsInput[]
    createMany?: QuizCreateManyStepsInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutStepsInput | QuizUpdateWithWhereUniqueWithoutStepsInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutStepsInput | QuizUpdateManyWithWhereWithoutStepsInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LastActivityUpdateManyWithoutRoadmapStepNestedInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput> | LastActivityCreateWithoutRoadmapStepInput[] | LastActivityUncheckedCreateWithoutRoadmapStepInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapStepInput | LastActivityCreateOrConnectWithoutRoadmapStepInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutRoadmapStepInput | LastActivityUpsertWithWhereUniqueWithoutRoadmapStepInput[]
    createMany?: LastActivityCreateManyRoadmapStepInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutRoadmapStepInput | LastActivityUpdateWithWhereUniqueWithoutRoadmapStepInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutRoadmapStepInput | LastActivityUpdateManyWithWhereWithoutRoadmapStepInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type RoadmapStepUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput> | RoadmapStepCreateWithoutParentInput[] | RoadmapStepUncheckedCreateWithoutParentInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutParentInput | RoadmapStepCreateOrConnectWithoutParentInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutParentInput | RoadmapStepUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: RoadmapStepCreateManyParentInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutParentInput | RoadmapStepUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutParentInput | RoadmapStepUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type TutorialUncheckedUpdateManyWithoutStepsNestedInput = {
    create?: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput> | TutorialCreateWithoutStepsInput[] | TutorialUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutStepsInput | TutorialCreateOrConnectWithoutStepsInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutStepsInput | TutorialUpsertWithWhereUniqueWithoutStepsInput[]
    createMany?: TutorialCreateManyStepsInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutStepsInput | TutorialUpdateWithWhereUniqueWithoutStepsInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutStepsInput | TutorialUpdateManyWithWhereWithoutStepsInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutStepsNestedInput = {
    create?: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput> | QuizCreateWithoutStepsInput[] | QuizUncheckedCreateWithoutStepsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutStepsInput | QuizCreateOrConnectWithoutStepsInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutStepsInput | QuizUpsertWithWhereUniqueWithoutStepsInput[]
    createMany?: QuizCreateManyStepsInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutStepsInput | QuizUpdateWithWhereUniqueWithoutStepsInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutStepsInput | QuizUpdateManyWithWhereWithoutStepsInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput = {
    create?: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput> | LastActivityCreateWithoutRoadmapStepInput[] | LastActivityUncheckedCreateWithoutRoadmapStepInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutRoadmapStepInput | LastActivityCreateOrConnectWithoutRoadmapStepInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutRoadmapStepInput | LastActivityUpsertWithWhereUniqueWithoutRoadmapStepInput[]
    createMany?: LastActivityCreateManyRoadmapStepInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutRoadmapStepInput | LastActivityUpdateWithWhereUniqueWithoutRoadmapStepInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutRoadmapStepInput | LastActivityUpdateManyWithWhereWithoutRoadmapStepInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizCreateNestedManyWithoutTutorialInput = {
    create?: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput> | QuizCreateWithoutTutorialInput[] | QuizUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTutorialInput | QuizCreateOrConnectWithoutTutorialInput[]
    createMany?: QuizCreateManyTutorialInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserProgressCreateNestedManyWithoutTutorialInput = {
    create?: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput> | UserProgressCreateWithoutTutorialInput[] | UserProgressUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutTutorialInput | UserProgressCreateOrConnectWithoutTutorialInput[]
    createMany?: UserProgressCreateManyTutorialInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type TagCreateNestedManyWithoutTutorialsInput = {
    create?: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput> | TagCreateWithoutTutorialsInput[] | TagUncheckedCreateWithoutTutorialsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTutorialsInput | TagCreateOrConnectWithoutTutorialsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type RoadmapStepCreateNestedOneWithoutTutorialsInput = {
    create?: XOR<RoadmapStepCreateWithoutTutorialsInput, RoadmapStepUncheckedCreateWithoutTutorialsInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutTutorialsInput
    connect?: RoadmapStepWhereUniqueInput
  }

  export type TutorialCreateNestedOneWithoutRelatedTutorialsInput = {
    create?: XOR<TutorialCreateWithoutRelatedTutorialsInput, TutorialUncheckedCreateWithoutRelatedTutorialsInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutRelatedTutorialsInput
    connect?: TutorialWhereUniqueInput
  }

  export type TutorialCreateNestedOneWithoutPreviousTutorialsInput = {
    create?: XOR<TutorialCreateWithoutPreviousTutorialsInput, TutorialUncheckedCreateWithoutPreviousTutorialsInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutPreviousTutorialsInput
    connect?: TutorialWhereUniqueInput
  }

  export type TutorialCreateNestedManyWithoutNextTutorialInput = {
    create?: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput> | TutorialCreateWithoutNextTutorialInput[] | TutorialUncheckedCreateWithoutNextTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutNextTutorialInput | TutorialCreateOrConnectWithoutNextTutorialInput[]
    createMany?: TutorialCreateManyNextTutorialInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type TutorialCreateNestedManyWithoutTutorialInput = {
    create?: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput> | TutorialCreateWithoutTutorialInput[] | TutorialUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialInput | TutorialCreateOrConnectWithoutTutorialInput[]
    createMany?: TutorialCreateManyTutorialInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type LastActivityCreateNestedManyWithoutTutorialInput = {
    create?: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput> | LastActivityCreateWithoutTutorialInput[] | LastActivityUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutTutorialInput | LastActivityCreateOrConnectWithoutTutorialInput[]
    createMany?: LastActivityCreateManyTutorialInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutTutorialInput = {
    create?: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput> | QuizCreateWithoutTutorialInput[] | QuizUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTutorialInput | QuizCreateOrConnectWithoutTutorialInput[]
    createMany?: QuizCreateManyTutorialInputEnvelope
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutTutorialInput = {
    create?: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput> | UserProgressCreateWithoutTutorialInput[] | UserProgressUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutTutorialInput | UserProgressCreateOrConnectWithoutTutorialInput[]
    createMany?: UserProgressCreateManyTutorialInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutTutorialsInput = {
    create?: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput> | TagCreateWithoutTutorialsInput[] | TagUncheckedCreateWithoutTutorialsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTutorialsInput | TagCreateOrConnectWithoutTutorialsInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type TutorialUncheckedCreateNestedManyWithoutNextTutorialInput = {
    create?: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput> | TutorialCreateWithoutNextTutorialInput[] | TutorialUncheckedCreateWithoutNextTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutNextTutorialInput | TutorialCreateOrConnectWithoutNextTutorialInput[]
    createMany?: TutorialCreateManyNextTutorialInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type TutorialUncheckedCreateNestedManyWithoutTutorialInput = {
    create?: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput> | TutorialCreateWithoutTutorialInput[] | TutorialUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialInput | TutorialCreateOrConnectWithoutTutorialInput[]
    createMany?: TutorialCreateManyTutorialInputEnvelope
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutTutorialInput = {
    create?: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput> | LastActivityCreateWithoutTutorialInput[] | LastActivityUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutTutorialInput | LastActivityCreateOrConnectWithoutTutorialInput[]
    createMany?: LastActivityCreateManyTutorialInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type EnumDifficultyLevelFieldUpdateOperationsInput = {
    set?: $Enums.DifficultyLevel
  }

  export type EnumTutorialStatusFieldUpdateOperationsInput = {
    set?: $Enums.TutorialStatus
  }

  export type QuizUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput> | QuizCreateWithoutTutorialInput[] | QuizUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTutorialInput | QuizCreateOrConnectWithoutTutorialInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutTutorialInput | QuizUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: QuizCreateManyTutorialInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutTutorialInput | QuizUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutTutorialInput | QuizUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserProgressUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput> | UserProgressCreateWithoutTutorialInput[] | UserProgressUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutTutorialInput | UserProgressCreateOrConnectWithoutTutorialInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutTutorialInput | UserProgressUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: UserProgressCreateManyTutorialInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutTutorialInput | UserProgressUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutTutorialInput | UserProgressUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type TagUpdateManyWithoutTutorialsNestedInput = {
    create?: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput> | TagCreateWithoutTutorialsInput[] | TagUncheckedCreateWithoutTutorialsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTutorialsInput | TagCreateOrConnectWithoutTutorialsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTutorialsInput | TagUpsertWithWhereUniqueWithoutTutorialsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTutorialsInput | TagUpdateWithWhereUniqueWithoutTutorialsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTutorialsInput | TagUpdateManyWithWhereWithoutTutorialsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type RoadmapStepUpdateOneWithoutTutorialsNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutTutorialsInput, RoadmapStepUncheckedCreateWithoutTutorialsInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutTutorialsInput
    upsert?: RoadmapStepUpsertWithoutTutorialsInput
    disconnect?: RoadmapStepWhereInput | boolean
    delete?: RoadmapStepWhereInput | boolean
    connect?: RoadmapStepWhereUniqueInput
    update?: XOR<XOR<RoadmapStepUpdateToOneWithWhereWithoutTutorialsInput, RoadmapStepUpdateWithoutTutorialsInput>, RoadmapStepUncheckedUpdateWithoutTutorialsInput>
  }

  export type TutorialUpdateOneWithoutRelatedTutorialsNestedInput = {
    create?: XOR<TutorialCreateWithoutRelatedTutorialsInput, TutorialUncheckedCreateWithoutRelatedTutorialsInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutRelatedTutorialsInput
    upsert?: TutorialUpsertWithoutRelatedTutorialsInput
    disconnect?: TutorialWhereInput | boolean
    delete?: TutorialWhereInput | boolean
    connect?: TutorialWhereUniqueInput
    update?: XOR<XOR<TutorialUpdateToOneWithWhereWithoutRelatedTutorialsInput, TutorialUpdateWithoutRelatedTutorialsInput>, TutorialUncheckedUpdateWithoutRelatedTutorialsInput>
  }

  export type TutorialUpdateOneWithoutPreviousTutorialsNestedInput = {
    create?: XOR<TutorialCreateWithoutPreviousTutorialsInput, TutorialUncheckedCreateWithoutPreviousTutorialsInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutPreviousTutorialsInput
    upsert?: TutorialUpsertWithoutPreviousTutorialsInput
    disconnect?: TutorialWhereInput | boolean
    delete?: TutorialWhereInput | boolean
    connect?: TutorialWhereUniqueInput
    update?: XOR<XOR<TutorialUpdateToOneWithWhereWithoutPreviousTutorialsInput, TutorialUpdateWithoutPreviousTutorialsInput>, TutorialUncheckedUpdateWithoutPreviousTutorialsInput>
  }

  export type TutorialUpdateManyWithoutNextTutorialNestedInput = {
    create?: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput> | TutorialCreateWithoutNextTutorialInput[] | TutorialUncheckedCreateWithoutNextTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutNextTutorialInput | TutorialCreateOrConnectWithoutNextTutorialInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutNextTutorialInput | TutorialUpsertWithWhereUniqueWithoutNextTutorialInput[]
    createMany?: TutorialCreateManyNextTutorialInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutNextTutorialInput | TutorialUpdateWithWhereUniqueWithoutNextTutorialInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutNextTutorialInput | TutorialUpdateManyWithWhereWithoutNextTutorialInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type TutorialUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput> | TutorialCreateWithoutTutorialInput[] | TutorialUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialInput | TutorialCreateOrConnectWithoutTutorialInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutTutorialInput | TutorialUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: TutorialCreateManyTutorialInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutTutorialInput | TutorialUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutTutorialInput | TutorialUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type LastActivityUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput> | LastActivityCreateWithoutTutorialInput[] | LastActivityUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutTutorialInput | LastActivityCreateOrConnectWithoutTutorialInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutTutorialInput | LastActivityUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: LastActivityCreateManyTutorialInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutTutorialInput | LastActivityUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutTutorialInput | LastActivityUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput> | QuizCreateWithoutTutorialInput[] | QuizUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTutorialInput | QuizCreateOrConnectWithoutTutorialInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutTutorialInput | QuizUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: QuizCreateManyTutorialInputEnvelope
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutTutorialInput | QuizUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutTutorialInput | QuizUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput> | UserProgressCreateWithoutTutorialInput[] | UserProgressUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutTutorialInput | UserProgressCreateOrConnectWithoutTutorialInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutTutorialInput | UserProgressUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: UserProgressCreateManyTutorialInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutTutorialInput | UserProgressUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutTutorialInput | UserProgressUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutTutorialsNestedInput = {
    create?: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput> | TagCreateWithoutTutorialsInput[] | TagUncheckedCreateWithoutTutorialsInput[]
    connectOrCreate?: TagCreateOrConnectWithoutTutorialsInput | TagCreateOrConnectWithoutTutorialsInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutTutorialsInput | TagUpsertWithWhereUniqueWithoutTutorialsInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutTutorialsInput | TagUpdateWithWhereUniqueWithoutTutorialsInput[]
    updateMany?: TagUpdateManyWithWhereWithoutTutorialsInput | TagUpdateManyWithWhereWithoutTutorialsInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput = {
    create?: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput> | TutorialCreateWithoutNextTutorialInput[] | TutorialUncheckedCreateWithoutNextTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutNextTutorialInput | TutorialCreateOrConnectWithoutNextTutorialInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutNextTutorialInput | TutorialUpsertWithWhereUniqueWithoutNextTutorialInput[]
    createMany?: TutorialCreateManyNextTutorialInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutNextTutorialInput | TutorialUpdateWithWhereUniqueWithoutNextTutorialInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutNextTutorialInput | TutorialUpdateManyWithWhereWithoutNextTutorialInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type TutorialUncheckedUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput> | TutorialCreateWithoutTutorialInput[] | TutorialUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialInput | TutorialCreateOrConnectWithoutTutorialInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutTutorialInput | TutorialUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: TutorialCreateManyTutorialInputEnvelope
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutTutorialInput | TutorialUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutTutorialInput | TutorialUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutTutorialNestedInput = {
    create?: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput> | LastActivityCreateWithoutTutorialInput[] | LastActivityUncheckedCreateWithoutTutorialInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutTutorialInput | LastActivityCreateOrConnectWithoutTutorialInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutTutorialInput | LastActivityUpsertWithWhereUniqueWithoutTutorialInput[]
    createMany?: LastActivityCreateManyTutorialInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutTutorialInput | LastActivityUpdateWithWhereUniqueWithoutTutorialInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutTutorialInput | LastActivityUpdateManyWithWhereWithoutTutorialInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type UserQuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput> | UserQuizAttemptCreateWithoutQuizInput[] | UserQuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuizInput | UserQuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: UserQuizAttemptCreateManyQuizInputEnvelope
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
  }

  export type TutorialCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<TutorialCreateWithoutQuizzesInput, TutorialUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutQuizzesInput
    connect?: TutorialWhereUniqueInput
  }

  export type TagCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput> | TagCreateWithoutQuizzesInput[] | TagUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQuizzesInput | TagCreateOrConnectWithoutQuizzesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type RoadmapStepCreateNestedOneWithoutQuizzesInput = {
    create?: XOR<RoadmapStepCreateWithoutQuizzesInput, RoadmapStepUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutQuizzesInput
    connect?: RoadmapStepWhereUniqueInput
  }

  export type LastActivityCreateNestedManyWithoutQuizInput = {
    create?: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput> | LastActivityCreateWithoutQuizInput[] | LastActivityUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizInput | LastActivityCreateOrConnectWithoutQuizInput[]
    createMany?: LastActivityCreateManyQuizInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput> | UserQuizAttemptCreateWithoutQuizInput[] | UserQuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuizInput | UserQuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: UserQuizAttemptCreateManyQuizInputEnvelope
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
  }

  export type TagUncheckedCreateNestedManyWithoutQuizzesInput = {
    create?: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput> | TagCreateWithoutQuizzesInput[] | TagUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQuizzesInput | TagCreateOrConnectWithoutQuizzesInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
  }

  export type LastActivityUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput> | LastActivityCreateWithoutQuizInput[] | LastActivityUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizInput | LastActivityCreateOrConnectWithoutQuizInput[]
    createMany?: LastActivityCreateManyQuizInputEnvelope
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type UserQuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput> | UserQuizAttemptCreateWithoutQuizInput[] | UserQuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuizInput | UserQuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: UserQuizAttemptUpsertWithWhereUniqueWithoutQuizInput | UserQuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: UserQuizAttemptCreateManyQuizInputEnvelope
    set?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    disconnect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    delete?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    update?: UserQuizAttemptUpdateWithWhereUniqueWithoutQuizInput | UserQuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: UserQuizAttemptUpdateManyWithWhereWithoutQuizInput | UserQuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
  }

  export type TutorialUpdateOneRequiredWithoutQuizzesNestedInput = {
    create?: XOR<TutorialCreateWithoutQuizzesInput, TutorialUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: TutorialCreateOrConnectWithoutQuizzesInput
    upsert?: TutorialUpsertWithoutQuizzesInput
    connect?: TutorialWhereUniqueInput
    update?: XOR<XOR<TutorialUpdateToOneWithWhereWithoutQuizzesInput, TutorialUpdateWithoutQuizzesInput>, TutorialUncheckedUpdateWithoutQuizzesInput>
  }

  export type TagUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput> | TagCreateWithoutQuizzesInput[] | TagUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQuizzesInput | TagCreateOrConnectWithoutQuizzesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutQuizzesInput | TagUpsertWithWhereUniqueWithoutQuizzesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutQuizzesInput | TagUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutQuizzesInput | TagUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type RoadmapStepUpdateOneWithoutQuizzesNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutQuizzesInput, RoadmapStepUncheckedCreateWithoutQuizzesInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutQuizzesInput
    upsert?: RoadmapStepUpsertWithoutQuizzesInput
    disconnect?: RoadmapStepWhereInput | boolean
    delete?: RoadmapStepWhereInput | boolean
    connect?: RoadmapStepWhereUniqueInput
    update?: XOR<XOR<RoadmapStepUpdateToOneWithWhereWithoutQuizzesInput, RoadmapStepUpdateWithoutQuizzesInput>, RoadmapStepUncheckedUpdateWithoutQuizzesInput>
  }

  export type LastActivityUpdateManyWithoutQuizNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput> | LastActivityCreateWithoutQuizInput[] | LastActivityUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizInput | LastActivityCreateOrConnectWithoutQuizInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuizInput | LastActivityUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: LastActivityCreateManyQuizInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuizInput | LastActivityUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuizInput | LastActivityUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput> | UserQuizAttemptCreateWithoutQuizInput[] | UserQuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: UserQuizAttemptCreateOrConnectWithoutQuizInput | UserQuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: UserQuizAttemptUpsertWithWhereUniqueWithoutQuizInput | UserQuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: UserQuizAttemptCreateManyQuizInputEnvelope
    set?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    disconnect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    delete?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    connect?: UserQuizAttemptWhereUniqueInput | UserQuizAttemptWhereUniqueInput[]
    update?: UserQuizAttemptUpdateWithWhereUniqueWithoutQuizInput | UserQuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: UserQuizAttemptUpdateManyWithWhereWithoutQuizInput | UserQuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
  }

  export type TagUncheckedUpdateManyWithoutQuizzesNestedInput = {
    create?: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput> | TagCreateWithoutQuizzesInput[] | TagUncheckedCreateWithoutQuizzesInput[]
    connectOrCreate?: TagCreateOrConnectWithoutQuizzesInput | TagCreateOrConnectWithoutQuizzesInput[]
    upsert?: TagUpsertWithWhereUniqueWithoutQuizzesInput | TagUpsertWithWhereUniqueWithoutQuizzesInput[]
    set?: TagWhereUniqueInput | TagWhereUniqueInput[]
    disconnect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    delete?: TagWhereUniqueInput | TagWhereUniqueInput[]
    connect?: TagWhereUniqueInput | TagWhereUniqueInput[]
    update?: TagUpdateWithWhereUniqueWithoutQuizzesInput | TagUpdateWithWhereUniqueWithoutQuizzesInput[]
    updateMany?: TagUpdateManyWithWhereWithoutQuizzesInput | TagUpdateManyWithWhereWithoutQuizzesInput[]
    deleteMany?: TagScalarWhereInput | TagScalarWhereInput[]
  }

  export type LastActivityUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput> | LastActivityCreateWithoutQuizInput[] | LastActivityUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: LastActivityCreateOrConnectWithoutQuizInput | LastActivityCreateOrConnectWithoutQuizInput[]
    upsert?: LastActivityUpsertWithWhereUniqueWithoutQuizInput | LastActivityUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: LastActivityCreateManyQuizInputEnvelope
    set?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    disconnect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    delete?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    connect?: LastActivityWhereUniqueInput | LastActivityWhereUniqueInput[]
    update?: LastActivityUpdateWithWhereUniqueWithoutQuizInput | LastActivityUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: LastActivityUpdateManyWithWhereWithoutQuizInput | LastActivityUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
  }

  export type QuizQuestionCreateoptionsInput = {
    set: string[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserCreateNestedOneWithoutAdminActivityLogsInput = {
    create?: XOR<UserCreateWithoutAdminActivityLogsInput, UserUncheckedCreateWithoutAdminActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAdminActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutAdminActivityLogsInput, UserUncheckedCreateWithoutAdminActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAdminActivityLogsInput
    upsert?: UserUpsertWithoutAdminActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAdminActivityLogsInput, UserUpdateWithoutAdminActivityLogsInput>, UserUncheckedUpdateWithoutAdminActivityLogsInput>
  }

  export type QuizCreateNestedManyWithoutTagsInput = {
    create?: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput> | QuizCreateWithoutTagsInput[] | QuizUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTagsInput | QuizCreateOrConnectWithoutTagsInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type TutorialCreateNestedManyWithoutTutorialTagsInput = {
    create?: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput> | TutorialCreateWithoutTutorialTagsInput[] | TutorialUncheckedCreateWithoutTutorialTagsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialTagsInput | TutorialCreateOrConnectWithoutTutorialTagsInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type QuizUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput> | QuizCreateWithoutTagsInput[] | QuizUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTagsInput | QuizCreateOrConnectWithoutTagsInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
  }

  export type TutorialUncheckedCreateNestedManyWithoutTutorialTagsInput = {
    create?: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput> | TutorialCreateWithoutTutorialTagsInput[] | TutorialUncheckedCreateWithoutTutorialTagsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialTagsInput | TutorialCreateOrConnectWithoutTutorialTagsInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
  }

  export type EnumTagTypeFieldUpdateOperationsInput = {
    set?: $Enums.TagType
  }

  export type QuizUpdateManyWithoutTagsNestedInput = {
    create?: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput> | QuizCreateWithoutTagsInput[] | QuizUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTagsInput | QuizCreateOrConnectWithoutTagsInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutTagsInput | QuizUpsertWithWhereUniqueWithoutTagsInput[]
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutTagsInput | QuizUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutTagsInput | QuizUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type TutorialUpdateManyWithoutTutorialTagsNestedInput = {
    create?: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput> | TutorialCreateWithoutTutorialTagsInput[] | TutorialUncheckedCreateWithoutTutorialTagsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialTagsInput | TutorialCreateOrConnectWithoutTutorialTagsInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutTutorialTagsInput | TutorialUpsertWithWhereUniqueWithoutTutorialTagsInput[]
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutTutorialTagsInput | TutorialUpdateWithWhereUniqueWithoutTutorialTagsInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutTutorialTagsInput | TutorialUpdateManyWithWhereWithoutTutorialTagsInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type QuizUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput> | QuizCreateWithoutTagsInput[] | QuizUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: QuizCreateOrConnectWithoutTagsInput | QuizCreateOrConnectWithoutTagsInput[]
    upsert?: QuizUpsertWithWhereUniqueWithoutTagsInput | QuizUpsertWithWhereUniqueWithoutTagsInput[]
    set?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    disconnect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    delete?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    connect?: QuizWhereUniqueInput | QuizWhereUniqueInput[]
    update?: QuizUpdateWithWhereUniqueWithoutTagsInput | QuizUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: QuizUpdateManyWithWhereWithoutTagsInput | QuizUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: QuizScalarWhereInput | QuizScalarWhereInput[]
  }

  export type TutorialUncheckedUpdateManyWithoutTutorialTagsNestedInput = {
    create?: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput> | TutorialCreateWithoutTutorialTagsInput[] | TutorialUncheckedCreateWithoutTutorialTagsInput[]
    connectOrCreate?: TutorialCreateOrConnectWithoutTutorialTagsInput | TutorialCreateOrConnectWithoutTutorialTagsInput[]
    upsert?: TutorialUpsertWithWhereUniqueWithoutTutorialTagsInput | TutorialUpsertWithWhereUniqueWithoutTutorialTagsInput[]
    set?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    disconnect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    delete?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    connect?: TutorialWhereUniqueInput | TutorialWhereUniqueInput[]
    update?: TutorialUpdateWithWhereUniqueWithoutTutorialTagsInput | TutorialUpdateWithWhereUniqueWithoutTutorialTagsInput[]
    updateMany?: TutorialUpdateManyWithWhereWithoutTutorialTagsInput | TutorialUpdateManyWithWhereWithoutTutorialTagsInput[]
    deleteMany?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumThemeNameFilter<$PrismaModel = never> = {
    equals?: $Enums.ThemeName | EnumThemeNameFieldRefInput<$PrismaModel>
    in?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeNameFilter<$PrismaModel> | $Enums.ThemeName
  }

  export type NestedEnumThemeNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ThemeName | EnumThemeNameFieldRefInput<$PrismaModel>
    in?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.ThemeName[] | ListEnumThemeNameFieldRefInput<$PrismaModel>
    not?: NestedEnumThemeNameWithAggregatesFilter<$PrismaModel> | $Enums.ThemeName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumThemeNameFilter<$PrismaModel>
    _max?: NestedEnumThemeNameFilter<$PrismaModel>
  }

  export type NestedEnumActivityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeFilter<$PrismaModel> | $Enums.ActivityType
  }

  export type NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityType | EnumActivityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityType[] | ListEnumActivityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumRoadmapTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadmapType | EnumRoadmapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadmapTypeFilter<$PrismaModel> | $Enums.RoadmapType
  }

  export type NestedEnumRoadmapTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoadmapType | EnumRoadmapTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoadmapType[] | ListEnumRoadmapTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoadmapTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoadmapType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoadmapTypeFilter<$PrismaModel>
    _max?: NestedEnumRoadmapTypeFilter<$PrismaModel>
  }

  export type NestedEnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type NestedEnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type NestedEnumDifficultyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelFilter<$PrismaModel> | $Enums.DifficultyLevel
  }

  export type NestedEnumTutorialStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TutorialStatus | EnumTutorialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutorialStatusFilter<$PrismaModel> | $Enums.TutorialStatus
  }

  export type NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DifficultyLevel | EnumDifficultyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.DifficultyLevel[] | ListEnumDifficultyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumDifficultyLevelWithAggregatesFilter<$PrismaModel> | $Enums.DifficultyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDifficultyLevelFilter<$PrismaModel>
    _max?: NestedEnumDifficultyLevelFilter<$PrismaModel>
  }

  export type NestedEnumTutorialStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TutorialStatus | EnumTutorialStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TutorialStatus[] | ListEnumTutorialStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTutorialStatusWithAggregatesFilter<$PrismaModel> | $Enums.TutorialStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTutorialStatusFilter<$PrismaModel>
    _max?: NestedEnumTutorialStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumTagTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeFilter<$PrismaModel> | $Enums.TagType
  }

  export type NestedEnumTagTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TagType | EnumTagTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TagType[] | ListEnumTagTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTagTypeWithAggregatesFilter<$PrismaModel> | $Enums.TagType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTagTypeFilter<$PrismaModel>
    _max?: NestedEnumTagTypeFilter<$PrismaModel>
  }

  export type UserProfileCreateWithoutUserInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type RoadmapCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    steps?: RoadmapStepCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutCreatedByInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput>
  }

  export type RoadmapCreateManyCreatedByInputEnvelope = {
    data: RoadmapCreateManyCreatedByInput | RoadmapCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapProgressCreateWithoutUserInput = {
    id?: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutRoadmapProgressInput
  }

  export type RoadmapProgressUncheckedCreateWithoutUserInput = {
    id?: string
    roadmapId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressCreateOrConnectWithoutUserInput = {
    where: RoadmapProgressWhereUniqueInput
    create: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput>
  }

  export type RoadmapProgressCreateManyUserInputEnvelope = {
    data: RoadmapProgressCreateManyUserInput | RoadmapProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AdminActivityLogCreateWithoutAdminInput = {
    id?: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
  }

  export type AdminActivityLogUncheckedCreateWithoutAdminInput = {
    id?: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
  }

  export type AdminActivityLogCreateOrConnectWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    create: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActivityLogCreateManyAdminInputEnvelope = {
    data: AdminActivityLogCreateManyAdminInput | AdminActivityLogCreateManyAdminInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type RoadmapUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: RoadmapWhereUniqueInput
    update: XOR<RoadmapUpdateWithoutCreatedByInput, RoadmapUncheckedUpdateWithoutCreatedByInput>
    create: XOR<RoadmapCreateWithoutCreatedByInput, RoadmapUncheckedCreateWithoutCreatedByInput>
  }

  export type RoadmapUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: RoadmapWhereUniqueInput
    data: XOR<RoadmapUpdateWithoutCreatedByInput, RoadmapUncheckedUpdateWithoutCreatedByInput>
  }

  export type RoadmapUpdateManyWithWhereWithoutCreatedByInput = {
    where: RoadmapScalarWhereInput
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type RoadmapScalarWhereInput = {
    AND?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    OR?: RoadmapScalarWhereInput[]
    NOT?: RoadmapScalarWhereInput | RoadmapScalarWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    title?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    category?: StringNullableFilter<"Roadmap"> | string | null
    type?: EnumRoadmapTypeFilter<"Roadmap"> | $Enums.RoadmapType
    createdById?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Roadmap"> | Date | string | null
  }

  export type RoadmapProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: RoadmapProgressWhereUniqueInput
    update: XOR<RoadmapProgressUpdateWithoutUserInput, RoadmapProgressUncheckedUpdateWithoutUserInput>
    create: XOR<RoadmapProgressCreateWithoutUserInput, RoadmapProgressUncheckedCreateWithoutUserInput>
  }

  export type RoadmapProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: RoadmapProgressWhereUniqueInput
    data: XOR<RoadmapProgressUpdateWithoutUserInput, RoadmapProgressUncheckedUpdateWithoutUserInput>
  }

  export type RoadmapProgressUpdateManyWithWhereWithoutUserInput = {
    where: RoadmapProgressScalarWhereInput
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type RoadmapProgressScalarWhereInput = {
    AND?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
    OR?: RoadmapProgressScalarWhereInput[]
    NOT?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
    id?: StringFilter<"RoadmapProgress"> | string
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    progress?: IntFilter<"RoadmapProgress"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
  }

  export type AdminActivityLogUpsertWithWhereUniqueWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    update: XOR<AdminActivityLogUpdateWithoutAdminInput, AdminActivityLogUncheckedUpdateWithoutAdminInput>
    create: XOR<AdminActivityLogCreateWithoutAdminInput, AdminActivityLogUncheckedCreateWithoutAdminInput>
  }

  export type AdminActivityLogUpdateWithWhereUniqueWithoutAdminInput = {
    where: AdminActivityLogWhereUniqueInput
    data: XOR<AdminActivityLogUpdateWithoutAdminInput, AdminActivityLogUncheckedUpdateWithoutAdminInput>
  }

  export type AdminActivityLogUpdateManyWithWhereWithoutAdminInput = {
    where: AdminActivityLogScalarWhereInput
    data: XOR<AdminActivityLogUpdateManyMutationInput, AdminActivityLogUncheckedUpdateManyWithoutAdminInput>
  }

  export type AdminActivityLogScalarWhereInput = {
    AND?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
    OR?: AdminActivityLogScalarWhereInput[]
    NOT?: AdminActivityLogScalarWhereInput | AdminActivityLogScalarWhereInput[]
    id?: StringFilter<"AdminActivityLog"> | string
    adminId?: StringFilter<"AdminActivityLog"> | string
    action?: StringFilter<"AdminActivityLog"> | string
    target?: StringFilter<"AdminActivityLog"> | string
    targetId?: StringFilter<"AdminActivityLog"> | string
    timestamp?: DateTimeFilter<"AdminActivityLog"> | Date | string
  }

  export type CoinWalletCreateWithoutProfileInput = {
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinWalletUncheckedCreateWithoutProfileInput = {
    balance?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinWalletCreateOrConnectWithoutProfileInput = {
    where: CoinWalletWhereUniqueInput
    create: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roadmaps?: RoadmapCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type CoinTransactionCreateWithoutProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinTransactionUncheckedCreateWithoutProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinTransactionCreateOrConnectWithoutProfileInput = {
    where: CoinTransactionWhereUniqueInput
    create: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput>
  }

  export type CoinTransactionCreateManyProfileInputEnvelope = {
    data: CoinTransactionCreateManyProfileInput | CoinTransactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type LastActivityCreateWithoutProfileInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type LastActivityCreateOrConnectWithoutProfileInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput>
  }

  export type UserProgressCreateWithoutProfileInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorial: TutorialCreateNestedOneWithoutProgressInput
    userQuizAttempt?: UserQuizAttemptCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutProfileInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutProfileInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput>
  }

  export type UserProgressCreateManyProfileInputEnvelope = {
    data: UserProgressCreateManyProfileInput | UserProgressCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserQuizAttemptCreateWithoutProfileInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    questionAttempts?: UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateWithoutProfileInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionAttempts?: UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptCreateOrConnectWithoutProfileInput = {
    where: UserQuizAttemptWhereUniqueInput
    create: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput>
  }

  export type UserQuizAttemptCreateManyProfileInputEnvelope = {
    data: UserQuizAttemptCreateManyProfileInput | UserQuizAttemptCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutProfileInput = {
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    badge: BadgeCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutProfileInput = {
    badgeId: string
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutProfileInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput>
  }

  export type UserBadgeCreateManyProfileInputEnvelope = {
    data: UserBadgeCreateManyProfileInput | UserBadgeCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserStreakCreateWithoutProfileInput = {
    streak?: number
    streakDays?: number
    lastLogin?: Date | string | null
    currentStart?: Date | string | null
    currentEnd?: Date | string | null
    longestStreak?: number
    longestStart?: Date | string | null
    longestEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStreakUncheckedCreateWithoutProfileInput = {
    streak?: number
    streakDays?: number
    lastLogin?: Date | string | null
    currentStart?: Date | string | null
    currentEnd?: Date | string | null
    longestStreak?: number
    longestStart?: Date | string | null
    longestEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserStreakCreateOrConnectWithoutProfileInput = {
    where: UserStreakWhereUniqueInput
    create: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
  }

  export type CoinWalletUpsertWithoutProfileInput = {
    update: XOR<CoinWalletUpdateWithoutProfileInput, CoinWalletUncheckedUpdateWithoutProfileInput>
    create: XOR<CoinWalletCreateWithoutProfileInput, CoinWalletUncheckedCreateWithoutProfileInput>
    where?: CoinWalletWhereInput
  }

  export type CoinWalletUpdateToOneWithWhereWithoutProfileInput = {
    where?: CoinWalletWhereInput
    data: XOR<CoinWalletUpdateWithoutProfileInput, CoinWalletUncheckedUpdateWithoutProfileInput>
  }

  export type CoinWalletUpdateWithoutProfileInput = {
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinWalletUncheckedUpdateWithoutProfileInput = {
    balance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roadmaps?: RoadmapUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roadmaps?: RoadmapUncheckedUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type CoinTransactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: CoinTransactionWhereUniqueInput
    update: XOR<CoinTransactionUpdateWithoutProfileInput, CoinTransactionUncheckedUpdateWithoutProfileInput>
    create: XOR<CoinTransactionCreateWithoutProfileInput, CoinTransactionUncheckedCreateWithoutProfileInput>
  }

  export type CoinTransactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: CoinTransactionWhereUniqueInput
    data: XOR<CoinTransactionUpdateWithoutProfileInput, CoinTransactionUncheckedUpdateWithoutProfileInput>
  }

  export type CoinTransactionUpdateManyWithWhereWithoutProfileInput = {
    where: CoinTransactionScalarWhereInput
    data: XOR<CoinTransactionUpdateManyMutationInput, CoinTransactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type CoinTransactionScalarWhereInput = {
    AND?: CoinTransactionScalarWhereInput | CoinTransactionScalarWhereInput[]
    OR?: CoinTransactionScalarWhereInput[]
    NOT?: CoinTransactionScalarWhereInput | CoinTransactionScalarWhereInput[]
    id?: StringFilter<"CoinTransaction"> | string
    type?: EnumTransactionTypeFilter<"CoinTransaction"> | $Enums.TransactionType
    amount?: IntFilter<"CoinTransaction"> | number
    description?: StringFilter<"CoinTransaction"> | string
    transactionAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    createdAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"CoinTransaction"> | Date | string
    profileId?: StringFilter<"CoinTransaction"> | string
  }

  export type LastActivityUpsertWithWhereUniqueWithoutProfileInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutProfileInput, LastActivityUncheckedUpdateWithoutProfileInput>
    create: XOR<LastActivityCreateWithoutProfileInput, LastActivityUncheckedCreateWithoutProfileInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutProfileInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutProfileInput, LastActivityUncheckedUpdateWithoutProfileInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutProfileInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutProfileInput>
  }

  export type LastActivityScalarWhereInput = {
    AND?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
    OR?: LastActivityScalarWhereInput[]
    NOT?: LastActivityScalarWhereInput | LastActivityScalarWhereInput[]
    id?: StringFilter<"LastActivity"> | string
    userId?: StringFilter<"LastActivity"> | string
    type?: EnumActivityTypeFilter<"LastActivity"> | $Enums.ActivityType
    description?: StringNullableFilter<"LastActivity"> | string | null
    xpAwarded?: IntNullableFilter<"LastActivity"> | number | null
    createdAt?: DateTimeFilter<"LastActivity"> | Date | string
    updatedAt?: DateTimeFilter<"LastActivity"> | Date | string
    quizId?: StringNullableFilter<"LastActivity"> | string | null
    tutorialId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapId?: StringNullableFilter<"LastActivity"> | string | null
    roadmapStepId?: StringNullableFilter<"LastActivity"> | string | null
    quizAttemptId?: StringNullableFilter<"LastActivity"> | string | null
    questionAttemptId?: StringNullableFilter<"LastActivity"> | string | null
  }

  export type UserProgressUpsertWithWhereUniqueWithoutProfileInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutProfileInput, UserProgressUncheckedUpdateWithoutProfileInput>
    create: XOR<UserProgressCreateWithoutProfileInput, UserProgressUncheckedCreateWithoutProfileInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutProfileInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutProfileInput, UserProgressUncheckedUpdateWithoutProfileInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutProfileInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutProfileInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    tutorialId?: StringFilter<"UserProgress"> | string
    bestAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    lastAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    userQuizAttemptId?: StringNullableFilter<"UserProgress"> | string | null
    isCompleted?: BoolFilter<"UserProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"UserProgress"> | Date | string | null
    attempts?: IntFilter<"UserProgress"> | number
    bestScore?: IntFilter<"UserProgress"> | number
    percentageCompleted?: IntFilter<"UserProgress"> | number
    interviewCompleted?: BoolFilter<"UserProgress"> | boolean
    challengeCompleted?: BoolFilter<"UserProgress"> | boolean
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    updatedAt?: DateTimeFilter<"UserProgress"> | Date | string
    profileId?: StringFilter<"UserProgress"> | string
  }

  export type UserQuizAttemptUpsertWithWhereUniqueWithoutProfileInput = {
    where: UserQuizAttemptWhereUniqueInput
    update: XOR<UserQuizAttemptUpdateWithoutProfileInput, UserQuizAttemptUncheckedUpdateWithoutProfileInput>
    create: XOR<UserQuizAttemptCreateWithoutProfileInput, UserQuizAttemptUncheckedCreateWithoutProfileInput>
  }

  export type UserQuizAttemptUpdateWithWhereUniqueWithoutProfileInput = {
    where: UserQuizAttemptWhereUniqueInput
    data: XOR<UserQuizAttemptUpdateWithoutProfileInput, UserQuizAttemptUncheckedUpdateWithoutProfileInput>
  }

  export type UserQuizAttemptUpdateManyWithWhereWithoutProfileInput = {
    where: UserQuizAttemptScalarWhereInput
    data: XOR<UserQuizAttemptUpdateManyMutationInput, UserQuizAttemptUncheckedUpdateManyWithoutProfileInput>
  }

  export type UserQuizAttemptScalarWhereInput = {
    AND?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
    OR?: UserQuizAttemptScalarWhereInput[]
    NOT?: UserQuizAttemptScalarWhereInput | UserQuizAttemptScalarWhereInput[]
    id?: StringFilter<"UserQuizAttempt"> | string
    quizId?: StringFilter<"UserQuizAttempt"> | string
    startedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserQuizAttempt"> | Date | string | null
    score?: IntFilter<"UserQuizAttempt"> | number
    isPassed?: BoolFilter<"UserQuizAttempt"> | boolean
    feedback?: StringNullableFilter<"UserQuizAttempt"> | string | null
    createdAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuizAttempt"> | Date | string
    profileId?: StringFilter<"UserQuizAttempt"> | string
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutProfileInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutProfileInput, UserBadgeUncheckedUpdateWithoutProfileInput>
    create: XOR<UserBadgeCreateWithoutProfileInput, UserBadgeUncheckedCreateWithoutProfileInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutProfileInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutProfileInput, UserBadgeUncheckedUpdateWithoutProfileInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutProfileInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutProfileInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    badgeId?: StringFilter<"UserBadge"> | string
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    createdAt?: DateTimeFilter<"UserBadge"> | Date | string
    updatedAt?: DateTimeFilter<"UserBadge"> | Date | string
    profileId?: StringFilter<"UserBadge"> | string
  }

  export type UserStreakUpsertWithoutProfileInput = {
    update: XOR<UserStreakUpdateWithoutProfileInput, UserStreakUncheckedUpdateWithoutProfileInput>
    create: XOR<UserStreakCreateWithoutProfileInput, UserStreakUncheckedCreateWithoutProfileInput>
    where?: UserStreakWhereInput
  }

  export type UserStreakUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserStreakWhereInput
    data: XOR<UserStreakUpdateWithoutProfileInput, UserStreakUncheckedUpdateWithoutProfileInput>
  }

  export type UserStreakUpdateWithoutProfileInput = {
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserStreakUncheckedUpdateWithoutProfileInput = {
    streak?: IntFieldUpdateOperationsInput | number
    streakDays?: IntFieldUpdateOperationsInput | number
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestStreak?: IntFieldUpdateOperationsInput | number
    longestStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    longestEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateWithoutProgressInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutProgressInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutProgressInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutProgressInput, UserProfileUncheckedCreateWithoutProgressInput>
  }

  export type TutorialCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutProgressInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutProgressInput, TutorialUncheckedCreateWithoutProgressInput>
  }

  export type UserQuizAttemptCreateWithoutUserProgressInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    questionAttempts?: UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateWithoutUserProgressInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    questionAttempts?: UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput
  }

  export type UserQuizAttemptCreateOrConnectWithoutUserProgressInput = {
    where: UserQuizAttemptWhereUniqueInput
    create: XOR<UserQuizAttemptCreateWithoutUserProgressInput, UserQuizAttemptUncheckedCreateWithoutUserProgressInput>
  }

  export type UserProfileUpsertWithoutProgressInput = {
    update: XOR<UserProfileUpdateWithoutProgressInput, UserProfileUncheckedUpdateWithoutProgressInput>
    create: XOR<UserProfileCreateWithoutProgressInput, UserProfileUncheckedCreateWithoutProgressInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutProgressInput, UserProfileUncheckedUpdateWithoutProgressInput>
  }

  export type UserProfileUpdateWithoutProgressInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutProgressInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type TutorialUpsertWithoutProgressInput = {
    update: XOR<TutorialUpdateWithoutProgressInput, TutorialUncheckedUpdateWithoutProgressInput>
    create: XOR<TutorialCreateWithoutProgressInput, TutorialUncheckedCreateWithoutProgressInput>
    where?: TutorialWhereInput
  }

  export type TutorialUpdateToOneWithWhereWithoutProgressInput = {
    where?: TutorialWhereInput
    data: XOR<TutorialUpdateWithoutProgressInput, TutorialUncheckedUpdateWithoutProgressInput>
  }

  export type TutorialUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type UserQuizAttemptUpsertWithoutUserProgressInput = {
    update: XOR<UserQuizAttemptUpdateWithoutUserProgressInput, UserQuizAttemptUncheckedUpdateWithoutUserProgressInput>
    create: XOR<UserQuizAttemptCreateWithoutUserProgressInput, UserQuizAttemptUncheckedCreateWithoutUserProgressInput>
    where?: UserQuizAttemptWhereInput
  }

  export type UserQuizAttemptUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: UserQuizAttemptWhereInput
    data: XOR<UserQuizAttemptUpdateWithoutUserProgressInput, UserQuizAttemptUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserQuizAttemptUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    questionAttempts?: UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    questionAttempts?: UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput
  }

  export type UserProfileCreateWithoutStreaksInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutStreaksInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutStreaksInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutStreaksInput, UserProfileUncheckedCreateWithoutStreaksInput>
  }

  export type UserProfileUpsertWithoutStreaksInput = {
    update: XOR<UserProfileUpdateWithoutStreaksInput, UserProfileUncheckedUpdateWithoutStreaksInput>
    create: XOR<UserProfileCreateWithoutStreaksInput, UserProfileUncheckedCreateWithoutStreaksInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutStreaksInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutStreaksInput, UserProfileUncheckedUpdateWithoutStreaksInput>
  }

  export type UserProfileUpdateWithoutStreaksInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutStreaksInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserProfileCreateWithoutQuizAttemptsInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutQuizAttemptsInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutQuizAttemptsInput, UserProfileUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuizCreateWithoutAttemptsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type UserQuestionAttemptCreateWithoutQuizAttemptsInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActivities?: LastActivityCreateNestedManyWithoutQuestionAttemptInput
  }

  export type UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuestionAttemptInput
  }

  export type UserQuestionAttemptCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserQuestionAttemptWhereUniqueInput
    create: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserQuestionAttemptCreateManyQuizAttemptsInputEnvelope = {
    data: UserQuestionAttemptCreateManyQuizAttemptsInput | UserQuestionAttemptCreateManyQuizAttemptsInput[]
    skipDuplicates?: boolean
  }

  export type LastActivityCreateWithoutQuizAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutQuizAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutQuizAttemptInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput>
  }

  export type LastActivityCreateManyQuizAttemptInputEnvelope = {
    data: LastActivityCreateManyQuizAttemptInput | LastActivityCreateManyQuizAttemptInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutUserQuizAttemptInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutProgressInput
    tutorial: TutorialCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutUserQuizAttemptInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserProgressCreateOrConnectWithoutUserQuizAttemptInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput>
  }

  export type UserProgressCreateManyUserQuizAttemptInputEnvelope = {
    data: UserProgressCreateManyUserQuizAttemptInput | UserProgressCreateManyUserQuizAttemptInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutQuizAttemptsInput = {
    update: XOR<UserProfileUpdateWithoutQuizAttemptsInput, UserProfileUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserProfileCreateWithoutQuizAttemptsInput, UserProfileUncheckedCreateWithoutQuizAttemptsInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutQuizAttemptsInput, UserProfileUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserProfileUpdateWithoutQuizAttemptsInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutQuizAttemptsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserQuestionAttemptUpsertWithWhereUniqueWithoutQuizAttemptsInput = {
    where: UserQuestionAttemptWhereUniqueInput
    update: XOR<UserQuestionAttemptUpdateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserQuestionAttemptCreateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type UserQuestionAttemptUpdateWithWhereUniqueWithoutQuizAttemptsInput = {
    where: UserQuestionAttemptWhereUniqueInput
    data: XOR<UserQuestionAttemptUpdateWithoutQuizAttemptsInput, UserQuestionAttemptUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserQuestionAttemptUpdateManyWithWhereWithoutQuizAttemptsInput = {
    where: UserQuestionAttemptScalarWhereInput
    data: XOR<UserQuestionAttemptUpdateManyMutationInput, UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsInput>
  }

  export type UserQuestionAttemptScalarWhereInput = {
    AND?: UserQuestionAttemptScalarWhereInput | UserQuestionAttemptScalarWhereInput[]
    OR?: UserQuestionAttemptScalarWhereInput[]
    NOT?: UserQuestionAttemptScalarWhereInput | UserQuestionAttemptScalarWhereInput[]
    id?: StringFilter<"UserQuestionAttempt"> | string
    questionId?: StringFilter<"UserQuestionAttempt"> | string
    selectedOption?: StringFilter<"UserQuestionAttempt"> | string
    isCorrect?: BoolFilter<"UserQuestionAttempt"> | boolean
    xpEarned?: IntFilter<"UserQuestionAttempt"> | number
    userQuizAttemptId?: StringFilter<"UserQuestionAttempt"> | string
    createdAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"UserQuestionAttempt"> | Date | string
  }

  export type LastActivityUpsertWithWhereUniqueWithoutQuizAttemptInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutQuizAttemptInput, LastActivityUncheckedUpdateWithoutQuizAttemptInput>
    create: XOR<LastActivityCreateWithoutQuizAttemptInput, LastActivityUncheckedCreateWithoutQuizAttemptInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutQuizAttemptInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutQuizAttemptInput, LastActivityUncheckedUpdateWithoutQuizAttemptInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutQuizAttemptInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutQuizAttemptInput>
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserQuizAttemptInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserQuizAttemptInput, UserProgressUncheckedUpdateWithoutUserQuizAttemptInput>
    create: XOR<UserProgressCreateWithoutUserQuizAttemptInput, UserProgressUncheckedCreateWithoutUserQuizAttemptInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserQuizAttemptInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserQuizAttemptInput, UserProgressUncheckedUpdateWithoutUserQuizAttemptInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserQuizAttemptInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserQuizAttemptInput>
  }

  export type UserQuizAttemptCreateWithoutQuestionAttemptsInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateWithoutQuestionAttemptsInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptCreateOrConnectWithoutQuestionAttemptsInput = {
    where: UserQuizAttemptWhereUniqueInput
    create: XOR<UserQuizAttemptCreateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
  }

  export type LastActivityCreateWithoutQuestionAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutQuestionAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutQuestionAttemptInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput>
  }

  export type LastActivityCreateManyQuestionAttemptInputEnvelope = {
    data: LastActivityCreateManyQuestionAttemptInput | LastActivityCreateManyQuestionAttemptInput[]
    skipDuplicates?: boolean
  }

  export type UserQuizAttemptUpsertWithoutQuestionAttemptsInput = {
    update: XOR<UserQuizAttemptUpdateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
    create: XOR<UserQuizAttemptCreateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedCreateWithoutQuestionAttemptsInput>
    where?: UserQuizAttemptWhereInput
  }

  export type UserQuizAttemptUpdateToOneWithWhereWithoutQuestionAttemptsInput = {
    where?: UserQuizAttemptWhereInput
    data: XOR<UserQuizAttemptUpdateWithoutQuestionAttemptsInput, UserQuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput>
  }

  export type UserQuizAttemptUpdateWithoutQuestionAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateWithoutQuestionAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type LastActivityUpsertWithWhereUniqueWithoutQuestionAttemptInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutQuestionAttemptInput, LastActivityUncheckedUpdateWithoutQuestionAttemptInput>
    create: XOR<LastActivityCreateWithoutQuestionAttemptInput, LastActivityUncheckedCreateWithoutQuestionAttemptInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutQuestionAttemptInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutQuestionAttemptInput, LastActivityUncheckedUpdateWithoutQuestionAttemptInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutQuestionAttemptInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutQuestionAttemptInput>
  }

  export type QuizCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
  }

  export type QuizUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
  }

  export type QuizCreateOrConnectWithoutLastActivitiesInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutLastActivitiesInput, QuizUncheckedCreateWithoutLastActivitiesInput>
  }

  export type TutorialCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutLastActivitiesInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutLastActivitiesInput, TutorialUncheckedCreateWithoutLastActivitiesInput>
  }

  export type RoadmapCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutRoadmapsInput
    steps?: RoadmapStepCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutRoadmapInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutLastActivitiesInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutLastActivitiesInput, RoadmapUncheckedCreateWithoutLastActivitiesInput>
  }

  export type RoadmapStepCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
  }

  export type RoadmapStepUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
  }

  export type RoadmapStepCreateOrConnectWithoutLastActivitiesInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutLastActivitiesInput, RoadmapStepUncheckedCreateWithoutLastActivitiesInput>
  }

  export type UserQuizAttemptCreateWithoutLastActivitiesInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutQuizAttemptsInput
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    questionAttempts?: UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput
    userProgress?: UserProgressCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    questionAttempts?: UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptCreateOrConnectWithoutLastActivitiesInput = {
    where: UserQuizAttemptWhereUniqueInput
    create: XOR<UserQuizAttemptCreateWithoutLastActivitiesInput, UserQuizAttemptUncheckedCreateWithoutLastActivitiesInput>
  }

  export type UserQuestionAttemptCreateWithoutLastActivitiesInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    quizAttempts: UserQuizAttemptCreateNestedOneWithoutQuestionAttemptsInput
  }

  export type UserQuestionAttemptUncheckedCreateWithoutLastActivitiesInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    userQuizAttemptId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuestionAttemptCreateOrConnectWithoutLastActivitiesInput = {
    where: UserQuestionAttemptWhereUniqueInput
    create: XOR<UserQuestionAttemptCreateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedCreateWithoutLastActivitiesInput>
  }

  export type UserProfileCreateWithoutLastActivitiesInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutLastActivitiesInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutLastActivitiesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput>
  }

  export type QuizUpsertWithoutLastActivitiesInput = {
    update: XOR<QuizUpdateWithoutLastActivitiesInput, QuizUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<QuizCreateWithoutLastActivitiesInput, QuizUncheckedCreateWithoutLastActivitiesInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutLastActivitiesInput, QuizUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type QuizUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
  }

  export type QuizUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
  }

  export type TutorialUpsertWithoutLastActivitiesInput = {
    update: XOR<TutorialUpdateWithoutLastActivitiesInput, TutorialUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<TutorialCreateWithoutLastActivitiesInput, TutorialUncheckedCreateWithoutLastActivitiesInput>
    where?: TutorialWhereInput
  }

  export type TutorialUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: TutorialWhereInput
    data: XOR<TutorialUpdateWithoutLastActivitiesInput, TutorialUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type TutorialUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type RoadmapUpsertWithoutLastActivitiesInput = {
    update: XOR<RoadmapUpdateWithoutLastActivitiesInput, RoadmapUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<RoadmapCreateWithoutLastActivitiesInput, RoadmapUncheckedCreateWithoutLastActivitiesInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutLastActivitiesInput, RoadmapUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type RoadmapUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
    steps?: RoadmapStepUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: RoadmapStepUncheckedUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapStepUpsertWithoutLastActivitiesInput = {
    update: XOR<RoadmapStepUpdateWithoutLastActivitiesInput, RoadmapStepUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<RoadmapStepCreateWithoutLastActivitiesInput, RoadmapStepUncheckedCreateWithoutLastActivitiesInput>
    where?: RoadmapStepWhereInput
  }

  export type RoadmapStepUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: RoadmapStepWhereInput
    data: XOR<RoadmapStepUpdateWithoutLastActivitiesInput, RoadmapStepUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type RoadmapStepUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
  }

  export type UserQuizAttemptUpsertWithoutLastActivitiesInput = {
    update: XOR<UserQuizAttemptUpdateWithoutLastActivitiesInput, UserQuizAttemptUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<UserQuizAttemptCreateWithoutLastActivitiesInput, UserQuizAttemptUncheckedCreateWithoutLastActivitiesInput>
    where?: UserQuizAttemptWhereInput
  }

  export type UserQuizAttemptUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: UserQuizAttemptWhereInput
    data: XOR<UserQuizAttemptUpdateWithoutLastActivitiesInput, UserQuizAttemptUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserQuizAttemptUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    questionAttempts?: UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    questionAttempts?: UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuestionAttemptUpsertWithoutLastActivitiesInput = {
    update: XOR<UserQuestionAttemptUpdateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<UserQuestionAttemptCreateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedCreateWithoutLastActivitiesInput>
    where?: UserQuestionAttemptWhereInput
  }

  export type UserQuestionAttemptUpdateToOneWithWhereWithoutLastActivitiesInput = {
    where?: UserQuestionAttemptWhereInput
    data: XOR<UserQuestionAttemptUpdateWithoutLastActivitiesInput, UserQuestionAttemptUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserQuestionAttemptUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizAttempts?: UserQuizAttemptUpdateOneRequiredWithoutQuestionAttemptsNestedInput
  }

  export type UserQuestionAttemptUncheckedUpdateWithoutLastActivitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    userQuizAttemptId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUpsertWithWhereUniqueWithoutLastActivitiesInput = {
    where: UserProfileWhereUniqueInput
    update: XOR<UserProfileUpdateWithoutLastActivitiesInput, UserProfileUncheckedUpdateWithoutLastActivitiesInput>
    create: XOR<UserProfileCreateWithoutLastActivitiesInput, UserProfileUncheckedCreateWithoutLastActivitiesInput>
  }

  export type UserProfileUpdateWithWhereUniqueWithoutLastActivitiesInput = {
    where: UserProfileWhereUniqueInput
    data: XOR<UserProfileUpdateWithoutLastActivitiesInput, UserProfileUncheckedUpdateWithoutLastActivitiesInput>
  }

  export type UserProfileUpdateManyWithWhereWithoutLastActivitiesInput = {
    where: UserProfileScalarWhereInput
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyWithoutLastActivitiesInput>
  }

  export type UserProfileScalarWhereInput = {
    AND?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    OR?: UserProfileScalarWhereInput[]
    NOT?: UserProfileScalarWhereInput | UserProfileScalarWhereInput[]
    userId?: StringFilter<"UserProfile"> | string
    bio?: StringNullableFilter<"UserProfile"> | string | null
    location?: StringNullableFilter<"UserProfile"> | string | null
    website?: StringNullableFilter<"UserProfile"> | string | null
    socialLinks?: StringNullableListFilter<"UserProfile">
    avatar?: StringNullableFilter<"UserProfile"> | string | null
    rank?: StringFilter<"UserProfile"> | string
    level?: IntFilter<"UserProfile"> | number
    xp?: IntFilter<"UserProfile"> | number
    levelProgress?: IntFilter<"UserProfile"> | number
    levelProgressMax?: IntFilter<"UserProfile"> | number
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    completedQuizzes?: StringNullableListFilter<"UserProfile">
    completedTutorials?: StringNullableListFilter<"UserProfile">
    completedRoadmaps?: StringNullableListFilter<"UserProfile">
    completedSteps?: StringNullableListFilter<"UserProfile">
    completedChallenges?: StringNullableListFilter<"UserProfile">
    completedInterviews?: StringNullableListFilter<"UserProfile">
    completedProjects?: StringNullableListFilter<"UserProfile">
    theme?: EnumThemeNameFilter<"UserProfile"> | $Enums.ThemeName
  }

  export type UserProfileCreateWithoutUserBadgesInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutUserBadgesInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutUserBadgesInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserBadgesInput, UserProfileUncheckedCreateWithoutUserBadgesInput>
  }

  export type BadgeCreateWithoutBadgesInput = {
    id?: string
    name: string
    imageUrl: string
    xpReq?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeUncheckedCreateWithoutBadgesInput = {
    id?: string
    name: string
    imageUrl: string
    xpReq?: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BadgeCreateOrConnectWithoutBadgesInput = {
    where: BadgeWhereUniqueInput
    create: XOR<BadgeCreateWithoutBadgesInput, BadgeUncheckedCreateWithoutBadgesInput>
  }

  export type UserProfileUpsertWithoutUserBadgesInput = {
    update: XOR<UserProfileUpdateWithoutUserBadgesInput, UserProfileUncheckedUpdateWithoutUserBadgesInput>
    create: XOR<UserProfileCreateWithoutUserBadgesInput, UserProfileUncheckedCreateWithoutUserBadgesInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserBadgesInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserBadgesInput, UserProfileUncheckedUpdateWithoutUserBadgesInput>
  }

  export type UserProfileUpdateWithoutUserBadgesInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutUserBadgesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type BadgeUpsertWithoutBadgesInput = {
    update: XOR<BadgeUpdateWithoutBadgesInput, BadgeUncheckedUpdateWithoutBadgesInput>
    create: XOR<BadgeCreateWithoutBadgesInput, BadgeUncheckedCreateWithoutBadgesInput>
    where?: BadgeWhereInput
  }

  export type BadgeUpdateToOneWithWhereWithoutBadgesInput = {
    where?: BadgeWhereInput
    data: XOR<BadgeUpdateWithoutBadgesInput, BadgeUncheckedUpdateWithoutBadgesInput>
  }

  export type BadgeUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BadgeUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    xpReq?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateWithoutBadgeInput = {
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutUserBadgesInput
  }

  export type UserBadgeUncheckedCreateWithoutBadgeInput = {
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserBadgeCreateOrConnectWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeCreateManyBadgeInputEnvelope = {
    data: UserBadgeCreateManyBadgeInput | UserBadgeCreateManyBadgeInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
    create: XOR<UserBadgeCreateWithoutBadgeInput, UserBadgeUncheckedCreateWithoutBadgeInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutBadgeInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutBadgeInput, UserBadgeUncheckedUpdateWithoutBadgeInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutBadgeInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutBadgeInput>
  }

  export type UserProfileCreateWithoutCoinWalletInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    user: UserCreateNestedOneWithoutProfileInput
    coinTransaction?: CoinTransactionCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutCoinWalletInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinTransaction?: CoinTransactionUncheckedCreateNestedManyWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutCoinWalletInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutCoinWalletInput, UserProfileUncheckedCreateWithoutCoinWalletInput>
  }

  export type UserProfileUpsertWithoutCoinWalletInput = {
    update: XOR<UserProfileUpdateWithoutCoinWalletInput, UserProfileUncheckedUpdateWithoutCoinWalletInput>
    create: XOR<UserProfileCreateWithoutCoinWalletInput, UserProfileUncheckedCreateWithoutCoinWalletInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutCoinWalletInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutCoinWalletInput, UserProfileUncheckedUpdateWithoutCoinWalletInput>
  }

  export type UserProfileUpdateWithoutCoinWalletInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutCoinWalletInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileCreateWithoutCoinTransactionInput = {
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletCreateNestedOneWithoutProfileInput
    user: UserCreateNestedOneWithoutProfileInput
    lastActivities?: LastActivityCreateNestedManyWithoutProfileInput
    progress?: UserProgressCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeCreateNestedManyWithoutProfileInput
    streaks?: UserStreakCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateWithoutCoinTransactionInput = {
    userId: string
    bio?: string | null
    location?: string | null
    website?: string | null
    socialLinks?: UserProfileCreatesocialLinksInput | string[]
    avatar?: string | null
    rank?: string
    level?: number
    xp?: number
    levelProgress?: number
    levelProgressMax?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    lastLogin?: Date | string | null
    completedQuizzes?: UserProfileCreatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileCreatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileCreatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileCreatecompletedStepsInput | string[]
    completedChallenges?: UserProfileCreatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileCreatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileCreatecompletedProjectsInput | string[]
    theme?: $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedCreateNestedOneWithoutProfileInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutProfileInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutProfileInput
    quizAttempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutProfileInput
    userBadges?: UserBadgeUncheckedCreateNestedManyWithoutProfileInput
    streaks?: UserStreakUncheckedCreateNestedOneWithoutProfileInput
  }

  export type UserProfileCreateOrConnectWithoutCoinTransactionInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutCoinTransactionInput, UserProfileUncheckedCreateWithoutCoinTransactionInput>
  }

  export type UserProfileUpsertWithoutCoinTransactionInput = {
    update: XOR<UserProfileUpdateWithoutCoinTransactionInput, UserProfileUncheckedUpdateWithoutCoinTransactionInput>
    create: XOR<UserProfileCreateWithoutCoinTransactionInput, UserProfileUncheckedCreateWithoutCoinTransactionInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutCoinTransactionInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutCoinTransactionInput, UserProfileUncheckedUpdateWithoutCoinTransactionInput>
  }

  export type UserProfileUpdateWithoutCoinTransactionInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    lastActivities?: LastActivityUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutCoinTransactionInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserCreateWithoutRoadmapsInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutRoadmapsInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutUserInput
    adminActivityLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutRoadmapsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
  }

  export type RoadmapStepCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutRoadmapInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapStepCreateManyRoadmapInputEnvelope = {
    data: RoadmapStepCreateManyRoadmapInput | RoadmapStepCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapProgressCreateWithoutRoadmapInput = {
    id?: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoadmapProgressInput
  }

  export type RoadmapProgressUncheckedCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressCreateOrConnectWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    create: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapProgressCreateManyRoadmapInputEnvelope = {
    data: RoadmapProgressCreateManyRoadmapInput | RoadmapProgressCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type LastActivityCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutRoadmapInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput>
  }

  export type LastActivityCreateManyRoadmapInputEnvelope = {
    data: LastActivityCreateManyRoadmapInput | LastActivityCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRoadmapsInput = {
    update: XOR<UserUpdateWithoutRoadmapsInput, UserUncheckedUpdateWithoutRoadmapsInput>
    create: XOR<UserCreateWithoutRoadmapsInput, UserUncheckedCreateWithoutRoadmapsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoadmapsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoadmapsInput, UserUncheckedUpdateWithoutRoadmapsInput>
  }

  export type UserUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutRoadmapsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutUserNestedInput
    adminActivityLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type RoadmapStepUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapStepWhereUniqueInput
    update: XOR<RoadmapStepUpdateWithoutRoadmapInput, RoadmapStepUncheckedUpdateWithoutRoadmapInput>
    create: XOR<RoadmapStepCreateWithoutRoadmapInput, RoadmapStepUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapStepUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapStepWhereUniqueInput
    data: XOR<RoadmapStepUpdateWithoutRoadmapInput, RoadmapStepUncheckedUpdateWithoutRoadmapInput>
  }

  export type RoadmapStepUpdateManyWithWhereWithoutRoadmapInput = {
    where: RoadmapStepScalarWhereInput
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type RoadmapStepScalarWhereInput = {
    AND?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
    OR?: RoadmapStepScalarWhereInput[]
    NOT?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
    id?: StringFilter<"RoadmapStep"> | string
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringNullableFilter<"RoadmapStep"> | string | null
    order?: IntFilter<"RoadmapStep"> | number
    status?: EnumStepStatusFilter<"RoadmapStep"> | $Enums.StepStatus
    progress?: IntFilter<"RoadmapStep"> | number
    completedAt?: DateTimeNullableFilter<"RoadmapStep"> | Date | string | null
    completed?: BoolFilter<"RoadmapStep"> | boolean
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    parentId?: StringNullableFilter<"RoadmapStep"> | string | null
    roadmapId?: StringNullableFilter<"RoadmapStep"> | string | null
  }

  export type RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    update: XOR<RoadmapProgressUpdateWithoutRoadmapInput, RoadmapProgressUncheckedUpdateWithoutRoadmapInput>
    create: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    data: XOR<RoadmapProgressUpdateWithoutRoadmapInput, RoadmapProgressUncheckedUpdateWithoutRoadmapInput>
  }

  export type RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput = {
    where: RoadmapProgressScalarWhereInput
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type LastActivityUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutRoadmapInput, LastActivityUncheckedUpdateWithoutRoadmapInput>
    create: XOR<LastActivityCreateWithoutRoadmapInput, LastActivityUncheckedCreateWithoutRoadmapInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutRoadmapInput, LastActivityUncheckedUpdateWithoutRoadmapInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutRoadmapInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type UserCreateWithoutRoadmapProgressInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutCreatedByInput
    adminActivityLogs?: AdminActivityLogCreateNestedManyWithoutAdminInput
  }

  export type UserUncheckedCreateWithoutRoadmapProgressInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutCreatedByInput
    adminActivityLogs?: AdminActivityLogUncheckedCreateNestedManyWithoutAdminInput
  }

  export type UserCreateOrConnectWithoutRoadmapProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoadmapProgressInput, UserUncheckedCreateWithoutRoadmapProgressInput>
  }

  export type RoadmapCreateWithoutRoadmapProgressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutRoadmapsInput
    steps?: RoadmapStepCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutRoadmapProgressInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutRoadmapProgressInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutRoadmapProgressInput, RoadmapUncheckedCreateWithoutRoadmapProgressInput>
  }

  export type UserUpsertWithoutRoadmapProgressInput = {
    update: XOR<UserUpdateWithoutRoadmapProgressInput, UserUncheckedUpdateWithoutRoadmapProgressInput>
    create: XOR<UserCreateWithoutRoadmapProgressInput, UserUncheckedCreateWithoutRoadmapProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoadmapProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoadmapProgressInput, UserUncheckedUpdateWithoutRoadmapProgressInput>
  }

  export type UserUpdateWithoutRoadmapProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutCreatedByNestedInput
    adminActivityLogs?: AdminActivityLogUpdateManyWithoutAdminNestedInput
  }

  export type UserUncheckedUpdateWithoutRoadmapProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutCreatedByNestedInput
    adminActivityLogs?: AdminActivityLogUncheckedUpdateManyWithoutAdminNestedInput
  }

  export type RoadmapUpsertWithoutRoadmapProgressInput = {
    update: XOR<RoadmapUpdateWithoutRoadmapProgressInput, RoadmapUncheckedUpdateWithoutRoadmapProgressInput>
    create: XOR<RoadmapCreateWithoutRoadmapProgressInput, RoadmapUncheckedCreateWithoutRoadmapProgressInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutRoadmapProgressInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutRoadmapProgressInput, RoadmapUncheckedUpdateWithoutRoadmapProgressInput>
  }

  export type RoadmapUpdateWithoutRoadmapProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
    steps?: RoadmapStepUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutRoadmapProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: RoadmapStepUncheckedUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapStepCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutChildrenInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutChildrenInput, RoadmapStepUncheckedCreateWithoutChildrenInput>
  }

  export type RoadmapStepCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmapId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutParentInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput>
  }

  export type RoadmapStepCreateManyParentInputEnvelope = {
    data: RoadmapStepCreateManyParentInput | RoadmapStepCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutRoadmapsInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutStepsInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutStepsInput, RoadmapUncheckedCreateWithoutStepsInput>
  }

  export type TutorialCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutStepsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutStepsInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput>
  }

  export type TutorialCreateManyStepsInputEnvelope = {
    data: TutorialCreateManyStepsInput | TutorialCreateManyStepsInput[]
    skipDuplicates?: boolean
  }

  export type QuizCreateWithoutStepsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutStepsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutStepsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput>
  }

  export type QuizCreateManyStepsInputEnvelope = {
    data: QuizCreateManyStepsInput | QuizCreateManyStepsInput[]
    skipDuplicates?: boolean
  }

  export type LastActivityCreateWithoutRoadmapStepInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutRoadmapStepInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutRoadmapStepInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput>
  }

  export type LastActivityCreateManyRoadmapStepInputEnvelope = {
    data: LastActivityCreateManyRoadmapStepInput | LastActivityCreateManyRoadmapStepInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapStepUpsertWithoutChildrenInput = {
    update: XOR<RoadmapStepUpdateWithoutChildrenInput, RoadmapStepUncheckedUpdateWithoutChildrenInput>
    create: XOR<RoadmapStepCreateWithoutChildrenInput, RoadmapStepUncheckedCreateWithoutChildrenInput>
    where?: RoadmapStepWhereInput
  }

  export type RoadmapStepUpdateToOneWithWhereWithoutChildrenInput = {
    where?: RoadmapStepWhereInput
    data: XOR<RoadmapStepUpdateWithoutChildrenInput, RoadmapStepUncheckedUpdateWithoutChildrenInput>
  }

  export type RoadmapStepUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUpsertWithWhereUniqueWithoutParentInput = {
    where: RoadmapStepWhereUniqueInput
    update: XOR<RoadmapStepUpdateWithoutParentInput, RoadmapStepUncheckedUpdateWithoutParentInput>
    create: XOR<RoadmapStepCreateWithoutParentInput, RoadmapStepUncheckedCreateWithoutParentInput>
  }

  export type RoadmapStepUpdateWithWhereUniqueWithoutParentInput = {
    where: RoadmapStepWhereUniqueInput
    data: XOR<RoadmapStepUpdateWithoutParentInput, RoadmapStepUncheckedUpdateWithoutParentInput>
  }

  export type RoadmapStepUpdateManyWithWhereWithoutParentInput = {
    where: RoadmapStepScalarWhereInput
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyWithoutParentInput>
  }

  export type RoadmapUpsertWithoutStepsInput = {
    update: XOR<RoadmapUpdateWithoutStepsInput, RoadmapUncheckedUpdateWithoutStepsInput>
    create: XOR<RoadmapCreateWithoutStepsInput, RoadmapUncheckedCreateWithoutStepsInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutStepsInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutStepsInput, RoadmapUncheckedUpdateWithoutStepsInput>
  }

  export type RoadmapUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutRoadmapsNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type TutorialUpsertWithWhereUniqueWithoutStepsInput = {
    where: TutorialWhereUniqueInput
    update: XOR<TutorialUpdateWithoutStepsInput, TutorialUncheckedUpdateWithoutStepsInput>
    create: XOR<TutorialCreateWithoutStepsInput, TutorialUncheckedCreateWithoutStepsInput>
  }

  export type TutorialUpdateWithWhereUniqueWithoutStepsInput = {
    where: TutorialWhereUniqueInput
    data: XOR<TutorialUpdateWithoutStepsInput, TutorialUncheckedUpdateWithoutStepsInput>
  }

  export type TutorialUpdateManyWithWhereWithoutStepsInput = {
    where: TutorialScalarWhereInput
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyWithoutStepsInput>
  }

  export type TutorialScalarWhereInput = {
    AND?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
    OR?: TutorialScalarWhereInput[]
    NOT?: TutorialScalarWhereInput | TutorialScalarWhereInput[]
    id?: StringFilter<"Tutorial"> | string
    title?: StringFilter<"Tutorial"> | string
    description?: StringNullableFilter<"Tutorial"> | string | null
    content?: StringFilter<"Tutorial"> | string
    category?: StringNullableFilter<"Tutorial"> | string | null
    authorId?: StringNullableFilter<"Tutorial"> | string | null
    likes?: IntFilter<"Tutorial"> | number
    views?: IntFilter<"Tutorial"> | number
    isLocked?: BoolFilter<"Tutorial"> | boolean
    cost?: IntFilter<"Tutorial"> | number
    hasChallenge?: BoolFilter<"Tutorial"> | boolean
    difficulty?: EnumDifficultyLevelFilter<"Tutorial"> | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFilter<"Tutorial"> | $Enums.TutorialStatus
    createdAt?: DateTimeFilter<"Tutorial"> | Date | string
    updatedAt?: DateTimeFilter<"Tutorial"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Tutorial"> | Date | string | null
    stepsId?: StringNullableFilter<"Tutorial"> | string | null
    tutorialId?: StringNullableFilter<"Tutorial"> | string | null
    nextTutorialId?: StringNullableFilter<"Tutorial"> | string | null
  }

  export type QuizUpsertWithWhereUniqueWithoutStepsInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutStepsInput, QuizUncheckedUpdateWithoutStepsInput>
    create: XOR<QuizCreateWithoutStepsInput, QuizUncheckedCreateWithoutStepsInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutStepsInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutStepsInput, QuizUncheckedUpdateWithoutStepsInput>
  }

  export type QuizUpdateManyWithWhereWithoutStepsInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutStepsInput>
  }

  export type QuizScalarWhereInput = {
    AND?: QuizScalarWhereInput | QuizScalarWhereInput[]
    OR?: QuizScalarWhereInput[]
    NOT?: QuizScalarWhereInput | QuizScalarWhereInput[]
    id?: StringFilter<"Quiz"> | string
    title?: StringFilter<"Quiz"> | string
    slug?: StringFilter<"Quiz"> | string
    isTimed?: BoolFilter<"Quiz"> | boolean
    timeLimit?: IntNullableFilter<"Quiz"> | number | null
    maxScore?: IntFilter<"Quiz"> | number
    passPercentage?: IntFilter<"Quiz"> | number
    difficulty?: EnumDifficultyLevelFilter<"Quiz"> | $Enums.DifficultyLevel
    order?: IntNullableFilter<"Quiz"> | number | null
    tutorialLocked?: BoolNullableFilter<"Quiz"> | boolean | null
    questionCount?: IntNullableFilter<"Quiz"> | number | null
    estimatedDuration?: IntNullableFilter<"Quiz"> | number | null
    tutorialId?: StringFilter<"Quiz"> | string
    stepsId?: StringNullableFilter<"Quiz"> | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Quiz"> | Date | string | null
  }

  export type LastActivityUpsertWithWhereUniqueWithoutRoadmapStepInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutRoadmapStepInput, LastActivityUncheckedUpdateWithoutRoadmapStepInput>
    create: XOR<LastActivityCreateWithoutRoadmapStepInput, LastActivityUncheckedCreateWithoutRoadmapStepInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutRoadmapStepInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutRoadmapStepInput, LastActivityUncheckedUpdateWithoutRoadmapStepInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutRoadmapStepInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutRoadmapStepInput>
  }

  export type QuizCreateWithoutTutorialInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutTutorialInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutTutorialInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput>
  }

  export type QuizCreateManyTutorialInputEnvelope = {
    data: QuizCreateManyTutorialInput | QuizCreateManyTutorialInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressCreateWithoutTutorialInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutProgressInput
    userQuizAttempt?: UserQuizAttemptCreateNestedOneWithoutUserProgressInput
  }

  export type UserProgressUncheckedCreateWithoutTutorialInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserProgressCreateOrConnectWithoutTutorialInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput>
  }

  export type UserProgressCreateManyTutorialInputEnvelope = {
    data: UserProgressCreateManyTutorialInput | UserProgressCreateManyTutorialInput[]
    skipDuplicates?: boolean
  }

  export type TagCreateWithoutTutorialsInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizCreateNestedManyWithoutTagsInput
  }

  export type TagUncheckedCreateWithoutTutorialsInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    quizzes?: QuizUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagCreateOrConnectWithoutTutorialsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput>
  }

  export type RoadmapStepCreateWithoutTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    quizzes?: QuizCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    quizzes?: QuizUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutTutorialsInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutTutorialsInput, RoadmapStepUncheckedCreateWithoutTutorialsInput>
  }

  export type TutorialCreateWithoutRelatedTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutRelatedTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutRelatedTutorialsInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutRelatedTutorialsInput, TutorialUncheckedCreateWithoutRelatedTutorialsInput>
  }

  export type TutorialCreateWithoutPreviousTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutPreviousTutorialsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutPreviousTutorialsInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutPreviousTutorialsInput, TutorialUncheckedCreateWithoutPreviousTutorialsInput>
  }

  export type TutorialCreateWithoutNextTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutNextTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutNextTutorialInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput>
  }

  export type TutorialCreateManyNextTutorialInputEnvelope = {
    data: TutorialCreateManyNextTutorialInput | TutorialCreateManyNextTutorialInput[]
    skipDuplicates?: boolean
  }

  export type TutorialCreateWithoutTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutTutorialInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput>
  }

  export type TutorialCreateManyTutorialInputEnvelope = {
    data: TutorialCreateManyTutorialInput | TutorialCreateManyTutorialInput[]
    skipDuplicates?: boolean
  }

  export type LastActivityCreateWithoutTutorialInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quiz?: QuizCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutTutorialInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutTutorialInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput>
  }

  export type LastActivityCreateManyTutorialInputEnvelope = {
    data: LastActivityCreateManyTutorialInput | LastActivityCreateManyTutorialInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithWhereUniqueWithoutTutorialInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutTutorialInput, QuizUncheckedUpdateWithoutTutorialInput>
    create: XOR<QuizCreateWithoutTutorialInput, QuizUncheckedCreateWithoutTutorialInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutTutorialInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutTutorialInput, QuizUncheckedUpdateWithoutTutorialInput>
  }

  export type QuizUpdateManyWithWhereWithoutTutorialInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutTutorialInput>
  }

  export type UserProgressUpsertWithWhereUniqueWithoutTutorialInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutTutorialInput, UserProgressUncheckedUpdateWithoutTutorialInput>
    create: XOR<UserProgressCreateWithoutTutorialInput, UserProgressUncheckedCreateWithoutTutorialInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutTutorialInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutTutorialInput, UserProgressUncheckedUpdateWithoutTutorialInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutTutorialInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutTutorialInput>
  }

  export type TagUpsertWithWhereUniqueWithoutTutorialsInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutTutorialsInput, TagUncheckedUpdateWithoutTutorialsInput>
    create: XOR<TagCreateWithoutTutorialsInput, TagUncheckedCreateWithoutTutorialsInput>
  }

  export type TagUpdateWithWhereUniqueWithoutTutorialsInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutTutorialsInput, TagUncheckedUpdateWithoutTutorialsInput>
  }

  export type TagUpdateManyWithWhereWithoutTutorialsInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutTutorialsInput>
  }

  export type TagScalarWhereInput = {
    AND?: TagScalarWhereInput | TagScalarWhereInput[]
    OR?: TagScalarWhereInput[]
    NOT?: TagScalarWhereInput | TagScalarWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    usageCount?: IntFilter<"Tag"> | number
    type?: EnumTagTypeFilter<"Tag"> | $Enums.TagType
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
  }

  export type RoadmapStepUpsertWithoutTutorialsInput = {
    update: XOR<RoadmapStepUpdateWithoutTutorialsInput, RoadmapStepUncheckedUpdateWithoutTutorialsInput>
    create: XOR<RoadmapStepCreateWithoutTutorialsInput, RoadmapStepUncheckedCreateWithoutTutorialsInput>
    where?: RoadmapStepWhereInput
  }

  export type RoadmapStepUpdateToOneWithWhereWithoutTutorialsInput = {
    where?: RoadmapStepWhereInput
    data: XOR<RoadmapStepUpdateWithoutTutorialsInput, RoadmapStepUncheckedUpdateWithoutTutorialsInput>
  }

  export type RoadmapStepUpdateWithoutTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type TutorialUpsertWithoutRelatedTutorialsInput = {
    update: XOR<TutorialUpdateWithoutRelatedTutorialsInput, TutorialUncheckedUpdateWithoutRelatedTutorialsInput>
    create: XOR<TutorialCreateWithoutRelatedTutorialsInput, TutorialUncheckedCreateWithoutRelatedTutorialsInput>
    where?: TutorialWhereInput
  }

  export type TutorialUpdateToOneWithWhereWithoutRelatedTutorialsInput = {
    where?: TutorialWhereInput
    data: XOR<TutorialUpdateWithoutRelatedTutorialsInput, TutorialUncheckedUpdateWithoutRelatedTutorialsInput>
  }

  export type TutorialUpdateWithoutRelatedTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutRelatedTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUpsertWithoutPreviousTutorialsInput = {
    update: XOR<TutorialUpdateWithoutPreviousTutorialsInput, TutorialUncheckedUpdateWithoutPreviousTutorialsInput>
    create: XOR<TutorialCreateWithoutPreviousTutorialsInput, TutorialUncheckedCreateWithoutPreviousTutorialsInput>
    where?: TutorialWhereInput
  }

  export type TutorialUpdateToOneWithWhereWithoutPreviousTutorialsInput = {
    where?: TutorialWhereInput
    data: XOR<TutorialUpdateWithoutPreviousTutorialsInput, TutorialUncheckedUpdateWithoutPreviousTutorialsInput>
  }

  export type TutorialUpdateWithoutPreviousTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutPreviousTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUpsertWithWhereUniqueWithoutNextTutorialInput = {
    where: TutorialWhereUniqueInput
    update: XOR<TutorialUpdateWithoutNextTutorialInput, TutorialUncheckedUpdateWithoutNextTutorialInput>
    create: XOR<TutorialCreateWithoutNextTutorialInput, TutorialUncheckedCreateWithoutNextTutorialInput>
  }

  export type TutorialUpdateWithWhereUniqueWithoutNextTutorialInput = {
    where: TutorialWhereUniqueInput
    data: XOR<TutorialUpdateWithoutNextTutorialInput, TutorialUncheckedUpdateWithoutNextTutorialInput>
  }

  export type TutorialUpdateManyWithWhereWithoutNextTutorialInput = {
    where: TutorialScalarWhereInput
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyWithoutNextTutorialInput>
  }

  export type TutorialUpsertWithWhereUniqueWithoutTutorialInput = {
    where: TutorialWhereUniqueInput
    update: XOR<TutorialUpdateWithoutTutorialInput, TutorialUncheckedUpdateWithoutTutorialInput>
    create: XOR<TutorialCreateWithoutTutorialInput, TutorialUncheckedCreateWithoutTutorialInput>
  }

  export type TutorialUpdateWithWhereUniqueWithoutTutorialInput = {
    where: TutorialWhereUniqueInput
    data: XOR<TutorialUpdateWithoutTutorialInput, TutorialUncheckedUpdateWithoutTutorialInput>
  }

  export type TutorialUpdateManyWithWhereWithoutTutorialInput = {
    where: TutorialScalarWhereInput
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyWithoutTutorialInput>
  }

  export type LastActivityUpsertWithWhereUniqueWithoutTutorialInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutTutorialInput, LastActivityUncheckedUpdateWithoutTutorialInput>
    create: XOR<LastActivityCreateWithoutTutorialInput, LastActivityUncheckedCreateWithoutTutorialInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutTutorialInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutTutorialInput, LastActivityUncheckedUpdateWithoutTutorialInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutTutorialInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutTutorialInput>
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type UserQuizAttemptCreateWithoutQuizInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: UserProfileCreateNestedOneWithoutQuizAttemptsInput
    questionAttempts?: UserQuestionAttemptCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
    questionAttempts?: UserQuestionAttemptUncheckedCreateNestedManyWithoutQuizAttemptsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizAttemptInput
    userProgress?: UserProgressUncheckedCreateNestedManyWithoutUserQuizAttemptInput
  }

  export type UserQuizAttemptCreateOrConnectWithoutQuizInput = {
    where: UserQuizAttemptWhereUniqueInput
    create: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type UserQuizAttemptCreateManyQuizInputEnvelope = {
    data: UserQuizAttemptCreateManyQuizInput | UserQuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type TutorialCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagCreateNestedManyWithoutTutorialsInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    tutorialTags?: TagUncheckedCreateNestedManyWithoutTutorialsInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutQuizzesInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutQuizzesInput, TutorialUncheckedCreateWithoutQuizzesInput>
  }

  export type TagCreateWithoutQuizzesInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorials?: TutorialCreateNestedManyWithoutTutorialTagsInput
  }

  export type TagUncheckedCreateWithoutQuizzesInput = {
    id?: string
    name: string
    slug: string
    usageCount?: number
    type?: $Enums.TagType
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialTagsInput
  }

  export type TagCreateOrConnectWithoutQuizzesInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput>
  }

  export type RoadmapStepCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: RoadmapStepCreateNestedOneWithoutChildrenInput
    children?: RoadmapStepCreateNestedManyWithoutParentInput
    roadmap?: RoadmapCreateNestedOneWithoutStepsInput
    tutorials?: TutorialCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutQuizzesInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
    roadmapId?: string | null
    children?: RoadmapStepUncheckedCreateNestedManyWithoutParentInput
    tutorials?: TutorialUncheckedCreateNestedManyWithoutStepsInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutRoadmapStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutQuizzesInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutQuizzesInput, RoadmapStepUncheckedCreateWithoutQuizzesInput>
  }

  export type LastActivityCreateWithoutQuizInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorial?: TutorialCreateNestedOneWithoutLastActivitiesInput
    roadmap?: RoadmapCreateNestedOneWithoutLastActivitiesInput
    roadmapStep?: RoadmapStepCreateNestedOneWithoutLastActivitiesInput
    quizAttempt?: UserQuizAttemptCreateNestedOneWithoutLastActivitiesInput
    questionAttempt?: UserQuestionAttemptCreateNestedOneWithoutLastActivitiesInput
    profile?: UserProfileCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityUncheckedCreateWithoutQuizInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
    profile?: UserProfileUncheckedCreateNestedManyWithoutLastActivitiesInput
  }

  export type LastActivityCreateOrConnectWithoutQuizInput = {
    where: LastActivityWhereUniqueInput
    create: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput>
  }

  export type LastActivityCreateManyQuizInputEnvelope = {
    data: LastActivityCreateManyQuizInput | LastActivityCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    questionText?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    xp?: IntFilter<"QuizQuestion"> | number
    quizId?: StringFilter<"QuizQuestion"> | string
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuizQuestion"> | Date | string
  }

  export type UserQuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: UserQuizAttemptWhereUniqueInput
    update: XOR<UserQuizAttemptUpdateWithoutQuizInput, UserQuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<UserQuizAttemptCreateWithoutQuizInput, UserQuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type UserQuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: UserQuizAttemptWhereUniqueInput
    data: XOR<UserQuizAttemptUpdateWithoutQuizInput, UserQuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type UserQuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: UserQuizAttemptScalarWhereInput
    data: XOR<UserQuizAttemptUpdateManyMutationInput, UserQuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type TutorialUpsertWithoutQuizzesInput = {
    update: XOR<TutorialUpdateWithoutQuizzesInput, TutorialUncheckedUpdateWithoutQuizzesInput>
    create: XOR<TutorialCreateWithoutQuizzesInput, TutorialUncheckedCreateWithoutQuizzesInput>
    where?: TutorialWhereInput
  }

  export type TutorialUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: TutorialWhereInput
    data: XOR<TutorialUpdateWithoutQuizzesInput, TutorialUncheckedUpdateWithoutQuizzesInput>
  }

  export type TutorialUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TagUpsertWithWhereUniqueWithoutQuizzesInput = {
    where: TagWhereUniqueInput
    update: XOR<TagUpdateWithoutQuizzesInput, TagUncheckedUpdateWithoutQuizzesInput>
    create: XOR<TagCreateWithoutQuizzesInput, TagUncheckedCreateWithoutQuizzesInput>
  }

  export type TagUpdateWithWhereUniqueWithoutQuizzesInput = {
    where: TagWhereUniqueInput
    data: XOR<TagUpdateWithoutQuizzesInput, TagUncheckedUpdateWithoutQuizzesInput>
  }

  export type TagUpdateManyWithWhereWithoutQuizzesInput = {
    where: TagScalarWhereInput
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyWithoutQuizzesInput>
  }

  export type RoadmapStepUpsertWithoutQuizzesInput = {
    update: XOR<RoadmapStepUpdateWithoutQuizzesInput, RoadmapStepUncheckedUpdateWithoutQuizzesInput>
    create: XOR<RoadmapStepCreateWithoutQuizzesInput, RoadmapStepUncheckedCreateWithoutQuizzesInput>
    where?: RoadmapStepWhereInput
  }

  export type RoadmapStepUpdateToOneWithWhereWithoutQuizzesInput = {
    where?: RoadmapStepWhereInput
    data: XOR<RoadmapStepUpdateWithoutQuizzesInput, RoadmapStepUncheckedUpdateWithoutQuizzesInput>
  }

  export type RoadmapStepUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type LastActivityUpsertWithWhereUniqueWithoutQuizInput = {
    where: LastActivityWhereUniqueInput
    update: XOR<LastActivityUpdateWithoutQuizInput, LastActivityUncheckedUpdateWithoutQuizInput>
    create: XOR<LastActivityCreateWithoutQuizInput, LastActivityUncheckedCreateWithoutQuizInput>
  }

  export type LastActivityUpdateWithWhereUniqueWithoutQuizInput = {
    where: LastActivityWhereUniqueInput
    data: XOR<LastActivityUpdateWithoutQuizInput, LastActivityUncheckedUpdateWithoutQuizInput>
  }

  export type LastActivityUpdateManyWithWhereWithoutQuizInput = {
    where: LastActivityScalarWhereInput
    data: XOR<LastActivityUpdateManyMutationInput, LastActivityUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    tags?: TagCreateNestedManyWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    tags?: TagUncheckedCreateNestedManyWithoutQuizzesInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserCreateWithoutAdminActivityLogsInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAdminActivityLogsInput = {
    id?: string
    username: string
    firstName: string
    lastName?: string | null
    email: string
    passwordHash?: string | null
    role?: $Enums.UserRole
    failedAttempts?: number
    lockedUntil?: Date | string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    emailVerified?: boolean
    verificationToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    roadmaps?: RoadmapUncheckedCreateNestedManyWithoutCreatedByInput
    roadmapProgress?: RoadmapProgressUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAdminActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAdminActivityLogsInput, UserUncheckedCreateWithoutAdminActivityLogsInput>
  }

  export type UserUpsertWithoutAdminActivityLogsInput = {
    update: XOR<UserUpdateWithoutAdminActivityLogsInput, UserUncheckedUpdateWithoutAdminActivityLogsInput>
    create: XOR<UserCreateWithoutAdminActivityLogsInput, UserUncheckedCreateWithoutAdminActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAdminActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAdminActivityLogsInput, UserUncheckedUpdateWithoutAdminActivityLogsInput>
  }

  export type UserUpdateWithoutAdminActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAdminActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    failedAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    roadmaps?: RoadmapUncheckedUpdateManyWithoutCreatedByNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptCreateNestedManyWithoutQuizInput
    tutorial: TutorialCreateNestedOneWithoutQuizzesInput
    steps?: RoadmapStepCreateNestedOneWithoutQuizzesInput
    lastActivities?: LastActivityCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutTagsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: UserQuizAttemptUncheckedCreateNestedManyWithoutQuizInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutTagsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput>
  }

  export type TutorialCreateWithoutTutorialTagsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    quizzes?: QuizCreateNestedManyWithoutTutorialInput
    progress?: UserProgressCreateNestedManyWithoutTutorialInput
    steps?: RoadmapStepCreateNestedOneWithoutTutorialsInput
    tutorial?: TutorialCreateNestedOneWithoutRelatedTutorialsInput
    nextTutorial?: TutorialCreateNestedOneWithoutPreviousTutorialsInput
    previousTutorials?: TutorialCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityCreateNestedManyWithoutTutorialInput
  }

  export type TutorialUncheckedCreateWithoutTutorialTagsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
    quizzes?: QuizUncheckedCreateNestedManyWithoutTutorialInput
    progress?: UserProgressUncheckedCreateNestedManyWithoutTutorialInput
    previousTutorials?: TutorialUncheckedCreateNestedManyWithoutNextTutorialInput
    relatedTutorials?: TutorialUncheckedCreateNestedManyWithoutTutorialInput
    lastActivities?: LastActivityUncheckedCreateNestedManyWithoutTutorialInput
  }

  export type TutorialCreateOrConnectWithoutTutorialTagsInput = {
    where: TutorialWhereUniqueInput
    create: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput>
  }

  export type QuizUpsertWithWhereUniqueWithoutTagsInput = {
    where: QuizWhereUniqueInput
    update: XOR<QuizUpdateWithoutTagsInput, QuizUncheckedUpdateWithoutTagsInput>
    create: XOR<QuizCreateWithoutTagsInput, QuizUncheckedCreateWithoutTagsInput>
  }

  export type QuizUpdateWithWhereUniqueWithoutTagsInput = {
    where: QuizWhereUniqueInput
    data: XOR<QuizUpdateWithoutTagsInput, QuizUncheckedUpdateWithoutTagsInput>
  }

  export type QuizUpdateManyWithWhereWithoutTagsInput = {
    where: QuizScalarWhereInput
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyWithoutTagsInput>
  }

  export type TutorialUpsertWithWhereUniqueWithoutTutorialTagsInput = {
    where: TutorialWhereUniqueInput
    update: XOR<TutorialUpdateWithoutTutorialTagsInput, TutorialUncheckedUpdateWithoutTutorialTagsInput>
    create: XOR<TutorialCreateWithoutTutorialTagsInput, TutorialUncheckedCreateWithoutTutorialTagsInput>
  }

  export type TutorialUpdateWithWhereUniqueWithoutTutorialTagsInput = {
    where: TutorialWhereUniqueInput
    data: XOR<TutorialUpdateWithoutTutorialTagsInput, TutorialUncheckedUpdateWithoutTutorialTagsInput>
  }

  export type TutorialUpdateManyWithWhereWithoutTutorialTagsInput = {
    where: TutorialScalarWhereInput
    data: XOR<TutorialUpdateManyMutationInput, TutorialUncheckedUpdateManyWithoutTutorialTagsInput>
  }

  export type RoadmapCreateManyCreatedByInput = {
    id?: string
    title: string
    description?: string | null
    category?: string | null
    type: $Enums.RoadmapType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RoadmapProgressCreateManyUserInput = {
    id?: string
    roadmapId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminActivityLogCreateManyAdminInput = {
    id?: string
    action: string
    target: string
    targetId: string
    timestamp?: Date | string
  }

  export type RoadmapUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: RoadmapStepUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    steps?: RoadmapStepUncheckedUpdateManyWithoutRoadmapNestedInput
    roadmapProgress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoadmapTypeFieldUpdateOperationsInput | $Enums.RoadmapType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RoadmapProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutRoadmapProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminActivityLogUncheckedUpdateManyWithoutAdminInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    target?: StringFieldUpdateOperationsInput | string
    targetId?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinTransactionCreateManyProfileInput = {
    id?: string
    type: $Enums.TransactionType
    amount: number
    description: string
    transactionAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProgressCreateManyProfileInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuizAttemptCreateManyProfileInput = {
    id?: string
    quizId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserBadgeCreateManyProfileInput = {
    badgeId: string
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoinTransactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinTransactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoinTransactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    amount?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    transactionAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LastActivityUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProgressUpdateWithoutProfileInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorial?: TutorialUpdateOneRequiredWithoutProgressNestedInput
    userQuizAttempt?: UserQuizAttemptUpdateOneWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutProfileInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutProfileInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuizAttemptUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    questionAttempts?: UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionAttempts?: UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUpdateWithoutProfileInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    badge?: BadgeUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutProfileInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutProfileInput = {
    badgeId?: StringFieldUpdateOperationsInput | string
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuestionAttemptCreateManyQuizAttemptsInput = {
    id?: string
    questionId: string
    selectedOption: string
    isCorrect: boolean
    xpEarned?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LastActivityCreateManyQuizAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    questionAttemptId?: string | null
  }

  export type UserProgressCreateManyUserQuizAttemptInput = {
    tutorialId: string
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserQuestionAttemptUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivities?: LastActivityUpdateManyWithoutQuestionAttemptNestedInput
  }

  export type UserQuestionAttemptUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuestionAttemptNestedInput
  }

  export type UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOption?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    xpEarned?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityUpdateWithoutQuizAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutQuizAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutQuizAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProgressUpdateWithoutUserQuizAttemptInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutProgressNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutUserQuizAttemptInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressUncheckedUpdateManyWithoutUserQuizAttemptInput = {
    tutorialId?: StringFieldUpdateOperationsInput | string
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type LastActivityCreateManyQuestionAttemptInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
  }

  export type LastActivityUpdateWithoutQuestionAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutQuestionAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutQuestionAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserProfileUpdateWithoutLastActivitiesInput = {
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUpdateOneWithoutProfileNestedInput
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateWithoutLastActivitiesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
    coinWallet?: CoinWalletUncheckedUpdateOneWithoutProfileNestedInput
    coinTransaction?: CoinTransactionUncheckedUpdateManyWithoutProfileNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutProfileNestedInput
    quizAttempts?: UserQuizAttemptUncheckedUpdateManyWithoutProfileNestedInput
    userBadges?: UserBadgeUncheckedUpdateManyWithoutProfileNestedInput
    streaks?: UserStreakUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateManyWithoutLastActivitiesInput = {
    userId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    socialLinks?: UserProfileUpdatesocialLinksInput | string[]
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    xp?: IntFieldUpdateOperationsInput | number
    levelProgress?: IntFieldUpdateOperationsInput | number
    levelProgressMax?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedQuizzes?: UserProfileUpdatecompletedQuizzesInput | string[]
    completedTutorials?: UserProfileUpdatecompletedTutorialsInput | string[]
    completedRoadmaps?: UserProfileUpdatecompletedRoadmapsInput | string[]
    completedSteps?: UserProfileUpdatecompletedStepsInput | string[]
    completedChallenges?: UserProfileUpdatecompletedChallengesInput | string[]
    completedInterviews?: UserProfileUpdatecompletedInterviewsInput | string[]
    completedProjects?: UserProfileUpdatecompletedProjectsInput | string[]
    theme?: EnumThemeNameFieldUpdateOperationsInput | $Enums.ThemeName
  }

  export type UserBadgeCreateManyBadgeInput = {
    earnedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type UserBadgeUpdateWithoutBadgeInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutUserBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateWithoutBadgeInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutBadgeInput = {
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapStepCreateManyRoadmapInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentId?: string | null
  }

  export type RoadmapProgressCreateManyRoadmapInput = {
    id?: string
    userId: string
    progress?: number
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LastActivityCreateManyRoadmapInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type RoadmapStepUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: RoadmapStepUpdateOneWithoutChildrenNestedInput
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadmapProgressUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoadmapProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadmapStepCreateManyParentInput = {
    id?: string
    title: string
    description?: string | null
    order: number
    status?: $Enums.StepStatus
    progress?: number
    completedAt?: Date | string | null
    completed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmapId?: string | null
  }

  export type TutorialCreateManyStepsInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    tutorialId?: string | null
    nextTutorialId?: string | null
  }

  export type QuizCreateManyStepsInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    tutorialId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type LastActivityCreateManyRoadmapStepInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    tutorialId?: string | null
    roadmapId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type RoadmapStepUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: RoadmapStepUpdateManyWithoutParentNestedInput
    roadmap?: RoadmapUpdateOneWithoutStepsNestedInput
    tutorials?: TutorialUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    children?: RoadmapStepUncheckedUpdateManyWithoutParentNestedInput
    tutorials?: TutorialUncheckedUpdateManyWithoutStepsNestedInput
    quizzes?: QuizUncheckedUpdateManyWithoutStepsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutRoadmapStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    progress?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutorialUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateManyWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LastActivityUpdateWithoutRoadmapStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutRoadmapStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutRoadmapStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizCreateManyTutorialInput = {
    id?: string
    title: string
    slug: string
    isTimed?: boolean
    timeLimit?: number | null
    maxScore?: number
    passPercentage?: number
    difficulty?: $Enums.DifficultyLevel
    order?: number | null
    tutorialLocked?: boolean | null
    questionCount?: number | null
    estimatedDuration?: number | null
    stepsId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserProgressCreateManyTutorialInput = {
    bestAttemptId?: string | null
    lastAttemptId?: string | null
    userQuizAttemptId?: string | null
    isCompleted?: boolean
    completedAt?: Date | string | null
    attempts?: number
    bestScore?: number
    percentageCompleted?: number
    interviewCompleted?: boolean
    challengeCompleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type TutorialCreateManyNextTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    tutorialId?: string | null
  }

  export type TutorialCreateManyTutorialInput = {
    id?: string
    title: string
    description?: string | null
    content: string
    category?: string | null
    authorId?: string | null
    likes?: number
    views?: number
    isLocked?: boolean
    cost?: number
    hasChallenge?: boolean
    difficulty?: $Enums.DifficultyLevel
    status?: $Enums.TutorialStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    stepsId?: string | null
    nextTutorialId?: string | null
  }

  export type LastActivityCreateManyTutorialInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    quizId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type QuizUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tags?: TagUpdateManyWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    tags?: TagUncheckedUpdateManyWithoutQuizzesNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserProgressUpdateWithoutTutorialInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutProgressNestedInput
    userQuizAttempt?: UserQuizAttemptUpdateOneWithoutUserProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutTutorialInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type UserProgressUncheckedUpdateManyWithoutTutorialInput = {
    bestAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    lastAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    userQuizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attempts?: IntFieldUpdateOperationsInput | number
    bestScore?: IntFieldUpdateOperationsInput | number
    percentageCompleted?: IntFieldUpdateOperationsInput | number
    interviewCompleted?: BoolFieldUpdateOperationsInput | boolean
    challengeCompleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizzes?: QuizUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutTutorialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutorialUpdateWithoutNextTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutNextTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateManyWithoutNextTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutorialUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUpdateManyWithoutTutorialsNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    tutorialTags?: TagUncheckedUpdateManyWithoutTutorialsNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateManyWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LastActivityUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutTutorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quizId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    questionText: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer?: string
    xp?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserQuizAttemptCreateManyQuizInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    score?: number
    isPassed?: boolean
    feedback?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profileId: string
  }

  export type LastActivityCreateManyQuizInput = {
    id?: string
    userId: string
    type: $Enums.ActivityType
    description?: string | null
    xpAwarded?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tutorialId?: string | null
    roadmapId?: string | null
    roadmapStepId?: string | null
    quizAttemptId?: string | null
    questionAttemptId?: string | null
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    xp?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserQuizAttemptUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneRequiredWithoutQuizAttemptsNestedInput
    questionAttempts?: UserQuestionAttemptUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
    questionAttempts?: UserQuestionAttemptUncheckedUpdateManyWithoutQuizAttemptsNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizAttemptNestedInput
    userProgress?: UserProgressUncheckedUpdateManyWithoutUserQuizAttemptNestedInput
  }

  export type UserQuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: IntFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: StringFieldUpdateOperationsInput | string
  }

  export type TagUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorials?: TutorialUpdateManyWithoutTutorialTagsNestedInput
  }

  export type TagUncheckedUpdateWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorials?: TutorialUncheckedUpdateManyWithoutTutorialTagsNestedInput
  }

  export type TagUncheckedUpdateManyWithoutQuizzesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    type?: EnumTagTypeFieldUpdateOperationsInput | $Enums.TagType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LastActivityUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorial?: TutorialUpdateOneWithoutLastActivitiesNestedInput
    roadmap?: RoadmapUpdateOneWithoutLastActivitiesNestedInput
    roadmapStep?: RoadmapStepUpdateOneWithoutLastActivitiesNestedInput
    quizAttempt?: UserQuizAttemptUpdateOneWithoutLastActivitiesNestedInput
    questionAttempt?: UserQuestionAttemptUpdateOneWithoutLastActivitiesNestedInput
    profile?: UserProfileUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    profile?: UserProfileUncheckedUpdateManyWithoutLastActivitiesNestedInput
  }

  export type LastActivityUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumActivityTypeFieldUpdateOperationsInput | $Enums.ActivityType
    description?: NullableStringFieldUpdateOperationsInput | string | null
    xpAwarded?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    roadmapStepId?: NullableStringFieldUpdateOperationsInput | string | null
    quizAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
    questionAttemptId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type QuizUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUpdateManyWithoutQuizNestedInput
    tutorial?: TutorialUpdateOneRequiredWithoutQuizzesNestedInput
    steps?: RoadmapStepUpdateOneWithoutQuizzesNestedInput
    lastActivities?: LastActivityUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: UserQuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateManyWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    isTimed?: BoolFieldUpdateOperationsInput | boolean
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    maxScore?: IntFieldUpdateOperationsInput | number
    passPercentage?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    order?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialLocked?: NullableBoolFieldUpdateOperationsInput | boolean | null
    questionCount?: NullableIntFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    tutorialId?: StringFieldUpdateOperationsInput | string
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TutorialUpdateWithoutTutorialTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quizzes?: QuizUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUpdateManyWithoutTutorialNestedInput
    steps?: RoadmapStepUpdateOneWithoutTutorialsNestedInput
    tutorial?: TutorialUpdateOneWithoutRelatedTutorialsNestedInput
    nextTutorial?: TutorialUpdateOneWithoutPreviousTutorialsNestedInput
    previousTutorials?: TutorialUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateWithoutTutorialTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    quizzes?: QuizUncheckedUpdateManyWithoutTutorialNestedInput
    progress?: UserProgressUncheckedUpdateManyWithoutTutorialNestedInput
    previousTutorials?: TutorialUncheckedUpdateManyWithoutNextTutorialNestedInput
    relatedTutorials?: TutorialUncheckedUpdateManyWithoutTutorialNestedInput
    lastActivities?: LastActivityUncheckedUpdateManyWithoutTutorialNestedInput
  }

  export type TutorialUncheckedUpdateManyWithoutTutorialTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: NullableStringFieldUpdateOperationsInput | string | null
    likes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    cost?: IntFieldUpdateOperationsInput | number
    hasChallenge?: BoolFieldUpdateOperationsInput | boolean
    difficulty?: EnumDifficultyLevelFieldUpdateOperationsInput | $Enums.DifficultyLevel
    status?: EnumTutorialStatusFieldUpdateOperationsInput | $Enums.TutorialStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stepsId?: NullableStringFieldUpdateOperationsInput | string | null
    tutorialId?: NullableStringFieldUpdateOperationsInput | string | null
    nextTutorialId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}